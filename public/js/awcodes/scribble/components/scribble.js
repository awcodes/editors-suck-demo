// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = class _Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new _Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new _Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(pos, round = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round > 0)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index, offset } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset - 1, to - offset - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index, offset } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node, index, start + offset);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc3)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
};
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset == pos || node.isText)
        return node;
      pos -= offset + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset } = this.content.findIndex(pos);
    if (offset < pos)
      return { node: this.content.child(index), index, offset };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from2).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++)
      copy2 = this.marks[i].addToSet(copy2);
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
};
Node.prototype.text = void 0;
var TextNode = class _TextNode extends Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max = parseNum(stream);
    else
      max = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min, max, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
var Attribute = class {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule))
        this.tags.push(rule);
      else if (isStyleRule(rule))
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  }
  withStyleRules(dom, f) {
    let style2 = dom.style;
    if (!style2 || !style2.length)
      return f();
    let marks = this.readStyles(dom.style);
    if (!marks)
      return;
    let [addMarks, removeMarks] = marks, top = this.top;
    for (let i = 0; i < removeMarks.length; i++)
      this.removePendingMark(removeMarks[i], top);
    for (let i = 0; i < addMarks.length; i++)
      this.addPendingMark(addMarks[i]);
    f();
    for (let i = 0; i < addMarks.length; i++)
      this.removePendingMark(addMarks[i], top);
    for (let i = 0; i < removeMarks.length; i++)
      this.addPendingMark(removeMarks[i]);
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top = this.top;
    if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, top = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, () => this.addAll(dom));
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, () => {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  // Called for ignored nodes
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles) {
    let add = Mark.none, remove = Mark.none;
    for (let i = 0, l = styles.length; i < l; i++) {
      let name = styles.item(i);
      for (let after = void 0; ; ) {
        let rule = this.parser.matchStyle(name, styles.getPropertyValue(name), this, after);
        if (!rule)
          break;
        if (rule.ignore)
          return null;
        if (rule.clearMark) {
          this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
            if (rule.clearMark(m))
              remove = m.addToSet(remove);
          });
        } else {
          add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
        }
        if (rule.consuming === false)
          after = rule;
        else
          break;
      }
    }
    return [add, remove];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(node.type);
      if (top.match)
        top.match = top.match.matchType(node.type);
      let marks = top.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top.type || top.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top.content.push(node.mark(marks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  }
  // Open a node of the given type
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.applyPending(type);
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
    this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set) {
  for (let i = 0; i < set.length; i++) {
    if (mark.eq(set[i]))
      return set[i];
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(doc3, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc3.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
    let attrs = structure[1], start = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space2 = name.indexOf(" ");
          if (space2 > 0)
            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset) {
  return index + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    this.to = this.maps.push(map2);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this.maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from2, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range.start, end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
      tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr.step(step);
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from2, to, slice2) {
  if (!slice2.size)
    return tr.deleteRange(from2, to);
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from2, to, slice2);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from2, to, node) {
  if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr, from2, to) {
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr.delete($from.before(d), to);
  }
  tr.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from2, to);
      } else {
        tr.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr.mapping.maps[last], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset) {
  for (; ; ) {
    if (node.nodeType == 3 && offset)
      return node;
    if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset) {
  for (; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset, parent) {
  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top, left } = stack[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias);
}
function posFromCaret(view, node, offset, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);
      if (offset < node.childNodes.length) {
        let next = node.childNodes[offset], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset++;
      }
    }
    let prev;
    if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset--;
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset, offset), side);
      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      let before = node.childNodes[offset - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset < nodeSize(node)) {
      let after = node.childNodes[offset];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
    let before = node.childNodes[offset - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset < nodeSize(node)) {
    let after = node.childNodes[offset];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == pos && end != offset) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset - child.border);
      offset = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset)
      return this.children[i].domFromPos(offset - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (from2 > offset && to < end)
        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
      offset = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset && node.nodeValue[offset - 1] == "\n");
        if (brKludge && offset == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {
        let startInside = offset + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset ? this.size : 0);
    return this.posAtStart + offset;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset, this.node.text.length);
    return super.localPosFromDOM(dom, offset, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      active.push(locals[decoIndex++]);
    let end = offset + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset);
        child = child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset, child), index);
    offset = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc3.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset } = view.docView.domFromPos(pos, 0);
  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  let before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))
    force = true;
  for (; ; ) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset) {
  while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset < node.childNodes.length) {
    let next = node.childNodes[offset];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = 0;
  }
}
function textNodeBefore(node, offset) {
  while (node && !offset && !hasBlockDesc(node)) {
    offset = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset) {
    let next = node.childNodes[offset - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset)) {
      node = after;
      offset = 0;
    } else if (before = textNodeBefore(node, offset)) {
      node = before;
      offset = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice2);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset, pos - offset, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset, to.pos - offset, this);
  }
  valid(node, span) {
    let { index, offset } = node.content.findIndex(span.from), child;
    return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset = 0) {
    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset, oldOffset) {
    return this.type.map(mapping, this, offset, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset, span.to + offset));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset, to = children[i + 1] + offset;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset) {
        if (this.children[i] == offset)
          child = this.children[i + 2];
        break;
      }
    let start = offset + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
  if (!offset || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf)
    return null;
  let end = offset + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
        return;
      tr = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr)
    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel2 = resolveSelection(view, tr.doc, parse.sel);
    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr.setSelection(sel2);
  }
  if (storedMarks)
    tr.ensureMarks(storedMarks);
  if (compositionID)
    tr.setMeta("composition", compositionID);
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr = state.tr.step(step);
    tr.setSelection(TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end + 2 * conn.length;
      if (canJoin(tr.doc, joinAt))
        tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end = Fragment.from(wrap2[i].copy(end));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let after = tr.mapping.map(end, -1) - 1;
  if (canJoin(tr.doc, after))
    tr.join(after);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find) => {
  if (isRegExp(find)) {
    return find.exec(text);
  }
  const inputRuleMatch = find(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from: from2,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            const { from: from2, text } = simulatedInputMeta;
            const to = from2 + text.length;
            run$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$1({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find, event) => {
  if (isRegExp(find)) {
    return [...text.matchAll(find)];
  }
  const matches2 = find(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
    const tr = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr
    });
    const handler = run({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr.steps.length) {
      return;
    }
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          const { from: from3, text } = simulatedPasteMeta;
          const to2 = from3 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from3,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return [...new Set(filtered)];
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.parent = this.parent;
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
    var _a;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr.deleteRange(originRange.from, originRange.to);
  const newPos = tr.mapping.map(targetPos);
  tr.insert(newPos, contentSlice.content);
  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) {
    return;
  }
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  findMarkInSet([...start.node.marks], type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index) => fn(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    const parser = DOMParser.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr.mapping.maps[last];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ tr, state, dispatch }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch (e) {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr, dispatch }) => {
  if (dispatch) {
    tr.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr.doc.content.size
  });
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
  const { doc: doc3 } = tr;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch) {
    tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node) {
  var _a;
  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function canSetMark(state, tr, newMarkType) {
  var _a;
  const { selection } = tr;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr, type);
};
var setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, attributes)(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return true;
};
var splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
var joinListForwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after = tr.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, {
            ...node.attrs,
            ...attributes
          });
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinUp: joinUp2,
  joinDown: joinDown2,
  joinBackward: joinBackward2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr }) => {
        const { selection, doc: doc3 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (!isEmpty) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const targetPos = this.pos + offset + 1;
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const oldSelection = this.editor.state.selection;
    this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex
    ] : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr.removeStoredMark(removeMark2);
      }
      tr.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr);
      return true;
    }
    return false;
  }
};
var Node2 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node2.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo2);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node2.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text = Node2.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/extension-text-style/dist/index.js
var TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// resources/js/index.js
function scribbleFormComponent({
  state,
  statePath,
  disabled,
  toolbar = []
}) {
  let editor;
  return {
    updatedAt: Date.now(),
    state,
    statePath,
    disabled,
    toolbar,
    editor() {
      return editor;
    },
    init() {
      const _this = this;
      editor = new Editor({
        element: this.$refs.element,
        extensions: [
          Document,
          Text,
          Paragraph,
          Dropcursor,
          Gapcursor,
          HardBreak,
          History,
          TextStyle,
          Heading,
          Bold,
          Italic
        ],
        content: this.state,
        onCreate({ editor: editor2 }) {
          _this.updatedAt = Date.now();
        },
        onUpdate({ editor: editor2 }) {
          _this.updatedAt = Date.now();
        },
        onSelectionUpdate({ editor: editor2 }) {
          _this.updatedAt = Date.now();
        }
      });
    },
    isActive(type, opts = {}) {
      return editor.isActive(type, opts);
    }
  };
}
export {
  scribbleFormComponent as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWtleW1hcC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvQ29tbWFuZE1hbmFnZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXZlbnRFbWl0dGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlVHlwZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0Z1bmN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2Zyb21TdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1JlZ0V4cC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTnVtYmVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1Bhc3RlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uTWFuYWdlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNQbGFpbk9iamVjdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWVyZ2VEZWVwLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V4dGVuc2lvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2JsdXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJDb250ZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY29tbWFuZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2N1dC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9lbnRlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leGl0Q29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrVHlwZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZmlyc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc1RleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21pbk1heC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc2lPUy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb2N1cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9mb3JFYWNoLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudEF0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1CYWNrd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUZvcndhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pblRleHRibG9ja0JhY2t3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5UZXh0YmxvY2tGb3J3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc01hY09TLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2tleWJvYXJkU2hvcnRjdXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbGlmdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0RW1wdHlCbG9jay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0TGlzdEl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbmV3bGluZUluQ29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9kZWxldGVQcm9wcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9yZXNldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2Nyb2xsSW50b1ZpZXcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0QWxsLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVCYWNrd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3ROb2RlRm9yd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RQYXJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja0VuZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tTdGFydC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldENvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZGVmYXVsdEJsb2NrQXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kQ2hpbGRyZW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kQ2hpbGRyZW5JblJhbmdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZUhUTUwudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZUpTT04udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2VuZXJhdGVUZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Q2hhbmdlZFJhbmdlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldERlYnVnSlNPTi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE5vZGVBdFBvc2l0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNNYXJrQWN0aXZlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0RW5kT2ZOb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBdFN0YXJ0T2ZOb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNMaXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNOb2RlRW1wdHkudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9wb3NUb0RPTVJlY3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0TWFyay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNZXRhLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRUZXh0U2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NpbmtMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zcGxpdEJsb2NrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0TGlzdEl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlV3JhcC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bmRvSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Vuc2V0QWxsTWFya3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VwZGF0ZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3dyYXBJbkxpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9jb21tYW5kcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2VkaXRhYmxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZm9jdXNFdmVudHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9rZXltYXAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy90YWJpbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlUG9zLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3N0eWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FZGl0b3IudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9tYXJrSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvbm9kZUlucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvd3JhcHBpbmdJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTWFyay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0FuZHJvaWQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZVZpZXcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9tYXJrUGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNTdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9UcmFja2VyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9zcmMvZG9jdW1lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9zcmMvZHJvcGN1cnNvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvci9zcmMvZ2FwY3Vyc29yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrL3NyYy9oYXJkLWJyZWFrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9zcmMvaGlzdG9yeS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL3NyYy9wYXJhZ3JhcGgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQvc3JjL3RleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL3RleHQtc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvc3JjL2hlYWRpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvc3JjL2JvbGQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYy9zcmMvaXRhbGljLnRzIiwgIi4uL2pzL2luZGV4LmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyA6Oi0gUGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYW4gb3JkZXJlZCBtYXBwaW5nIGZyb21cbi8vIHN0cmluZ3MgdG8gdmFsdWVzLCB3aXRoIHNvbWUgY29udmVuaWVudCB1cGRhdGUgbWV0aG9kcy5cbmZ1bmN0aW9uIE9yZGVyZWRNYXAoY29udGVudCkge1xuICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xufVxuXG5PcmRlcmVkTWFwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE9yZGVyZWRNYXAsXG5cbiAgZmluZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBpZiAodGhpcy5jb250ZW50W2ldID09PSBrZXkpIHJldHVybiBpXG4gICAgcmV0dXJuIC0xXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykgXHUyMTkyID9hbnlcbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlIHN0b3JlZCB1bmRlciBga2V5YCwgb3IgcmV0dXJuIHVuZGVmaW5lZCB3aGVuXG4gIC8vIG5vIHN1Y2gga2V5IGV4aXN0cy5cbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICByZXR1cm4gZm91bmQgPT0gLTEgPyB1bmRlZmluZWQgOiB0aGlzLmNvbnRlbnRbZm91bmQgKyAxXVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSwgP3N0cmluZykgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSByZXBsYWNpbmcgdGhlIHZhbHVlIG9mIGBrZXlgIHdpdGggYSBuZXdcbiAgLy8gdmFsdWUsIG9yIGFkZGluZyBhIGJpbmRpbmcgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLiBJZiBgbmV3S2V5YCBpc1xuICAvLyBnaXZlbiwgdGhlIGtleSBvZiB0aGUgYmluZGluZyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhhdCBrZXkuXG4gIHVwZGF0ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgbmV3S2V5KSB7XG4gICAgdmFyIHNlbGYgPSBuZXdLZXkgJiYgbmV3S2V5ICE9IGtleSA/IHRoaXMucmVtb3ZlKG5ld0tleSkgOiB0aGlzO1xuICAgIHZhciBmb3VuZCA9IHNlbGYuZmluZChrZXkpLCBjb250ZW50ID0gc2VsZi5jb250ZW50LnNsaWNlKCk7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICBjb250ZW50LnB1c2gobmV3S2V5IHx8IGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50W2ZvdW5kICsgMV0gPSB2YWx1ZTtcbiAgICAgIGlmIChuZXdLZXkpIGNvbnRlbnRbZm91bmRdID0gbmV3S2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4ga2V5IHJlbW92ZWQsIGlmIGl0IGV4aXN0ZWQuXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgaWYgKGZvdW5kID09IC0xKSByZXR1cm4gdGhpc1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQsIDIpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgc3RhcnQgb2YgdGhlIG1hcC5cbiAgYWRkVG9TdGFydDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChba2V5LCB2YWx1ZV0uY29uY2F0KHRoaXMucmVtb3ZlKGtleSkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBlbmQgb2YgdGhlIG1hcC5cbiAgYWRkVG9FbmQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMucmVtb3ZlKGtleSkuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQucHVzaChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBzdHJpbmcsIGFueSkgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEga2V5IGFmdGVyIHRoZSBnaXZlbiBrZXkuIElmIGBwbGFjZWAgaXMgbm90IGZvdW5kLCB0aGUgbmV3XG4gIC8vIGtleSBpcyBhZGRlZCB0byB0aGUgZW5kLlxuICBhZGRCZWZvcmU6IGZ1bmN0aW9uKHBsYWNlLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHdpdGhvdXQgPSB0aGlzLnJlbW92ZShrZXkpLCBjb250ZW50ID0gd2l0aG91dC5jb250ZW50LnNsaWNlKCk7XG4gICAgdmFyIGZvdW5kID0gd2l0aG91dC5maW5kKHBsYWNlKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCA9PSAtMSA/IGNvbnRlbnQubGVuZ3RoIDogZm91bmQsIDAsIGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpKVxuICAvLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgbWFwLCBpblxuICAvLyBvcmRlci5cbiAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgZih0aGlzLmNvbnRlbnRbaV0sIHRoaXMuY29udGVudFtpICsgMV0pO1xuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHByZXBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYmVmb3JlIHRoZSBrZXlzIGluIGBtYXBgLlxuICBwcmVwZW5kOiBmdW5jdGlvbihtYXApIHtcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBpZiAoIW1hcC5zaXplKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChtYXAuY29udGVudC5jb25jYXQodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IGFwcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBhZnRlciB0aGUga2V5cyBpbiBgbWFwYC5cbiAgYXBwZW5kOiBmdW5jdGlvbihtYXApIHtcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBpZiAoIW1hcC5zaXplKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudC5jb25jYXQobWFwLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6ICh1bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAuXG4gIHN1YnRyYWN0OiBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICBtYXAgPSBPcmRlcmVkTWFwLmZyb20obWFwKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlbW92ZShtYXAuY29udGVudFtpXSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6ICgpIFx1MjE5MiBPYmplY3RcbiAgLy8gVHVybiBvcmRlcmVkIG1hcCBpbnRvIGEgcGxhaW4gb2JqZWN0LlxuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJlc3VsdFtrZXldID0gdmFsdWU7IH0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiBudW1iZXJcbiAgLy8gVGhlIGFtb3VudCBvZiBrZXlzIGluIHRoaXMgbWFwLlxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA+PiAxXG4gIH1cbn07XG5cbi8vIDo6ICg/dW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbi8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LiBJZiBudWxsLCBjcmVhdGUgYW4gZW1wdHlcbi8vIG1hcC4gSWYgZ2l2ZW4gYW4gb3JkZXJlZCBtYXAsIHJldHVybiB0aGF0IG1hcCBpdHNlbGYuIElmIGdpdmVuIGFuXG4vLyBvYmplY3QsIGNyZWF0ZSBhIG1hcCBmcm9tIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzLlxuT3JkZXJlZE1hcC5mcm9tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT3JkZXJlZE1hcCkgcmV0dXJuIHZhbHVlXG4gIHZhciBjb250ZW50ID0gW107XG4gIGlmICh2YWx1ZSkgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkgY29udGVudC5wdXNoKHByb3AsIHZhbHVlW3Byb3BdKTtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBPcmRlcmVkTWFwO1xuIiwgImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gICAgZm9yIChsZXQgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICAgICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgc2FtZSA9IDAsIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICAgICAgICAgIHNhbWUrKztcbiAgICAgICAgICAgICAgICBwb3NBLS07XG4gICAgICAgICAgICAgICAgcG9zQi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgfVxufVxuXG4vKipcbkEgZnJhZ21lbnQgcmVwcmVzZW50cyBhIG5vZGUncyBjb2xsZWN0aW9uIG9mIGNoaWxkIG5vZGVzLlxuXG5MaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG5zaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbmluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG4qL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb250ZW50LCBzaXplKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuICAgIHBvc2l0aW9ucyAocmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBmcmFnbWVudCkuIERvZXNuJ3QgZGVzY2VuZFxuICAgIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgbm9kZVN0YXJ0ID0gMCwgcGFyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQgfHwgbnVsbCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIGZyb20gLSBzdGFydCksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBgcG9zYCB3aWxsIGJlXG4gICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC4gVGhlIGNhbGxiYWNrIG1heSByZXR1cm5cbiAgICBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4gICAgW2BOb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlVGV4dCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKVxuICAgICAgICAgICAgICAgIDogIW5vZGUuaXNMZWFmID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICA6IGxlYWZUZXh0ID8gKHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZS50eXBlLnNwZWMubGVhZlRleHQgPyBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgKG5vZGUuaXNMZWFmICYmIG5vZGVUZXh0IHx8IG5vZGUuaXNUZXh0YmxvY2spICYmIGJsb2NrU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gbm9kZVRleHQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgb3RoZXIuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlci5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdENoaWxkLCBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSwgaSA9IDA7XG4gICAgICAgIGlmIChsYXN0LmlzVGV4dCAmJiBsYXN0LnNhbWVNYXJrdXAoZmlyc3QpKSB7XG4gICAgICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29udGVudC5wdXNoKG90aGVyLmNvbnRlbnRbaV0pO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluIHdoaWNoIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpc1xuICAgIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29weSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9FbmQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgZnJhZ21lbnQgdG8gYW5vdGhlciBvbmUuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggdGhpcyBmcmFnbWVudCBhbmQgYW5vdGhlclxuICAgIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuICAgICovXG4gICAgZmluZERpZmZTdGFydChvdGhlciwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24sIHNlYXJjaGluZyBmcm9tIHRoZSBlbmQsIGF0IHdoaWNoIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlXG4gICAgdGhlIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aFxuICAgIG5vZGVzLCBhbiBvYmplY3Qgd2l0aCB0d28gc2VwYXJhdGUgcG9zaXRpb25zIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZmluZERpZmZFbmQob3RoZXIsIHBvcyA9IHRoaXMuc2l6ZSwgb3RoZXJQb3MgPSBvdGhlci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4gICAgcG9zaXRpb24gaW4gdGhpcyBmcmFnbWVudC4gVGhlIHJlc3VsdCBvYmplY3Qgd2lsbCBiZSByZXVzZWRcbiAgICAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKE5vdCBwdWJsaWMuKVxuICAgICovXG4gICAgZmluZEluZGV4KHBvcywgcm91bmQgPSAtMSkge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgodGhpcy5jb250ZW50Lmxlbmd0aCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBvdXRzaWRlIG9mIGZyYWdtZW50ICgke3RoaXN9KWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyUG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGQoaSksIGVuZCA9IGN1clBvcyArIGN1ci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MgfHwgcm91bmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZGVidWdnaW5nIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nSW5uZXIoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChuID0+IG4udG9KU09OKCkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBmcmFnbWVudCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodmFsdWUubWFwKHNjaGVtYS5ub2RlRnJvbUpTT04pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBmcmFnbWVudCBmcm9tIGFuIGFycmF5IG9mIG5vZGVzLiBFbnN1cmVzIHRoYXQgYWRqYWNlbnRcbiAgICB0ZXh0IG5vZGVzIHdpdGggdGhlIHNhbWUgbWFya3MgYXJlIGpvaW5lZCB0b2dldGhlci5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgaWYgKCFhcnJheS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGxldCBqb2luZWQsIHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgJiYgbm9kZS5pc1RleHQgJiYgYXJyYXlbaSAtIDFdLnNhbWVNYXJrdXAobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5lZClcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgICAgICAgICAgICBqb2luZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZyYWdtZW50IGZyb20gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICBzZXQgb2Ygbm9kZXMuIEZvciBgbnVsbGAsIGl0IHJldHVybnMgdGhlIGVtcHR5IGZyYWdtZW50LiBGb3IgYVxuICAgIGZyYWdtZW50LCB0aGUgZnJhZ21lbnQgaXRzZWxmLiBGb3IgYSBub2RlIG9yIGFycmF5IG9mIG5vZGVzLCBhXG4gICAgZnJhZ21lbnQgY29udGFpbmluZyB0aG9zZSBub2Rlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5vZGVzKSB7XG4gICAgICAgIGlmICghbm9kZXMpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIEZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMuYXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2Rlc10sIG5vZGVzLm5vZGVTaXplKTtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgXCIgKyBub2RlcyArIFwiIHRvIGEgRnJhZ21lbnRcIiArXG4gICAgICAgICAgICAobm9kZXMubm9kZXNCZXR3ZWVuID8gXCIgKGxvb2tzIGxpa2UgbXVsdGlwbGUgdmVyc2lvbnMgb2YgcHJvc2VtaXJyb3ItbW9kZWwgd2VyZSBsb2FkZWQpXCIgOiBcIlwiKSk7XG4gICAgfVxufVxuLyoqXG5BbiBlbXB0eSBmcmFnbWVudC4gSW50ZW5kZWQgdG8gYmUgcmV1c2VkIHdoZW5ldmVyIGEgbm9kZSBkb2Vzbid0XG5jb250YWluIGFueXRoaW5nIChyYXRoZXIgdGhhbiBhbGxvY2F0aW5nIGEgbmV3IGVtcHR5IGZyYWdtZW50IGZvclxuZWFjaCBsZWFmIG5vZGUpLlxuKi9cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcbmNvbnN0IGZvdW5kID0geyBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gICAgZm91bmQuaW5kZXggPSBpbmRleDtcbiAgICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghKGEgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIikgfHxcbiAgICAgICAgIShiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQSBtYXJrIGlzIGEgcGllY2Ugb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlLFxuc3VjaCBhcyBpdCBiZWluZyBlbXBoYXNpemVkLCBpbiBjb2RlIGZvbnQsIG9yIGEgbGluay4gSXQgaGFzIGFcbnR5cGUgYW5kIG9wdGlvbmFsbHkgYSBzZXQgb2YgYXR0cmlidXRlcyB0aGF0IHByb3ZpZGUgZnVydGhlclxuaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHRhcmdldCBvZiB0aGUgbGluaykuIE1hcmtzIGFyZSBjcmVhdGVkXG50aHJvdWdoIGEgYFNjaGVtYWAsIHdoaWNoIGNvbnRyb2xzIHdoaWNoIHR5cGVzIGV4aXN0IGFuZCB3aGljaFxuYXR0cmlidXRlcyB0aGV5IGhhdmUuXG4qL1xuY2xhc3MgTWFyayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXJrLlxuICAgICovXG4gICAgYXR0cnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHNldCBvZiBtYXJrcywgY3JlYXRlIGEgbmV3IHNldCB3aGljaCBjb250YWlucyB0aGlzIG9uZSBhc1xuICAgIHdlbGwsIGluIHRoZSByaWdodCBwb3NpdGlvbi4gSWYgdGhpcyBtYXJrIGlzIGFscmVhZHkgaW4gdGhlIHNldCxcbiAgICB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC4gSWYgYW55IG1hcmtzIHRoYXQgYXJlIHNldCB0byBiZVxuICAgIFtleGNsdXNpdmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgd2l0aCB0aGlzIG1hcmsgYXJlIHByZXNlbnQsXG4gICAgdGhvc2UgYXJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBjb3B5LCBwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgICAgaWYgKCFwbGFjZWQpXG4gICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgdGhpcyBtYXJrIGZyb20gdGhlIGdpdmVuIHNldCwgcmV0dXJuaW5nIGEgbmV3IHNldC4gSWYgdGhpc1xuICAgIG1hcmsgaXMgbm90IGluIHRoZSBzZXQsIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGlzIGluIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgYXR0cmlidXRlcyBhc1xuICAgIGFub3RoZXIgbWFyay5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAodGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIG1hcmsgdG8gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIEpTT04uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTWFyay5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubWFya3NbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSAke2pzb24udHlwZX0gaW4gdGhpcyBzY2hlbWFgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbiAgICAqL1xuICAgIHN0YXRpYyBzYW1lU2V0KGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT0gYilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuICAgIHVuc29ydGVkIGFycmF5IG9mIG1hcmtzLlxuICAgICovXG4gICAgc3RhdGljIHNldEZyb20obWFya3MpIHtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspXG4gICAgICAgICAgICByZXR1cm4gW21hcmtzXTtcbiAgICAgICAgbGV0IGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgICBjb3B5LnNvcnQoKGEsIGIpID0+IGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbmspO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG4qL1xuTWFyay5ub25lID0gW107XG5cbi8qKlxuRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG5naXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qXG5SZXBsYWNlRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKVxuICA7KGVyciBhcyBhbnkpLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGVcbiAgcmV0dXJuIGVyclxufSBhcyBhbnlcblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvclxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJSZXBsYWNlRXJyb3JcIlxuKi9cbi8qKlxuQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbnN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbmJvdGggc2lkZSBhcmUgXHUyMDE4b3Blblx1MjAxOSAoY3V0IHRocm91Z2gpLlxuKi9cbmNsYXNzIFNsaWNlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZS4gV2hlbiBzcGVjaWZ5aW5nIGEgbm9uLXplcm8gb3BlbiBkZXB0aCwgeW91IG11c3RcbiAgICBtYWtlIHN1cmUgdGhhdCB0aGVyZSBhcmUgbm9kZXMgb2YgYXQgbGVhc3QgdGhhdCBkZXB0aCBhdCB0aGVcbiAgICBhcHByb3ByaWF0ZSBzaWRlIG9mIHRoZSBmcmFnbWVudFx1MjAxNGkuZS4gaWYgdGhlIGZyYWdtZW50IGlzIGFuXG4gICAgZW1wdHkgcGFyYWdyYXBoIG5vZGUsIGBvcGVuU3RhcnRgIGFuZCBgb3BlbkVuZGAgY2FuJ3QgYmUgZ3JlYXRlclxuICAgIHRoYW4gMS5cbiAgICBcbiAgICBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBvZiBvcGVuIG5vZGVzIHRvIGNvbmZvcm0gdG9cbiAgICB0aGUgc2NoZW1hJ3MgY29udGVudCBjb25zdHJhaW50cywgdGhvdWdoIGl0IHNob3VsZCBiZSBhIHZhbGlkXG4gICAgc3RhcnQvZW5kL21pZGRsZSBmb3Igc3VjaCBhIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlcyBhcmVcbiAgICBvcGVuLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBvcGVuU3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBvcGVuRW5kKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSB0aGlzIHNsaWNlIHdvdWxkIGFkZCB3aGVuIGluc2VydGVkIGludG8gYSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGlzIHNsaWNlIGlzIGVxdWFsIHRvIGFub3RoZXIgc2xpY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbiA9IHsgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5vcGVuRW5kID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCwgb3BlbkVuZCA9IGpzb24ub3BlbkVuZCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNsaWNlLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UgZnJvbSBhIGZyYWdtZW50IGJ5IHRha2luZyB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAgIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXhPcGVuKGZyYWdtZW50LCBvcGVuSXNvbGF0aW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQubGFzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4ubGFzdENoaWxkKVxuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNsaWNlLlxuKi9cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBsZXQgeyBpbmRleDogaW5kZXhUbywgb2Zmc2V0OiBvZmZzZXRUbyB9ID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICAgIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGluZGV4VG8pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2UoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgICBsZXQgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7IC8vIFNpbXBsZSwgZmxhdCBjYXNlXG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gICAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgICBsZXQgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gICAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgICBsZXQgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSlcbiAgICAgICAgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICBlbHNlXG4gICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICAgIGxldCBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICAgIGlmICgkc3RhcnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRzdGFydC50ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGROb2RlKCRzdGFydC5ub2RlQWZ0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gICAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpXG4gICAgICAgIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICAgIG5vZGUudHlwZS5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgICBsZXQgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICAgICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlblN0YXJ0KVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgICAgICBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKG9wZW5FbmQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgIGxldCB0eXBlID0gam9pbmFibGUoJGZyb20sICR0bywgZGVwdGggKyAxKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICAgIGxldCBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICAgIGxldCBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gICAgZm9yIChsZXQgaSA9IGV4dHJhIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKSB9O1xufVxuXG4vKipcbllvdSBjYW4gW19yZXNvbHZlX10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG5yZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHRcbmluZm9ybWF0aW9uLCBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cblxuVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxucGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG5udW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxuKi9cbmNsYXNzIFJlc29sdmVkUG9zIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXRoLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcGFyZW50T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgICAgaWYgKHZhbCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuICAgIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuICAgIHRoZSBwYXJlbnRcdTIwMTR0ZXh0IG5vZGVzIGFyZSBcdTIwMThmbGF0XHUyMDE5IGluIHRoaXMgbW9kZWwsIGFuZCBoYXZlIG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgZ2V0IGRvYygpIHsgcmV0dXJuIHRoaXMubm9kZSgwKTsgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4gICAgc2FtZSBhcyBgcC5wYXJlbnRgLlxuICAgICovXG4gICAgbm9kZShkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHNcbiAgICBhdCB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yXG4gICAgZXhhbXBsZSwgYHAuaW5kZXgoMClgIGlzIDEgYW5kIGBwLmluZGV4KDEpYCBpcyAyLlxuICAgICovXG4gICAgaW5kZXgoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggcG9pbnRpbmcgYWZ0ZXIgdGhpcyBwb3NpdGlvbiBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbC5cbiAgICAqL1xuICAgIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIHN0YXJ0KGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgZW5kKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYmVmb3JlIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgYmVmb3JlKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cbiAgICAqL1xuICAgIGFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuICAgIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvc2l0aW9uIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgdGV4dE9mZnNldCgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4gICAgcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVBZnRlcigpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuICAgIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuICAgIGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUJlZm9yZSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkT2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cbiAgICAqL1xuICAgIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgIHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbiAgICBtYXJrcycgW2BpbmNsdXNpdmVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuaW5jbHVzaXZlKSBwcm9wZXJ0eS4gSWYgdGhlXG4gICAgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbiAgICBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cbiAgICAqL1xuICAgIG1hcmtzKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgICBsZXQgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgYGFmdGVyYCBmbGFnIGlzIHRydWUgb2YgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUsIG1ha2VcbiAgICAgICAgLy8gdGhlIG5vZGUgYWZ0ZXIgdGhpcyBwb3NpdGlvbiB0aGUgbWFpbiByZWZlcmVuY2UuXG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbGV0IHRtcCA9IG1haW47XG4gICAgICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgICAgICAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gICAgICAgIGxldCBtYXJrcyA9IG1haW4ubWFya3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBpZiBhbnksIGV4Y2VwdCB0aG9zZVxuICAgIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuICAgIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4gICAgZGVsZXRpb24uIFdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuICAgIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG4gICAgKi9cbiAgICBtYXJrc0Fjcm9zcygkZW5kKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1hcmtzID0gYWZ0ZXIubWFya3MsIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuICAgIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cbiAgICAqL1xuICAgIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmFuZ2UgYmFzZWQgb24gdGhlIHBsYWNlIHdoZXJlIHRoaXMgcG9zaXRpb24gYW5kIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuICAgIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4gICAgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhleSBwb2ludCBpbnRvIGRpZmZlcmVudCBibG9ja3MsIHRoZSByYW5nZVxuICAgIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4gICAgcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4gICAgbm9kZSB0byBzZWUgaWYgYSByYW5nZSBpbnRvIHRoYXQgcGFyZW50IGlzIGFjY2VwdGFibGUuXG4gICAgKi9cbiAgICBibG9ja1JhbmdlKG90aGVyID0gdGhpcywgcHJlZCkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgICAgICAgICAgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBzYW1lUGFyZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1heChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICAgIHJldHVybiBzdHIgKyBcIjpcIiArIHRoaXMucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIXJlbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVkID0gcmVzb2x2ZUNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZC5wb3MgPT0gcG9zICYmIGNhY2hlZC5kb2MgPT0gZG9jKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc29sdmVDYWNoZVtyZXNvbHZlQ2FjaGVQb3NdID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gICAgICAgIHJlc29sdmVDYWNoZVBvcyA9IChyZXNvbHZlQ2FjaGVQb3MgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxubGV0IHJlc29sdmVDYWNoZSA9IFtdLCByZXNvbHZlQ2FjaGVQb3MgPSAwLCByZXNvbHZlQ2FjaGVTaXplID0gMTI7XG4vKipcblJlcHJlc2VudHMgYSBmbGF0IHJhbmdlIG9mIGNvbnRlbnQsIGkuZS4gb25lIHRoYXQgc3RhcnRzIGFuZFxuZW5kcyBpbiB0aGUgc2FtZSBub2RlLlxuKi9cbmNsYXNzIE5vZGVSYW5nZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbm9kZSByYW5nZS4gYCRmcm9tYCBhbmQgYCR0b2Agc2hvdWxkIHBvaW50IGludG8gdGhlXG4gICAgc2FtZSBub2RlIHVudGlsIGF0IGxlYXN0IHRoZSBnaXZlbiBgZGVwdGhgLCBzaW5jZSBhIG5vZGUgcmFuZ2VcbiAgICBkZW5vdGVzIGFuIGFkamFjZW50IHNldCBvZiBub2RlcyBpbiBhIHNpbmdsZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50LiBNYXkgaGF2ZSBhXG4gICAgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgIHByb3BlcnR5LCBzaW5jZVxuICAgIHRoZXNlIGFyZSB0aGUgcG9zaXRpb25zIHRoYXQgd2VyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJhbmdlLFxuICAgIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzIGJvdW5kYXJpZXMuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgICBjYXZlYXQgZm9yIFtgJGZyb21gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgICAqL1xuICAgICR0bywgXG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLmJlZm9yZSh0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7IHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IGVuZEluZGV4KCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTsgfVxufVxuXG5jb25zdCBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcblByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuXG5Ob2RlcyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMuIEluc3RlYWQgb2YgY2hhbmdpbmcgdGhlbSwgeW91XG5jcmVhdGUgbmV3IG9uZXMgd2l0aCB0aGUgY29udGVudCB5b3Ugd2FudC4gT2xkIG9uZXMga2VlcCBwb2ludGluZ1xuYXQgdGhlIG9sZCBkb2N1bWVudCBzaGFwZS4gVGhpcyBpcyBtYWRlIGNoZWFwZXIgYnkgc2hhcmluZ1xuc3RydWN0dXJlIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3IGRhdGEgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hpY2ggYVxudHJlZSBzaGFwZSBsaWtlIHRoaXMgKHdpdGhvdXQgYmFjayBwb2ludGVycykgbWFrZXMgZWFzeS5cblxuKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcblt0aGUgZ3VpZGVdKC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBBbiBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLiBUaGUga2luZCBvZlxuICAgIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gICAgW2RldGVybWluZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGF0dHJzLCBcbiAgICAvLyBBIGZyYWdtZW50IGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgbWFya3MgKHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQgaXMgZW1waGFzaXplZCBvciBwYXJ0IG9mIGFcbiAgICBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIG1hcmtzID0gTWFyay5ub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSBvZiB0aGlzIG5vZGUsIGFzIGRlZmluZWQgYnkgdGhlIGludGVnZXItYmFzZWQgW2luZGV4aW5nXG4gICAgc2NoZW1lXSgvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4gICAgYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuICAgIG5vbi1sZWFmIG5vZGVzLCBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBwbHVzIHR3byAodGhlXG4gICAgc3RhcnQgYW5kIGVuZCB0b2tlbikuXG4gICAgKi9cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHsgdGhpcy5jb250ZW50LmZvckVhY2goZik7IH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuICAgIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXNcbiAgICBub2RlJ3MgY29udGVudC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aCB0aGUgbm9kZSwgaXRzXG4gICAgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIG5vZGUgKG1ldGhvZCByZWNlaXZlciksXG4gICAgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3MgY2hpbGRyZW4gd2lsbCBub3QgYmVcbiAgICByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhXG4gICAgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlY15sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgZXJyb3Igd2hlbiB0aGV5IGRvIG5vdC5cbiAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSBudWxsO1xuICAgICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgICAgICBtYXJrcyA9IGpzb24ubWFya3MubWFwKHNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS50ZXh0ID0gdW5kZWZpbmVkO1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBzdXBlcih0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLnRleHQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9XG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7IH1cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gICAgd2l0aFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICBjdXQoZnJvbSA9IDAsIHRvID0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgICBmb3IgKGxldCBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG5JbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGUgdHlwZSdzXG5bY29udGVudCBleHByZXNzaW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmUgdXNlZCB0b1xuZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlciBhIGdpdmVuXG5wb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiovXG5jbGFzcyBDb250ZW50TWF0Y2gge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHZhbGlkRW5kKSB7XG4gICAgICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0cmFpbGluZyB0ZXh0XCIpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoRnJhZ21lbnQoZnJhZywgc3RhcnQgPSAwLCBlbmQgPSBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHR5cGUgYXQgdGhpcyBtYXRjaCBwb3NpdGlvbiB0aGF0IGNhblxuICAgIGJlIGdlbmVyYXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0VHlwZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IHRoaXMubmV4dFtpXTtcbiAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCB0aGUgZ2l2ZW4gZnJhZ21lbnQsIGFuZCBpZiB0aGF0IGZhaWxzLCBzZWUgaWYgaXQgY2FuXG4gICAgYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbiAgICBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4gICAgZW1wdHkgaWYgbm90aGluZyBoYWQgdG8gYmUgaW5zZXJ0ZWQpLiBXaGVuIGB0b0VuZGAgaXMgdHJ1ZSwgb25seVxuICAgIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGZpbGxCZWZvcmUoYWZ0ZXIsIHRvRW5kID0gZmFsc2UsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWVuID0gW3RoaXNdO1xuICAgICAgICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAodHAgPT4gdHAuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2godGhpcywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4gICAgZ2l2ZW4gdHlwZSB0byBhcHBlYXIgYXQgdGhpcyBwb3NpdGlvbi4gVGhlIHJlc3VsdCBtYXkgYmUgZW1wdHlcbiAgICAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgICAgbGV0IGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbeyBtYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsIH1dO1xuICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHsgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlLCB2aWE6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZ2V0IGVkZ2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgX25fXHUyMDBCdGggb3V0Z29pbmcgZWRnZSBmcm9tIHRoaXMgbm9kZSBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBlZGdlKG4pIHtcbiAgICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSdzIG5vICR7bn10aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaGApO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2VlbiA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2Vlbi5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgb3V0ICs9IChpID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuY2xhc3MgVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdOyB9XG4gICAgZWF0KHRvaykgeyByZXR1cm4gdGhpcy5uZXh0ID09IHRvayAmJiAodGhpcy5wb3MrKyB8fCB0cnVlKTsgfVxuICAgIGVycihzdHIpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpOyB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSk7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwic2VxXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInBsdXNcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwic3RhclwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJvcHRcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICAgIGxldCBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIilcbiAgICAgICAgICAgIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IC0xO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwicmFuZ2VcIiwgbWluLCBtYXgsIGV4cHIgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICAgIGxldCB0eXBlcyA9IHN0cmVhbS5ub2RlVHlwZXMsIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIFt0eXBlXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgICAgIGlmICh0eXBlLmdyb3Vwcy5pbmRleE9mKG5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLyoqXG5Db25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbk5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG5hcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG50aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG5cbk5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG5uZWNlc3NhcnkuXG4qL1xuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5Ob2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG5hYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxucmVwcmVzZW50cy5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSB0aGUgbm9kZSB0eXBlIGhhcyBpbiB0aGlzIHNjaGVtYS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHNldCBvZiBtYXJrcyBhbGxvd2VkIGluIHRoaXMgbm9kZS4gYG51bGxgIG1lYW5zIGFsbCBtYXJrc1xuICAgICAgICBhcmUgYWxsb3dlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5pc1RleHQgPSBuYW1lID09IFwidGV4dFwiO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdGV4dGJsb2NrIHR5cGUsIGEgYmxvY2sgdGhhdCBjb250YWlucyBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgZm9yIG5vZGUgdHlwZXMgdGhhdCBhbGxvdyBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbiAgICBkaXJlY3RseSBlZGl0YWJsZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207IH1cbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlJ3MgW3doaXRlc3BhY2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy53aGl0ZXNwYWNlKSBvcHRpb24uXG4gICAgKi9cbiAgICBnZXQgd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgICAgZm9yIChsZXQgbiBpbiB0aGlzLmF0dHJzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnNbbl0uaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG5vZGUgYWxsb3dzIHNvbWUgb2YgdGhlIHNhbWUgY29udGVudCBhc1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgTm9kZWAgb2YgdGhpcyB0eXBlLiBUaGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmVcbiAgICBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3NcbiAgICBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuICAgIG1heSBiZSBhIGBGcmFnbWVudGAsIGEgbm9kZSwgYW4gYXJyYXkgb2Ygbm9kZXMsIG9yXG4gICAgYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4gICAgc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbiAgICBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4gICAgaWYgaXQgZG9lc24ndCBtYXRjaC5cbiAgICAqL1xuICAgIGNyZWF0ZUNoZWNrZWQoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgdGhpcy5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXNcbiAgICBuZWNlc3NhcnkgdG8gYWRkIG5vZGVzIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGdpdmVuIGZyYWdtZW50XG4gICAgdG8gbWFrZSBpdCBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLFxuICAgIHJldHVybiBudWxsLiBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhblxuICAgIGFsd2F5cyBiZSBjcmVhdGVkLCB0aGlzIHdpbGwgYWx3YXlzIHN1Y2NlZWQgaWYgeW91IHBhc3MgbnVsbCBvclxuICAgIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbiAgICAqL1xuICAgIGNyZWF0ZUFuZEZpbGwoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGxldCBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgYXR0cnMsIGNvbnRlbnQuYXBwZW5kKGFmdGVyKSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgdmFsaWQgY29udGVudCBmb3IgdGhpcyBub2RlXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIG5vdCB2YWxpZCBjb250ZW50IGZvciB0aGlzXG4gICAgbm9kZSB0eXBlLlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgJHt0aGlzLm5hbWV9OiAke2NvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQXR0cmlidXRlIGRlc2NyaXB0b3JzXG5jbGFzcyBBdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICBnZXQgaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxufVxuLy8gTWFya3Ncbi8qKlxuTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxudGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuW3RhZ2dlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxuKi9cbmNsYXNzIE1hcmtUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmssIFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuICAgIHRoZXkgaGF2ZSBkZWZhdWx0cywgd2lsbCBiZSBhZGRlZC5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLCBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgICAgICAgbWFya3MuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbiAgICB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW2xpbmVicmVha1xuICAgICAgICByZXBsYWNlbWVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSBub2RlIGRlZmluZWRcbiAgICAgICAgaW4gdGhpcyBzY2hlbWEsIGlmIGFueS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBsaW5lYnJlYWsgbm9kZXMgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNJbmxpbmUgfHwgIXR5cGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmVicmVhayByZXBsYWNlbWVudCBub2RlcyBtdXN0IGJlIGlubGluZSBsZWFmIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSB0aGlzLm5vZGVGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbm9kZUZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbWFya0Zyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBpc1RhZ1J1bGUocnVsZSkgeyByZXR1cm4gcnVsZS50YWcgIT0gbnVsbDsgfVxuZnVuY3Rpb24gaXNTdHlsZVJ1bGUocnVsZSkgeyByZXR1cm4gcnVsZS5zdHlsZSAhPSBudWxsOyB9XG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUYWdSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHlsZVJ1bGUocnVsZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKHIgPT4ge1xuICAgICAgICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbiAgICAqL1xuICAgIHBhcnNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2VcbiAgICBbYHBhcnNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2ZcbiAgICBvcHRpb25zLiBCdXQgdW5saWtlIHRoYXQgbWV0aG9kLCB3aGljaCBwcm9kdWNlcyBhIHdob2xlIG5vZGUsXG4gICAgdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuICAgIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4gICAgdGhlIGxlZnQgb2YgdGhlIGlucHV0IGFuZCB0aGUgZW5kIG9mIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBwYXJzZVNsaWNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFRhZyhkb20sIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMudGFnc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKGRvbSwgcnVsZS50YWcpICYmXG4gICAgICAgICAgICAgICAgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiZcbiAgICAgICAgICAgICAgICAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hTdHlsZShwcm9wLCB2YWx1ZSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuc3R5bGVzW2ldLCBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5jb250ZXh0ICYmICFjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIHN0eWxlIHN0cmluZyBlaXRoZXIgcHJlY2lzZWx5IG1hdGNoZXMgdGhlIHByb3AsXG4gICAgICAgICAgICAgICAgLy8gb3IgaGFzIGFuICc9JyBzaWduIGFmdGVyIHRoZSBwcm9wLCBmb2xsb3dlZCBieSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZW5ndGggPiBwcm9wLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGUuY2hhckNvZGVBdChwcm9wLmxlbmd0aCkgIT0gNjEgfHwgc3R5bGUuc2xpY2UocHJvcC5sZW5ndGggKyAxKSAhPSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSByZXN1bHRbaV0sIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShpLCAwLCBydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5ub2Rlc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubm9kZSB8fCBydWxlLmlnbm9yZSB8fCBydWxlLm1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ub2RlID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBET00gcGFyc2VyIHVzaW5nIHRoZSBwYXJzaW5nIHJ1bGVzIGxpc3RlZCBpbiBhXG4gICAgc2NoZW1hJ3MgW25vZGUgc3BlY3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5wYXJzZURPTSksIHJlb3JkZXJlZCBieVxuICAgIFtwcmlvcml0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZS5wcmlvcml0eSkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKHNjaGVtYSwgRE9NUGFyc2VyLnNjaGVtYVJ1bGVzKHNjaGVtYSkpKTtcbiAgICB9XG59XG5jb25zdCBibG9ja1RhZ3MgPSB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGNhbnZhczogdHJ1ZSxcbiAgICBkZDogdHJ1ZSwgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZpZ2NhcHRpb246IHRydWUsIGZpZ3VyZTogdHJ1ZSxcbiAgICBmb290ZXI6IHRydWUsIGZvcm06IHRydWUsIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSxcbiAgICBoNjogdHJ1ZSwgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBsaTogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9sOiB0cnVlLFxuICAgIG91dHB1dDogdHJ1ZSwgcDogdHJ1ZSwgcHJlOiB0cnVlLCBzZWN0aW9uOiB0cnVlLCB0YWJsZTogdHJ1ZSwgdGZvb3Q6IHRydWUsIHVsOiB0cnVlXG59O1xuY29uc3QgaWdub3JlVGFncyA9IHtcbiAgICBoZWFkOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2JqZWN0OiB0cnVlLCBzY3JpcHQ6IHRydWUsIHN0eWxlOiB0cnVlLCB0aXRsZTogdHJ1ZVxufTtcbmNvbnN0IGxpc3RUYWdzID0geyBvbDogdHJ1ZSwgdWw6IHRydWUgfTtcbi8vIFVzaW5nIGEgYml0ZmllbGQgZm9yIG5vZGUgY29udGV4dCBvcHRpb25zXG5jb25zdCBPUFRfUFJFU0VSVkVfV1MgPSAxLCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA9IDIsIE9QVF9PUEVOX0xFRlQgPSA0O1xuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV2hpdGVzcGFjZSwgYmFzZSkge1xuICAgIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8XG4gICAgICAgICAgICAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMCk7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbmNsYXNzIE5vZGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgXG4gICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGlzIG5vZGUgaXRzZWxmXG4gICAgbWFya3MsIFxuICAgIC8vIE1hcmtzIHRoYXQgY2FuJ3QgYXBwbHkgaGVyZSwgYnV0IHdpbGwgYmUgdXNlZCBpbiBjaGlsZHJlbiBpZiBwb3NzaWJsZVxuICAgIHBlbmRpbmdNYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgIC8vIE5lc3RlZCBNYXJrcyB3aXRoIHNhbWUgdHlwZVxuICAgICAgICB0aGlzLnN0YXNoTWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLCB3cmFwO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sIG07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gICAgcG9wRnJvbVN0YXNoTWFyayhtYXJrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXNoTWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAobWFyay5lcSh0aGlzLnN0YXNoTWFya3NbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXNoTWFya3Muc3BsaWNlKGksIDEpWzBdO1xuICAgIH1cbiAgICBhcHBseVBlbmRpbmcobmV4dFR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdNYXJrczsgaSA8IHBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gcGVuZGluZ1tpXTtcbiAgICAgICAgICAgIGlmICgodGhpcy50eXBlID8gdGhpcy50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkgOiBtYXJrTWF5QXBwbHkobWFyay50eXBlLCBuZXh0VHlwZSkpICYmXG4gICAgICAgICAgICAgICAgIW1hcmsuaXNJblNldCh0aGlzLmFjdGl2ZU1hcmtzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVDb250ZXh0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdLmlzSW5saW5lO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIHBhcnNlciB3ZSBhcmUgdXNpbmcuXG4gICAgcGFyc2VyLCBcbiAgICAvLyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhpcyBwYXJzZS5cbiAgICBvcHRpb25zLCBpc09wZW4pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSwgdG9wQ29udGV4dDtcbiAgICAgICAgbGV0IHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICAgICAgaWYgKHRvcE5vZGUpXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2UgaWYgKGlzT3BlbilcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0b3BDb250ZXh0XTtcbiAgICAgICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gICAgLy8gQWRkIGEgRE9NIG5vZGUgdG8gdGhlIGNvbnRlbnQuIFRleHQgaXMgaW5zZXJ0ZWQgYXMgdGV4dCBub2RlLFxuICAgIC8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cbiAgICBhZGRET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tKTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tKTtcbiAgICB9XG4gICAgd2l0aFN0eWxlUnVsZXMoZG9tLCBmKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKCFzdHlsZSB8fCAhc3R5bGUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKGRvbS5zdHlsZSk7XG4gICAgICAgIGlmICghbWFya3MpXG4gICAgICAgICAgICByZXR1cm47IC8vIEEgc3R5bGUgd2l0aCBpZ25vcmU6IHRydWVcbiAgICAgICAgbGV0IFthZGRNYXJrcywgcmVtb3ZlTWFya3NdID0gbWFya3MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsoYWRkTWFya3NbaV0pO1xuICAgICAgICBmKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hdGNoQWZ0ZXIpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcnVsZUlEO1xuICAgICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpXG4gICAgICAgICAgICBub3JtYWxpemVMaXN0KGRvbSk7XG4gICAgICAgIGxldCBydWxlID0gKHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUgJiYgdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZShkb20pKSB8fFxuICAgICAgICAgICAgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgICBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBkb20gPSBydWxlLnNraXA7XG4gICAgICAgICAgICBsZXQgc3luYywgdG9wID0gdGhpcy50b3AsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnNraXApXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4gdGhpcy5hZGRBbGwoZG9tKSk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgaWdub3JlZCBub2Rlc1xuICAgIGlnbm9yZUZhbGxiYWNrKGRvbSkge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGUgc3R5bGVzXG4gICAgLy8gaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBsZXQgYWRkID0gTWFyay5ub25lLCByZW1vdmUgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3R5bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBzdHlsZXMuaXRlbShpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUobmFtZSwgc3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSksIHRoaXMsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmlnbm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcy5jb25jYXQodGhpcy50b3AuYWN0aXZlTWFya3MpLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmsobSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gbS5hZGRUb1NldChyZW1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKS5hZGRUb1NldChhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FkZCwgcmVtb3ZlXTtcbiAgICB9XG4gICAgLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4gICAgLy8gZmFsc2UuIE90aGVyd2lzZSwgYXBwbHkgaXQsIHVzZSBpdHMgcmV0dXJuIHZhbHVlIHRvIGRyaXZlIHRoZSB3YXlcbiAgICAvLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuICAgIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBjb250aW51ZUFmdGVyKSB7XG4gICAgICAgIGxldCBzeW5jLCBub2RlVHlwZSwgbWFyaztcbiAgICAgICAgaWYgKHJ1bGUubm9kZSkge1xuICAgICAgICAgICAgbm9kZVR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbcnVsZS5ub2RlXTtcbiAgICAgICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgc3luYyA9IHRoaXMuZW50ZXIobm9kZVR5cGUsIHJ1bGUuYXR0cnMgfHwgbnVsbCwgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICAgICAgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGludWVBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgY29udGludWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChub2RlID0+IHRoaXMuaW5zZXJ0Tm9kZShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudERPTSA9IGRvbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3RvcihydWxlLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKVxuICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrLCBzdGFydEluKTtcbiAgICB9XG4gICAgLy8gQWRkIGFsbCBjaGlsZCBub2RlcyBiZXR3ZWVuIGBzdGFydEluZGV4YCBhbmQgYGVuZEluZGV4YCAob3IgdGhlXG4gICAgLy8gd2hvbGUgbm9kZSwgaWYgbm90IGdpdmVuKS4gSWYgYHN5bmNgIGlzIHBhc3NlZCwgdXNlIGl0IHRvXG4gICAgLy8gc3luY2hyb25pemUgYWZ0ZXIgZXZlcnkgYmxvY2sgZWxlbWVudC5cbiAgICBhZGRBbGwocGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hZGRET00oZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4gICAgLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuICAgIC8vIG5vZGVzIHRoYXQgd2UncmUgaW4uXG4gICAgZmluZFBsYWNlKG5vZGUpIHtcbiAgICAgICAgbGV0IHJvdXRlLCBzeW5jO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBzeW5jID0gY3g7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN4LnNvbGlkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luYyhzeW5jKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuICAgIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVySW5uZXIoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbmRQbGFjZShub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRvcC5hY3RpdmVNYXJrcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlIHx8IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG5vZGUubWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbm9kZS5tYXJrc1tpXS5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhtYXJrcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gc3RhcnQgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlblxuICAgIC8vIG5lY2Vzc2FyeS5cbiAgICBlbnRlcih0eXBlLCBhdHRycywgcHJlc2VydmVXUykge1xuICAgICAgICBsZXQgb2sgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuICAgIC8vIE9wZW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZW50ZXJJbm5lcih0eXBlLCBhdHRycyA9IG51bGwsIHNvbGlkID0gZmFsc2UsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLmFwcGx5UGVuZGluZyh0eXBlKTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgICAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCB0b3AuYWN0aXZlTWFya3MsIHRvcC5wZW5kaW5nTWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMub3BlbisrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYWxsIG5vZGVzIGFib3ZlIHRoaXMub3BlbiBhcmUgZmluaXNoZWQgYW5kIGFkZGVkIHRvXG4gICAgLy8gdGhlaXIgcGFyZW50c1xuICAgIGNsb3NlRXh0cmEob3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2kgLSAxXS5jb250ZW50LnB1c2godGhpcy5ub2Rlc1tpXS5maW5pc2gob3BlbkVuZCkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKHRoaXMuaXNPcGVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKTtcbiAgICB9XG4gICAgc3luYyh0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldID09IHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBvcygpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29udGVudFtqXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5UZXh0KHRleHROb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGV4dCBzdHJpbmcgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG4gICAgbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgbGV0IHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgbGV0IHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICAgIGxldCBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gICAgICAgIGxldCBtYXRjaCA9IChpLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IChuZXh0Lm5hbWUgIT0gcGFydCAmJiBuZXh0Lmdyb3Vwcy5pbmRleE9mKHBhcnQpID09IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICAgIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgICBsZXQgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgaWYgKCRjb250ZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRQZW5kaW5nTWFyayhtYXJrKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHRoaXMudG9wLnN0YXNoTWFya3MucHVzaChmb3VuZCk7XG4gICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICB9XG4gICAgcmVtb3ZlUGVuZGluZ01hcmsobWFyaywgdXB0bykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBsZXZlbC5wZW5kaW5nTWFya3MubGFzdEluZGV4T2YobWFyayk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFzaE1hcmsgPSBsZXZlbC5wb3BGcm9tU3Rhc2hNYXJrKG1hcmspO1xuICAgICAgICAgICAgICAgIGlmIChzdGFzaE1hcmsgJiYgbGV2ZWwudHlwZSAmJiBsZXZlbC50eXBlLmFsbG93c01hcmtUeXBlKHN0YXNoTWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBzdGFzaE1hcmsuYWRkVG9TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxldmVsID09IHVwdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgZGlyZWN0bHkgbmVzdGVkIGxpc3Qgbm9kZXMgcHJvZHVjZWQgYnkgc29tZVxuLy8gdG9vbHMgYW5kIGFsbG93ZWQgYnkgYnJvd3NlcnMgdG8gbWVhbiB0aGF0IHRoZSBuZXN0ZWQgbGlzdCBpc1xuLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBpdGVtIGFib3ZlIGl0LlxuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkLCBwcmV2SXRlbSA9IG51bGw7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwibGlcIikge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBBcHBseSBhIENTUyBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAoZG9tLm1hdGNoZXMgfHwgZG9tLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLm1vek1hdGNoZXNTZWxlY3RvcikuY2FsbChkb20sIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8vIFVzZWQgd2hlbiBmaW5kaW5nIGEgbWFyayBhdCB0aGUgdG9wIGxldmVsIG9mIGEgZnJhZ21lbnQgcGFyc2UuXG4vLyBDaGVja3Mgd2hldGhlciBpdCB3b3VsZCBiZSByZWFzb25hYmxlIHRvIGFwcGx5IGEgZ2l2ZW4gbWFyayB0eXBlIHRvXG4vLyBhIGdpdmVuIG5vZGUsIGJ5IGxvb2tpbmcgYXQgdGhlIHdheSB0aGUgbWFyayBvY2N1cnMgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG1hcmtNYXlBcHBseShtYXJrVHlwZSwgbm9kZVR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBub2Rlcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc2VlbiA9IFtdLCBzY2FuID0gKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gbm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NhbihwYXJlbnQuY29udGVudE1hdGNoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrLmVxKHNldFtpXSkpXG4gICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbn1cblxuLyoqXG5BIERPTSBzZXJpYWxpemVyIGtub3dzIGhvdyB0byBjb252ZXJ0IFByb3NlTWlycm9yIG5vZGVzIGFuZFxubWFya3Mgb2YgdmFyaW91cyB0eXBlcyB0byBET00gbm9kZXMuXG4qL1xuY2xhc3MgRE9NU2VyaWFsaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VyaWFsaXplci4gYG5vZGVzYCBzaG91bGQgbWFwIG5vZGUgbmFtZXMgdG8gZnVuY3Rpb25zXG4gICAgdGhhdCB0YWtlIGEgbm9kZSBhbmQgcmV0dXJuIGEgZGVzY3JpcHRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICBET00uIGBtYXJrc2AgZG9lcyB0aGUgc2FtZSBmb3IgbWFyayBuYW1lcywgYnV0IGFsc28gZ2V0cyBhblxuICAgIGFyZ3VtZW50IHRoYXQgdGVsbHMgaXQgd2hldGhlciB0aGUgbWFyaydzIGNvbnRlbnQgaXMgYmxvY2sgb3JcbiAgICBpbmxpbmUgY29udGVudCAoZm9yIHR5cGljYWwgdXNlLCBpdCdsbCBhbHdheXMgYmUgaW5saW5lKS4gQSBtYXJrXG4gICAgc2VyaWFsaXplciBtYXkgYmUgYG51bGxgIHRvIGluZGljYXRlIHRoYXQgbWFya3Mgb2YgdGhhdCB0eXBlXG4gICAgc2hvdWxkIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBub2RlcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBtYXJrcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoaXMgZnJhZ21lbnQgdG8gYSBET00gZnJhZ21lbnQuIFdoZW5cbiAgICBub3QgaW4gdGhlIGJyb3dzZXIsIHRoZSBgZG9jdW1lbnRgIG9wdGlvbiwgY29udGFpbmluZyBhIERPTVxuICAgIGRvY3VtZW50LCBzaG91bGQgYmUgcGFzc2VkIHNvIHRoYXQgdGhlIHNlcmlhbGl6ZXIgY2FuIGNyZWF0ZVxuICAgIG5vZGVzLlxuICAgICovXG4gICAgc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMgPSB7fSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRhcmdldCwgYWN0aXZlID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBrZWVwID0gMCwgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5tYXJrc1tyZW5kZXJlZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXJrc1tuZXh0LnR5cGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdWzBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKVsxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtET00gPSB0aGlzLnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKG1hcmtET00uZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZCh0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSkpO1xuICAgICAgICBpZiAoY29udGVudERPTSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIik7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VcbiAgICBuZWVkIHRvIHNlcmlhbGl6ZSBhIHBhcnQgb2YgYSBkb2N1bWVudCwgYXMgb3Bwb3NlZCB0byB0aGUgd2hvbGVcbiAgICBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuICAgIFtgc2VyaWFsaXplRnJhZ21lbnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbiAgICBpdHMgW2NvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLmNvbnRlbnQpLlxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXAgPSB0aGlzLnNlcmlhbGl6ZU1hcmsobm9kZS5tYXJrc1tpXSwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICByZXR1cm4gdG9ET00gJiYgRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbmRlciBhbiBbb3V0cHV0IHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01PdXRwdXRTcGVjKSB0byBhIERPTSBub2RlLiBJZlxuICAgIHRoZSBzcGVjIGhhcyBhIGhvbGUgKHplcm8pIGluIGl0LCBgY29udGVudERPTWAgd2lsbCBwb2ludCBhdCB0aGVcbiAgICBub2RlIHdpdGggdGhlIGhvbGUuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogc3RydWN0dXJlIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUuZG9tICYmIHN0cnVjdHVyZS5kb20ubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gICAgICAgIGxldCB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzcGFjZSA9IHRhZ05hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zbGljZShzcGFjZSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50RE9NO1xuICAgICAgICBsZXQgZG9tID0gKHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gICAgICAgIGxldCBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICAgICAgICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gbmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYWNlID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlKSwgbmFtZS5zbGljZShzcGFjZSArIDEpLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET006IGRvbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZG9tOiBpbm5lciwgY29udGVudERPTTogaW5uZXJDb250ZW50IH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMpO1xuICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERPTSA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbiAgICBwcm9wZXJ0aWVzIGluIGEgc2NoZW1hJ3Mgbm9kZSBhbmQgbWFyayBzcGVjcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbiAgICAqL1xuICAgIHN0YXRpYyBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgcmVzdWx0LnRleHQgPSBub2RlID0+IG5vZGUudGV4dDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG1hcmsgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgbGV0IHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgICAgIGlmICh0b0RPTSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbiIsICJpbXBvcnQgeyBSZXBsYWNlRXJyb3IsIFNsaWNlLCBGcmFnbWVudCwgTWFya1R5cGUsIE1hcmsgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5cbi8vIFJlY292ZXJ5IHZhbHVlcyBlbmNvZGUgYSByYW5nZSBpbmRleCBhbmQgYW4gb2Zmc2V0LiBUaGV5IGFyZVxuLy8gcmVwcmVzZW50ZWQgYXMgbnVtYmVycywgYmVjYXVzZSB0b25zIG9mIHRoZW0gd2lsbCBiZSBjcmVhdGVkIHdoZW5cbi8vIG1hcHBpbmcsIGZvciBleGFtcGxlLCBhIGxhcmdlIG51bWJlciBvZiBkZWNvcmF0aW9ucy4gVGhlIG51bWJlcidzXG4vLyBsb3dlciAxNiBiaXRzIHByb3ZpZGUgdGhlIGluZGV4LCB0aGUgcmVtYWluaW5nIGJpdHMgdGhlIG9mZnNldC5cbi8vXG4vLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBiaXQgc2hpZnQgb3BlcmF0b3JzIHRvIGVuLSBhbmRcbi8vIGRlY29kZSB0aGVzZSwgc2luY2UgdGhvc2UgY2xpcCB0byAzMiBiaXRzLCB3aGljaCB3ZSBtaWdodCBpbiByYXJlXG4vLyBjYXNlcyB3YW50IHRvIG92ZXJmbG93LiBBIDY0LWJpdCBmbG9hdCBjYW4gcmVwcmVzZW50IDQ4LWJpdFxuLy8gaW50ZWdlcnMgcHJlY2lzZWx5LlxuY29uc3QgbG93ZXIxNiA9IDB4ZmZmZjtcbmNvbnN0IGZhY3RvcjE2ID0gTWF0aC5wb3coMiwgMTYpO1xuZnVuY3Rpb24gbWFrZVJlY292ZXIoaW5kZXgsIG9mZnNldCkgeyByZXR1cm4gaW5kZXggKyBvZmZzZXQgKiBmYWN0b3IxNjsgfVxuZnVuY3Rpb24gcmVjb3ZlckluZGV4KHZhbHVlKSB7IHJldHVybiB2YWx1ZSAmIGxvd2VyMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJPZmZzZXQodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAtICh2YWx1ZSAmIGxvd2VyMTYpKSAvIGZhY3RvcjE2OyB9XG5jb25zdCBERUxfQkVGT1JFID0gMSwgREVMX0FGVEVSID0gMiwgREVMX0FDUk9TUyA9IDQsIERFTF9TSURFID0gODtcbi8qKlxuQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIG1hcHBlZCBwb3NpdGlvbiB3aXRoIGV4dHJhXG5pbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBNYXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG1hcHBlZCB2ZXJzaW9uIG9mIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkZWxJbmZvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZGVsSW5mbyA9IGRlbEluZm87XG4gICAgICAgIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwb3NpdGlvbiB3YXMgZGVsZXRlZCwgdGhhdCBpcywgd2hldGhlciB0aGVcbiAgICBzdGVwIHJlbW92ZWQgdGhlIHRva2VuIG9uIHRoZSBzaWRlIHF1ZXJpZWQgKHZpYSB0aGUgYGFzc29jYClcbiAgICBhcmd1bWVudCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9TSURFKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgdG9rZW4gYmVmb3JlIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEJlZm9yZSgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0JFRk9SRSB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIHRva2VuIGFmdGVyIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFmdGVyKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQUZURVIgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgd2hldGhlciBhbnkgb2YgdGhlIHN0ZXBzIG1hcHBlZCB0aHJvdWdoIGRlbGV0ZXMgYWNyb3NzIHRoZVxuICAgIHBvc2l0aW9uIChpbmNsdWRpbmcgYm90aCB0aGUgdG9rZW4gYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAgICBwb3NpdGlvbikuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFjcm9zcygpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfQUNST1NTKSA+IDA7IH1cbn1cbi8qKlxuQSBtYXAgZGVzY3JpYmluZyB0aGUgZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zIG1hZGUgYnkgYSBzdGVwLCB3aGljaFxuY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlXG5wcmUtc3RlcCB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgYW5kIHRoZSBzYW1lIHBvc2l0aW9uIGluIHRoZVxucG9zdC1zdGVwIHZlcnNpb24uXG4qL1xuY2xhc3MgU3RlcE1hcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcG9zaXRpb24gbWFwLiBUaGUgbW9kaWZpY2F0aW9ucyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycywgaW4gd2hpY2ggZWFjaCBncm91cCBvZiB0aHJlZVxuICAgIHJlcHJlc2VudHMgYSBtb2RpZmllZCBjaHVuayBhcyBgW3N0YXJ0LCBvbGRTaXplLCBuZXdTaXplXWAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnZlcnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiBTdGVwTWFwLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcih2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmludmVydGVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSAqIDMgKyAyXSAtIHRoaXMucmFuZ2VzW2kgKiAzICsgMV07XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpO1xuICAgIH1cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gIW9sZFNpemUgPyBhc3NvYyA6IHBvcyA9PSBzdGFydCA/IC0xIDogcG9zID09IGVuZCA/IDEgOiBhc3NvYztcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gc3RhcnQgKyBkaWZmICsgKHNpZGUgPCAwID8gMCA6IG5ld1NpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlY292ZXIgPSBwb3MgPT0gKGFzc29jIDwgMCA/IHN0YXJ0IDogZW5kKSA/IG51bGwgOiBtYWtlUmVjb3ZlcihpIC8gMywgcG9zIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBkZWwgPSBwb3MgPT0gc3RhcnQgPyBERUxfQUZURVIgOiBwb3MgPT0gZW5kID8gREVMX0JFRk9SRSA6IERFTF9BQ1JPU1M7XG4gICAgICAgICAgICAgICAgaWYgKGFzc29jIDwgMCA/IHBvcyAhPSBzdGFydCA6IHBvcyAhPSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGRlbCB8PSBERUxfU0lERTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcFJlc3VsdChyZXN1bHQsIGRlbCwgcmVjb3Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgKyBkaWZmIDogbmV3IE1hcFJlc3VsdChwb3MgKyBkaWZmLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b3VjaGVzKHBvcywgcmVjb3Zlcikge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHJlY292ZXIpO1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb24gZWFjaCBvZiB0aGUgY2hhbmdlZCByYW5nZXMgaW5jbHVkZWQgaW5cbiAgICB0aGlzIG1hcC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZGlmZiA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sIG9sZFN0YXJ0ID0gc3RhcnQgLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKSwgbmV3U3RhcnQgPSBzdGFydCArICh0aGlzLmludmVydGVkID8gMCA6IGRpZmYpO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XTtcbiAgICAgICAgICAgIGYob2xkU3RhcnQsIG9sZFN0YXJ0ICsgb2xkU2l6ZSwgbmV3U3RhcnQsIG5ld1N0YXJ0ICsgbmV3U2l6ZSk7XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwLiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIHRvXG4gICAgbWFwIHBvc2l0aW9ucyBpbiB0aGUgcG9zdC1zdGVwIGRvY3VtZW50IHRvIHRoZSBwcmUtc3RlcCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbnZlcnRlZCA/IFwiLVwiIDogXCJcIikgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcCB0aGF0IG1vdmVzIGFsbCBwb3NpdGlvbnMgYnkgb2Zmc2V0IGBuYCAod2hpY2ggbWF5IGJlXG4gICAgbmVnYXRpdmUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBhcHBseWluZyBzdGVwcyBtZWFudCBmb3IgYVxuICAgIHN1Yi1kb2N1bWVudCB0byBhIGxhcmdlciBkb2N1bWVudCwgb3IgdmljZS12ZXJzYS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZmZzZXQobikge1xuICAgICAgICByZXR1cm4gbiA9PSAwID8gU3RlcE1hcC5lbXB0eSA6IG5ldyBTdGVwTWFwKG4gPCAwID8gWzAsIC1uLCAwXSA6IFswLCAwLCBuXSk7XG4gICAgfVxufVxuLyoqXG5BIFN0ZXBNYXAgdGhhdCBjb250YWlucyBubyBjaGFuZ2VkIHJhbmdlcy5cbiovXG5TdGVwTWFwLmVtcHR5ID0gbmV3IFN0ZXBNYXAoW10pO1xuLyoqXG5BIG1hcHBpbmcgcmVwcmVzZW50cyBhIHBpcGVsaW5lIG9mIHplcm8gb3IgbW9yZSBbc3RlcFxubWFwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwTWFwKS4gSXQgaGFzIHNwZWNpYWwgcHJvdmlzaW9ucyBmb3IgbG9zc2xlc3NseVxuaGFuZGxpbmcgbWFwcGluZyBwb3NpdGlvbnMgdGhyb3VnaCBhIHNlcmllcyBvZiBzdGVwcyBpbiB3aGljaCBzb21lXG5zdGVwcyBhcmUgaW52ZXJ0ZWQgdmVyc2lvbnMgb2YgZWFybGllciBzdGVwcy4gKFRoaXMgY29tZXMgdXAgd2hlblxuXHUyMDE4W3JlYmFzaW5nXSgvZG9jcy9ndWlkZS8jdHJhbnNmb3JtLnJlYmFzaW5nKVx1MjAxOSBzdGVwcyBmb3JcbmNvbGxhYm9yYXRpb24gb3IgaGlzdG9yeSBtYW5hZ2VtZW50LilcbiovXG5jbGFzcyBNYXBwaW5nIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbWFwcGluZyB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBtYXBzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0ZXAgbWFwcyBpbiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBtYXBzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWlycm9yLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheSwgdXNlZCB3aGVuIGBtYXBgIG9yXG4gICAgYG1hcFJlc3VsdGAgaXMgY2FsbGVkLlxuICAgICovXG4gICAgZnJvbSA9IDAsIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheS5cbiAgICAqL1xuICAgIHRvID0gbWFwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXBzID0gbWFwcztcbiAgICAgICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwcGluZyB0aGF0IG1hcHMgb25seSB0aHJvdWdoIGEgcGFydCBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20gPSAwLCB0byA9IHRoaXMubWFwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLnNsaWNlKCksIHRoaXMubWlycm9yICYmIHRoaXMubWlycm9yLnNsaWNlKCksIHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHN0ZXAgbWFwIHRvIHRoZSBlbmQgb2YgdGhpcyBtYXBwaW5nLiBJZiBgbWlycm9yc2AgaXNcbiAgICBnaXZlbiwgaXQgc2hvdWxkIGJlIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBpcyB0aGUgbWlycm9yXG4gICAgaW1hZ2Ugb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXAobWFwLCBtaXJyb3JzKSB7XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLm1hcHMucHVzaChtYXApO1xuICAgICAgICBpZiAobWlycm9ycyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRNaXJyb3IodGhpcy5tYXBzLmxlbmd0aCAtIDEsIG1pcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYWxsIHRoZSBzdGVwIG1hcHMgaW4gYSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lIChwcmVzZXJ2aW5nXG4gICAgbWlycm9yaW5nIGluZm9ybWF0aW9uKS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXSwgbWlyciAhPSBudWxsICYmIG1pcnIgPCBpID8gc3RhcnRTaXplICsgbWlyciA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZHMgdGhlIG9mZnNldCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBtaXJyb3JzIHRoZSBtYXAgYXQgdGhlXG4gICAgZ2l2ZW4gb2Zmc2V0LCBpbiB0aGlzIG1hcHBpbmcgKGFzIHBlciB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgYGFwcGVuZE1hcGApLlxuICAgICovXG4gICAgZ2V0TWlycm9yKG4pIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1pcnJvci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JbaV0gPT0gbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yW2kgKyAoaSAlIDIgPyAtMSA6IDEpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRNaXJyb3IobiwgbSkge1xuICAgICAgICBpZiAoIXRoaXMubWlycm9yKVxuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSBbXTtcbiAgICAgICAgdGhpcy5taXJyb3IucHVzaChuLCBtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIHRoZSBpbnZlcnNlIG9mIHRoZSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZ0ludmVydGVkKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoICsgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0uaW52ZXJ0KCksIG1pcnIgIT0gbnVsbCAmJiBtaXJyID4gaSA/IHRvdGFsU2l6ZSAtIG1pcnIgLSAxIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIGxldCBpbnZlcnNlID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGludmVyc2UuYXBwZW5kTWFwcGluZ0ludmVydGVkKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLCByZXR1cm5pbmcgYSBtYXBwaW5nXG4gICAgcmVzdWx0LlxuICAgICovXG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGVsSW5mbyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLm1hcHNbaV0sIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JyID0gdGhpcy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcnIgIT0gbnVsbCAmJiBjb3JyID4gaSAmJiBjb3JyIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgICAgICBpID0gY29ycjtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2NvcnJdLnJlY292ZXIocmVzdWx0LnJlY292ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxJbmZvIHw9IHJlc3VsdC5kZWxJbmZvO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zIDogbmV3IE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIG51bGwpO1xuICAgIH1cbn1cblxuY29uc3Qgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuQSBzdGVwIG9iamVjdCByZXByZXNlbnRzIGFuIGF0b21pYyBjaGFuZ2UuIEl0IGdlbmVyYWxseSBhcHBsaWVzXG5vbmx5IHRvIHRoZSBkb2N1bWVudCBpdCB3YXMgY3JlYXRlZCBmb3IsIHNpbmNlIHRoZSBwb3NpdGlvbnNcbnN0b3JlZCBpbiBpdCB3aWxsIG9ubHkgbWFrZSBzZW5zZSBmb3IgdGhhdCBkb2N1bWVudC5cblxuTmV3IHN0ZXBzIGFyZSBkZWZpbmVkIGJ5IGNyZWF0aW5nIGNsYXNzZXMgdGhhdCBleHRlbmQgYFN0ZXBgLFxub3ZlcnJpZGluZyB0aGUgYGFwcGx5YCwgYGludmVydGAsIGBtYXBgLCBgZ2V0TWFwYCBhbmQgYGZyb21KU09OYFxubWV0aG9kcywgYW5kIHJlZ2lzdGVyaW5nIHlvdXIgY2xhc3Mgd2l0aCBhIHVuaXF1ZVxuSlNPTi1zZXJpYWxpemF0aW9uIGlkZW50aWZpZXIgdXNpbmdcbltgU3RlcC5qc29uSURgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBeanNvbklEKS5cbiovXG5jbGFzcyBTdGVwIHtcbiAgICAvKipcbiAgICBHZXQgdGhlIHN0ZXAgbWFwIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgc3RlcCxcbiAgICBhbmQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZSBvbGRcbiAgICBhbmQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldE1hcCgpIHsgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWVyZ2UgdGhpcyBzdGVwIHdpdGggYW5vdGhlciBvbmUsIHRvIGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICBhZnRlciBpdC4gUmV0dXJucyB0aGUgbWVyZ2VkIHN0ZXAgd2hlbiBwb3NzaWJsZSwgbnVsbCBpZiB0aGVcbiAgICBzdGVwcyBjYW4ndCBiZSBtZXJnZWQuXG4gICAgKi9cbiAgICBtZXJnZShvdGhlcikgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RlcCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaWxsIGNhbGxcbiAgICB0aHJvdWdoIHRvIHRoZSBzdGVwIGNsYXNzJyBvd24gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi5zdGVwVHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzdGVwc0J5SURbanNvbi5zdGVwVHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzdGVwIHR5cGUgJHtqc29uLnN0ZXBUeXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmZyb21KU09OKHNjaGVtYSwganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHN0ZXBzIHRvIEpTT04sIGVhY2ggc3RlcCBuZWVkcyBhIHN0cmluZ1xuICAgIElEIHRvIGF0dGFjaCB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVXNlIHRoaXMgbWV0aG9kIHRvXG4gICAgcmVnaXN0ZXIgYW4gSUQgZm9yIHlvdXIgc3RlcCBjbGFzc2VzLiBUcnkgdG8gcGljayBzb21ldGhpbmdcbiAgICB0aGF0J3MgdW5saWtlbHkgdG8gY2xhc2ggd2l0aCBzdGVwcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzdGVwQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIHN0ZXBzQnlJRClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzdGVwIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIHN0ZXBzQnlJRFtpZF0gPSBzdGVwQ2xhc3M7XG4gICAgICAgIHN0ZXBDbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzdGVwQ2xhc3M7XG4gICAgfVxufVxuLyoqXG5UaGUgcmVzdWx0IG9mIFthcHBseWluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwLmFwcGx5KSBhIHN0ZXAuIENvbnRhaW5zIGVpdGhlciBhXG5uZXcgZG9jdW1lbnQgb3IgYSBmYWlsdXJlIHZhbHVlLlxuKi9cbmNsYXNzIFN0ZXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50LCBpZiBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgZmFpbHVyZSBtZXNzYWdlLCBpZiB1bnN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBmYWlsZWQpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gZmFpbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdWNjZXNzZnVsIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIG9rKGRvYykgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQoZG9jLCBudWxsKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZhaWxlZCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmYWlsKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KG51bGwsIG1lc3NhZ2UpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdpdGggdGhlIGdpdmVuXG4gICAgYXJndW1lbnRzLiBDcmVhdGUgYSBzdWNjZXNzZnVsIHJlc3VsdCBpZiBpdCBzdWNjZWVkcywgYW5kIGFcbiAgICBmYWlsZWQgb25lIGlmIGl0IHRocm93cyBhIGBSZXBsYWNlRXJyb3JgLlxuICAgICovXG4gICAgc3RhdGljIGZyb21SZXBsYWNlKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZXBsYWNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwRnJhZ21lbnQoZnJhZ21lbnQsIGYsIHBhcmVudCkge1xuICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnbWVudC5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY29weShtYXBGcmFnbWVudChjaGlsZC5jb250ZW50LCBmLCBjaGlsZCkpO1xuICAgICAgICBpZiAoY2hpbGQuaXNJbmxpbmUpXG4gICAgICAgICAgICBjaGlsZCA9IGYoY2hpbGQsIHBhcmVudCwgaSk7XG4gICAgICAgIG1hcHBlZC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShtYXBwZWQpO1xufVxuLyoqXG5BZGQgYSBtYXJrIHRvIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgQWRkTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLCAkZnJvbSA9IGRvYy5yZXNvbHZlKHRoaXMuZnJvbSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKCRmcm9tLnNoYXJlZERlcHRoKHRoaXMudG8pKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIChub2RlLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0F0b20gfHwgIXBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKHRoaXMubWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgcGFyZW50KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEFkZE1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSZW1vdmVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgbm9kZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgZG9jKSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU1hcmtcIiwgUmVtb3ZlTWFya1N0ZXApO1xuLyoqXG5BZGQgYSBtYXJrIHRvIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBZGROb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmIChuZXdTZXQubGVuZ3RoID09IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubWFya3NbaV0uaXNJblNldChuZXdTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIG5vZGUubWFya3NbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGROb2RlTWFya1wiLCBBZGROb2RlTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIFJlbW92ZU5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5tYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVOb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU5vZGVNYXJrXCIsIFJlbW92ZU5vZGVNYXJrU3RlcCk7XG5cbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBuZXcgY29udGVudC5cbiovXG5jbGFzcyBSZXBsYWNlU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIFRoZSBnaXZlbiBgc2xpY2VgIHNob3VsZCBmaXQgdGhlICdnYXAnIGJldHdlZW4gYGZyb21gIGFuZFxuICAgIGB0b2BcdTIwMTR0aGUgZGVwdGhzIG11c3QgbGluZSB1cCwgYW5kIHRoZSBzdXJyb3VuZGluZyBub2RlcyBtdXN0IGJlXG4gICAgYWJsZSB0byBiZSBqb2luZWQgd2l0aCB0aGUgb3BlbiBzaWRlcyBvZiB0aGUgc2xpY2UuIFdoZW5cbiAgICBgc3RydWN0dXJlYCBpcyB0cnVlLCB0aGUgc3RlcCB3aWxsIGZhaWwgaWYgdGhlIGNvbnRlbnQgYmV0d2VlblxuICAgIGZyb20gYW5kIHRvIGlzIG5vdCBqdXN0IGEgc2VxdWVuY2Ugb2YgY2xvc2luZyBhbmQgdGhlbiBvcGVuaW5nXG4gICAgdG9rZW5zICh0aGlzIGlzIHRvIGd1YXJkIGFnYWluc3QgcmViYXNlZCByZXBsYWNlIHN0ZXBzXG4gICAgb3ZlcndyaXRpbmcgc29tZXRoaW5nIHRoZXkgd2VyZW4ndCBzdXBwb3NlZCB0bykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy50bykpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIHJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy50byAtIHRoaXMuZnJvbSwgdGhpcy5zbGljZS5zaXplXSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLnBvcywgTWF0aC5tYXgoZnJvbS5wb3MsIHRvLnBvcyksIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwKSB8fCBvdGhlci5zdHJ1Y3R1cmUgfHwgdGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSA9PSBvdGhlci5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5FbmQgJiYgIW90aGVyLnNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy50byArIChvdGhlci50byAtIG90aGVyLmZyb20pLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2Uob3RoZXIuc2xpY2UuY29udGVudC5hcHBlbmQodGhpcy5zbGljZS5jb250ZW50KSwgb3RoZXIuc2xpY2Uub3BlblN0YXJ0LCB0aGlzLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChvdGhlci5mcm9tLCB0aGlzLnRvLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZVwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZVN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VcIiwgUmVwbGFjZVN0ZXApO1xuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIGNvbnRlbnQsIGJ1dFxucHJlc2VydmUgYSByYW5nZSBvZiB0aGUgcmVwbGFjZWQgY29udGVudCBieSBtb3ZpbmcgaXQgaW50byB0aGVcbnNsaWNlLlxuKi9cbmNsYXNzIFJlcGxhY2VBcm91bmRTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZS1hcm91bmQgc3RlcCB3aXRoIHRoZSBnaXZlbiByYW5nZSBhbmQgZ2FwLlxuICAgIGBpbnNlcnRgIHNob3VsZCBiZSB0aGUgcG9pbnQgaW4gdGhlIHNsaWNlIGludG8gd2hpY2ggdGhlIGNvbnRlbnRcbiAgICBvZiB0aGUgZ2FwIHNob3VsZCBiZSBtb3ZlZC4gYHN0cnVjdHVyZWAgaGFzIHRoZSBzYW1lIG1lYW5pbmcgYXNcbiAgICBpdCBoYXMgaW4gdGhlIFtgUmVwbGFjZVN0ZXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlJlcGxhY2VTdGVwKSBjbGFzcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwRnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBUbywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gaW4gdGhlIHNsaWNlIHdoZXJlIHRoZSBwcmVzZXJ2ZWQgcmFuZ2Ugc2hvdWxkIGJlXG4gICAgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICBpbnNlcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmdhcEZyb20gPSBnYXBGcm9tO1xuICAgICAgICB0aGlzLmdhcFRvID0gZ2FwVG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIChjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy5nYXBGcm9tKSB8fFxuICAgICAgICAgICAgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmdhcFRvLCB0aGlzLnRvKSkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIGdhcC1yZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICBsZXQgZ2FwID0gZG9jLnNsaWNlKHRoaXMuZ2FwRnJvbSwgdGhpcy5nYXBUbyk7XG4gICAgICAgIGlmIChnYXAub3BlblN0YXJ0IHx8IGdhcC5vcGVuRW5kKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkdhcCBpcyBub3QgYSBmbGF0IHJhbmdlXCIpO1xuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSB0aGlzLnNsaWNlLmluc2VydEF0KHRoaXMuaW5zZXJ0LCBnYXAuY29udGVudCk7XG4gICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiQ29udGVudCBkb2VzIG5vdCBmaXQgaW4gZ2FwXCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuaW5zZXJ0LFxuICAgICAgICAgICAgdGhpcy5nYXBUbywgdGhpcy50byAtIHRoaXMuZ2FwVG8sIHRoaXMuc2xpY2Uuc2l6ZSAtIHRoaXMuaW5zZXJ0XSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IGdhcCA9IHRoaXMuZ2FwVG8gLSB0aGlzLmdhcEZyb207XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgKyBnYXAsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0LCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCArIGdhcCwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykucmVtb3ZlQmV0d2Vlbih0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuZ2FwVG8gLSB0aGlzLmZyb20pLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgbGV0IGdhcEZyb20gPSB0aGlzLmZyb20gPT0gdGhpcy5nYXBGcm9tID8gZnJvbS5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKTtcbiAgICAgICAgbGV0IGdhcFRvID0gdGhpcy50byA9PSB0aGlzLmdhcFRvID8gdG8ucG9zIDogbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gsIGNsZWFyTmV3bGluZXMgPSB0cnVlKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgbGV0IHJlcGxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGxldCBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgICAgIGlmIChjbGVhck5ld2xpbmVzICYmIGNoaWxkLmlzVGV4dCAmJiBwYXJlbnRUeXBlLndoaXRlc3BhY2UgIT0gXCJwcmVcIikge1xuICAgICAgICAgICAgICAgIGxldCBtLCBuZXdsaW5lID0gL1xccj9cXG58XFxyL2csIHNsaWNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHBhcmVudFR5cGUuc2NoZW1hLnRleHQoXCIgXCIsIHBhcmVudFR5cGUuYWxsb3dlZE1hcmtzKGNoaWxkLm1hcmtzKSkpLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciArIG0uaW5kZXgsIGN1ciArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgc2xpY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZW5kO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoLnZhbGlkRW5kKSB7XG4gICAgICAgIGxldCBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIHRyLnJlcGxhY2UoY3VyLCBjdXIsIG5ldyBTbGljZShmaWxsLCAwLCAwKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSByZXBsU3RlcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHRyLnN0ZXAocmVwbFN0ZXBzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2FuQ3V0KG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJlxuICAgICAgICAoZW5kID09IG5vZGUuY2hpbGRDb3VudCB8fCBub2RlLmNhblJlcGxhY2UoMCwgZW5kKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdGFyZ2V0IGRlcHRoIHRvIHdoaWNoIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZVxuY2FuIGJlIGxpZnRlZC4gV2lsbCBub3QgZ28gYWNyb3NzXG5baXNvbGF0aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuaXNvbGF0aW5nKSBwYXJlbnQgbm9kZXMuXG4qL1xuZnVuY3Rpb24gbGlmdFRhcmdldChyYW5nZSkge1xuICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgbGV0IGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgICBmb3IgKGxldCBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgaW5kZXggPSByYW5nZS4kZnJvbS5pbmRleChkZXB0aCksIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpO1xuICAgICAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxpZnQodHIsIHJhbmdlLCB0YXJnZXQpIHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvLCBkZXB0aCB9ID0gcmFuZ2U7XG4gICAgbGV0IGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksIGdhcEVuZCA9ICR0by5hZnRlcihkZXB0aCArIDEpO1xuICAgIGxldCBzdGFydCA9IGdhcFN0YXJ0LCBlbmQgPSBnYXBFbmQ7XG4gICAgbGV0IGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBvcGVuU3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkZnJvbS5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgfVxuICAgIGxldCBhZnRlciA9IEZyYWdtZW50LmVtcHR5LCBvcGVuRW5kID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJHRvLmFmdGVyKGQgKyAxKSA8ICR0by5lbmQoZCkpIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20oJHRvLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBnYXBTdGFydCwgZ2FwRW5kLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIG9wZW5TdGFydCwgb3BlbkVuZCksIGJlZm9yZS5zaXplIC0gb3BlblN0YXJ0LCB0cnVlKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdmFsaWQgd2F5IHRvIHdyYXAgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIGluIGFcbm5vZGUgb2YgdGhlIGdpdmVuIHR5cGUuIE1heSBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgYXJvdW5kIGFuZCBpbnNpZGVcbnRoZSB3cmFwcGVyIG5vZGUsIGlmIG5lY2Vzc2FyeS4gUmV0dXJucyBudWxsIGlmIG5vIHZhbGlkIHdyYXBwaW5nXG5jb3VsZCBiZSBmb3VuZC4gV2hlbiBgaW5uZXJSYW5nZWAgaXMgZ2l2ZW4sIHRoYXQgcmFuZ2UncyBjb250ZW50IGlzXG51c2VkIGFzIHRoZSBjb250ZW50IHRvIGZpdCBpbnRvIHRoZSB3cmFwcGluZywgaW5zdGVhZCBvZiB0aGVcbmNvbnRlbnQgb2YgYHJhbmdlYC5cbiovXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyA9IG51bGwsIGlubmVyUmFuZ2UgPSByYW5nZSkge1xuICAgIGxldCBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gICAgbGV0IGlubmVyID0gYXJvdW5kICYmIGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKCFpbm5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKVxuICAgICAgICAuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUsIGF0dHJzIH0pLmNvbmNhdChpbm5lci5tYXAod2l0aEF0dHJzKSk7XG59XG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkgeyByZXR1cm4geyB0eXBlLCBhdHRyczogbnVsbCB9OyB9XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gICAgaWYgKCFhcm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgbGV0IGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgICBpZiAoIWluc2lkZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICAgIGxldCBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpO1xuICAgIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cbmZ1bmN0aW9uIHdyYXAodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHdyYXBwZXJzW2ldLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldyYXBwZXIgdHlwZSBnaXZlbiB0byBUcmFuc2Zvcm0ud3JhcCBkb2VzIG5vdCBmb3JtIHZhbGlkIGNvbnRlbnQgb2YgaXRzIHBhcmVudCB3cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgc3RhcnQsIGVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gICAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgZ2l2ZW4gdG8gc2V0QmxvY2tUeXBlIHNob3VsZCBiZSBhIHRleHRibG9ja1wiKTtcbiAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRycykgJiYgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgY29udmVydE5ld2xpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmUgPSB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiwgc3VwcG9ydExpbmVicmVhayA9ICEhdHlwZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlICYmICFzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcHJlICYmIHN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgICAgICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxpbmVicmVha3ModHIsIG5vZGUsIHBvcywgbWFwRnJvbSk7XG4gICAgICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0ciwgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSwgdW5kZWZpbmVkLCBjb252ZXJ0TmV3bGluZXMgPT09IG51bGwpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZztcbiAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgMSArIG9mZnNldCArIG0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQuY3JlYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKSB7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09IGNoaWxkLnR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyAxICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEudGV4dChcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IHN0ZXAgPSBuZXcgUmVwbGFjZVN0ZXAocG9zIC0gZGVwdGgsIHBvcyArIGRlcHRoLCBTbGljZS5lbXB0eSwgdHJ1ZSk7XG4gICAgdHIuc3RlcChzdGVwKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG5cdTIwMThGaXRcdTIwMTkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIGRvYyBub2RlLlxuKi9cbmNsYXNzIERvY0F0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gZG9jLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGRvYy50eXBlLmNyZWF0ZShhdHRycywgZG9jLmNvbnRlbnQsIGRvYy5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAodGhpcy5hdHRyLCBkb2MuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImRvY0F0dHJcIiwgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIERvY0F0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJkb2NBdHRyXCIsIERvY0F0dHJTdGVwKTtcblxuLyoqXG5AaW50ZXJuYWxcbiovXG5sZXQgVHJhbnNmb3JtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiBlcnI7XG59O1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcbi8qKlxuQWJzdHJhY3Rpb24gdG8gYnVpbGQgdXAgYW5kIHRyYWNrIGFuIGFycmF5IG9mXG5bc3RlcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uXG5cbk1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xudGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxuKi9cbmNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zZm9ybSkuXG4gICAgKi9cbiAgICBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBkb2N1bWVudHMgYmVmb3JlIGVhY2ggb2YgdGhlIHN0ZXBzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7IH1cbiAgICAvKipcbiAgICBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4gICAgZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cbiAgICAqL1xuICAgIHN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAoc3RlcCk7XG4gICAgICAgIGlmIChyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuICAgIGZhaWxzLiBSZXR1cm5zIHRoZSBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNoYW5nZWQgKHdoZW4gdGhlcmUgYXJlIGFueVxuICAgIHN0ZXBzKS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbiAgICBnaXZlbiBgc2xpY2VgLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuICAgIGZyYWdtZW50LCBub2RlLCBvciBhcnJheSBvZiBub2Rlcy5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBkZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIHNsaWNlLCB1c2luZ1xuICAgIGBmcm9tYCwgYHRvYCwgYW5kIHRoZSBzbGljZSdzXG4gICAgW2BvcGVuU3RhcnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2xpY2Uub3BlblN0YXJ0KSBwcm9wZXJ0eSBhcyBoaW50cywgcmF0aGVyXG4gICAgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5IGdyb3cgdGhlXG4gICAgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0byBnZXQgYVxuICAgIGZpdCB0aGF0IGlzIG1vcmUgaW4gbGluZSB3aXRoIFdZU0lXWUcgZXhwZWN0YXRpb25zLCBieSBkcm9wcGluZ1xuICAgIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlbiB0aGV5IGFyZVxuICAgIG1hcmtlZCBbbm9uLWRlZmluaW5nIGFzXG4gICAgY29udGV4dF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nQXNDb250ZXh0KSwgb3IgaW5jbHVkaW5nIGFuXG4gICAgb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzIFtkZWZpbmluZ1xuICAgIGl0cyBjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdGb3JDb250ZW50KS5cbiAgICBcbiAgICBUaGlzIGlzIHRoZSBtZXRob2QsIGZvciBleGFtcGxlLCB0byBoYW5kbGUgcGFzdGUuIFRoZSBzaW1pbGFyXG4gICAgW2ByZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuICAgIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbiAgICByYW5nZSwgYW5kIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIG1vcmUgcHJlY2lzZVxuICAgIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4gICAgaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuICAgIGFuZCBhcmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHBhcmVudCBub2RlIGluIHdoaWNoIHRoZSBnaXZlblxuICAgIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuICAgIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgY29tcGxldGVseSBjb3ZlcnMgYSBwYXJlbnQgbm9kZSwgdGhpcyBtZXRob2QgbWF5IGNvbXBsZXRlbHkgcmVwbGFjZVxuICAgIHRoYXQgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbiAgICBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuICAgICovXG4gICAgZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4gICAgaXMgc2libGluZyBjb250ZW50IGJlZm9yZSBvciBhZnRlciBpdCwgYW5kIG1vdmUgaXQgdXAgdGhlIHRyZWUgdG9cbiAgICB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAgICBbYGxpZnRUYXJnZXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2VcbiAgICBzdXJlIHRoZSBsaWZ0IGlzIHZhbGlkLlxuICAgICovXG4gICAgbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICAgIGxpZnQodGhpcywgcmFuZ2UsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIHRoZSBibG9ja3MgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgZGVwdGggaXMgMiwgdGhlaXJcbiAgICBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIGpvaW4ocG9zLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbiAgICBUaGUgd3JhcHBlcnMgYXJlIGFzc3VtZWQgdG8gYmUgdmFsaWQgaW4gdGhpcyBwb3NpdGlvbiwgYW5kIHNob3VsZFxuICAgIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG4gICAgKi9cbiAgICB3cmFwKHJhbmdlLCB3cmFwcGVycykge1xuICAgICAgICB3cmFwKHRoaXMsIHJhbmdlLCB3cmFwcGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHR5cGUgb2YgYWxsIHRleHRibG9ja3MgKHBhcnRseSkgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgdG9cbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzZXRCbG9ja1R5cGUoZnJvbSwgdG8gPSBmcm9tLCB0eXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICAgICAgc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbiAgICBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4gICAgKi9cbiAgICBzZXROb2RlTWFya3VwKHBvcywgdHlwZSwgYXR0cnMgPSBudWxsLCBtYXJrcykge1xuICAgICAgICBzZXROb2RlTWFya3VwKHRoaXMsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYSBnaXZlbiBub2RlIHRvIGEgbmV3IHZhbHVlLlxuICAgIFRoZSBgcG9zYCBhZGRyZXNzZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQuIFVzZSBgc2V0RG9jQXR0cmlidXRlYFxuICAgIHRvIHNldCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgKi9cbiAgICBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBdHRyU3RlcChwb3MsIGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldERvY0F0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IERvY0F0dHJTdGVwKGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBub2RlIGF0IHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgYWRkTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayAob3IgYSBtYXJrIG9mIHRoZSBnaXZlbiB0eXBlKSBmcm9tIHRoZSBub2RlIGF0XG4gICAgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICByZW1vdmVOb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgaWYgKCEobWFyayBpbnN0YW5jZW9mIE1hcmspKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgICAgICBtYXJrID0gbWFyay5pc0luU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKCFtYXJrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgb3B0aW9uYWxseSwgaWYgYGRlcHRoYCBpc1xuICAgIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4gICAgcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhbiBhcnJheSBvZiB0eXBlcyBhbmQgYXR0cmlidXRlcyB0b1xuICAgIHVzZSBhZnRlciB0aGUgc3BsaXQuXG4gICAgKi9cbiAgICBzcGxpdChwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgICAgICBzcGxpdCh0aGlzLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gbWFyayB0byB0aGUgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBhZGRNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIGFkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIG1hcmtzIGZyb20gaW5saW5lIG5vZGVzIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYG1hcmtgIGlzIGEgc2luZ2xlIG1hcmssIHJlbW92ZSBwcmVjaXNlbHkgdGhhdCBtYXJrLiBXaGVuIGl0IGlzXG4gICAgYSBtYXJrIHR5cGUsIHJlbW92ZSBhbGwgbWFya3Mgb2YgdGhhdCB0eXBlLiBXaGVuIGl0IGlzIG51bGwsXG4gICAgcmVtb3ZlIGFsbCBtYXJrcyBvZiBhbnkgdHlwZS5cbiAgICAqL1xuICAgIHJlbW92ZU1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgcmVtb3ZlTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIGFsbCBtYXJrcyBhbmQgbm9kZXMgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgbm9kZSBhdFxuICAgIGBwb3NgIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGdpdmVuIG5ldyBwYXJlbnQgbm9kZSB0eXBlLiBBY2NlcHRzXG4gICAgYW4gb3B0aW9uYWwgc3RhcnRpbmcgW2NvbnRlbnQgbWF0Y2hdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Db250ZW50TWF0Y2gpIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjbGVhckluY29tcGF0aWJsZShwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRoaXMsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFkZE1hcmtTdGVwLCBBZGROb2RlTWFya1N0ZXAsIEF0dHJTdGVwLCBEb2NBdHRyU3RlcCwgTWFwUmVzdWx0LCBNYXBwaW5nLCBSZW1vdmVNYXJrU3RlcCwgUmVtb3ZlTm9kZU1hcmtTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAsIFN0ZXAsIFN0ZXBNYXAsIFN0ZXBSZXN1bHQsIFRyYW5zZm9ybSwgVHJhbnNmb3JtRXJyb3IsIGNhbkpvaW4sIGNhblNwbGl0LCBkcm9wUG9pbnQsIGZpbmRXcmFwcGluZywgaW5zZXJ0UG9pbnQsIGpvaW5Qb2ludCwgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAgfTtcbiIsICJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhXG5wcm9wZXJ0aWVzOiBpdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWVcbmB0cnVlYCB0byBzZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaFxuaW5wdXQsIGEgYFwiY29tcG9zaXRpb25cImAgcHJvcGVydHkgaG9sZGluZyBhbiBJRCBpZGVudGlmeWluZyB0aGVcbmNvbXBvc2l0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIHRyYW5zYWN0aW9ucyBjYXVzZWQgYnkgY29tcG9zZWQgRE9NXG5pbnB1dCwgYW5kIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCxcbmBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbmNvbnN0IGNsZWFyUmV1c2VkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV1c2VkUmFuZ2UgPSBudWxsO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbm9kZVNpemUobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZVNpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUkMShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyJDEobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc09uRWRnZShub2RlLCBvZmZzZXQsIHBhcmVudCkge1xuICAgIGZvciAobGV0IGF0U3RhcnQgPSBvZmZzZXQgPT0gMCwgYXRFbmQgPSBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSk7IGF0U3RhcnQgfHwgYXRFbmQ7KSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgaW5kZXggPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhdFN0YXJ0ID0gYXRTdGFydCAmJiBpbmRleCA9PSAwO1xuICAgICAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgICBsZXQgZGVzYztcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChkZXNjID0gY3VyLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKTtcbn1cbi8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbi8vIChpc0NvbGxhcHNlZCBpbmFwcHJvcHJpYXRlbHkgcmV0dXJucyB0cnVlIGluIHNoYWRvdyBkb20pXG5jb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBmdW5jdGlvbiAoZG9tU2VsKSB7XG4gICAgcmV0dXJuIGRvbVNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59O1xuZnVuY3Rpb24ga2V5RXZlbnQoa2V5Q29kZSwga2V5KSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICAgIGV2ZW50LmtleSA9IGV2ZW50LmNvZGUgPSBrZXk7XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KGRvYywgeCwgeSkge1xuICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICB0cnkgeyAvLyBGaXJlZm94IHRocm93cyBmb3IgdGhpcyBjYWxsIGluIGhhcmQtdG8tcHJlZGljdCBjaXJjdW1zdGFuY2VzICgjOTk0KVxuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBwb3Mub2Zmc2V0Tm9kZSwgb2Zmc2V0OiBwb3Mub2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgIH1cbiAgICBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0IH07XG4gICAgfVxufVxuXG5jb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCBhZ2VudCA9IChuYXYgJiYgbmF2LnVzZXJBZ2VudCkgfHwgXCJcIjtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5jb25zdCBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgY2hyb21lID0gISFfY2hyb21lO1xuY29uc3QgY2hyb21lX3ZlcnNpb24gPSBfY2hyb21lID8gK19jaHJvbWVbMV0gOiAwO1xuY29uc3Qgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbi8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbmNvbnN0IG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xuY29uc3Qgd2luZG93cyA9IG5hdiA/IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlO1xuY29uc3QgYW5kcm9pZCA9IC9BbmRyb2lkIFxcZC8udGVzdChhZ2VudCk7XG5jb25zdCB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgICBsZXQgdnAgPSBkb2MuZGVmYXVsdFZpZXcgJiYgZG9jLmRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0O1xuICAgIGlmICh2cClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsIHJpZ2h0OiB2cC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBBZGp1c3QgZm9yIGVsZW1lbnRzIHdpdGggc3R5bGUgXCJ0cmFuc2Zvcm06IHNjYWxlKClcIlxuICAgIGxldCBzY2FsZVggPSAocmVjdC53aWR0aCAvIG5vZGUub2Zmc2V0V2lkdGgpIHx8IDE7XG4gICAgbGV0IHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIG5vZGUuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gICAgbGV0IHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCwgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzsgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICBsZXQgYXRUb3AgPSBlbHQgPT0gZG9jLmJvZHk7XG4gICAgICAgIGxldCBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInRvcFwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgPyByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgIDogcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwibGVmdFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcbiAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcuc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFggPSBlbHQuc2Nyb2xsTGVmdCwgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVkpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICBsZXQgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdFRvcCB8fCAvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24pKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydFkgPSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgbGV0IHJlZkRPTSwgcmVmVG9wO1xuICAgIGZvciAobGV0IHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbG9jYWxSZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gICAgbGV0IHN0YWNrID0gW10sIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7IGRvbTogY3VyLCB0b3A6IGN1ci5zY3JvbGxUb3AsIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICBpZiAoZG9tID09IGRvYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG4vLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMgdG8gdGhhdCB3aGF0XG4vLyBpdCB3YXMgYmVmb3JlLCB3aGVuIHN0b3JlU2Nyb2xsUG9zIHdhcyBjYWxsZWQuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyh7IHJlZkRPTSwgcmVmVG9wLCBzdGFjayB9KSB7XG4gICAgbGV0IG5ld1JlZlRvcCA9IHJlZkRPTSA/IHJlZkRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgZFRvcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZG9tLCB0b3AsIGxlZnQgfSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKVxuICAgICAgICAgICAgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgZG9tLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgY2xvc2VzdCwgZHhDbG9zZXN0ID0gMmU4LCBjb29yZHNDbG9zZXN0LCBvZmZzZXQgPSAwO1xuICAgIGxldCByb3dCb3QgPSBjb29yZHMudG9wLCByb3dUb3AgPSBjb29yZHMudG9wO1xuICAgIGxldCBmaXJzdEJlbG93LCBjb29yZHNCZWxvdztcbiAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgbGV0IHJlY3RzO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnRvcCA+IGNvb3Jkcy50b3AgJiYgIWZpcnN0QmVsb3cgJiYgcmVjdC5sZWZ0IDw9IGNvb3Jkcy5sZWZ0ICYmIHJlY3QucmlnaHQgPj0gY29vcmRzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29vcmRzQmVsb3cgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgTWF0aC5taW4ocmVjdC5yaWdodCwgY29vcmRzLmxlZnQpKSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHxcbiAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0ICYmIGZpcnN0QmVsb3cpIHtcbiAgICAgICAgY2xvc2VzdCA9IGZpcnN0QmVsb3c7XG4gICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBjb29yZHNCZWxvdztcbiAgICAgICAgZHhDbG9zZXN0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgICBpZiAoIWNsb3Nlc3QgfHwgKGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpKVxuICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQgfTtcbiAgICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpO1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50IHx8ICFkZXNjLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSB0aGUgaG9yaXpvbnRhbCB0ZXN0IHRvIHRoZSBpbm5lcm1vc3QgYmxvY2suIFZlcnRpY2FsIGZvciBhbnkgcGFyZW50LlxuICAgICAgICAgICAgICAgIGlmICghc2F3QmxvY2sgJiYgcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgfHwgcmVjdC50b3AgPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2F3QmxvY2sgJiYgcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0IHx8IHJlY3QuYm90dG9tIDwgY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgICAgICBzYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MuY29udGVudERPTSAmJiBvdXRzaWRlQmxvY2sgPCAwICYmICFkZXNjLm5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhIGxlYWYsIHJldHVybiB0aGUgc2lkZSBvZiB0aGUgbGVhZiBjbG9zZXIgdG8gdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBkZXNjLm5vZGUuaXNCbG9jayA/IGNvb3Jkcy50b3AgPCAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogY29vcmRzLmxlZnQgPCAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUgPyBkZXNjLnBvc0JlZm9yZSA6IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZGVzYy5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHNpZGVCbG9jayA+IC0xID8gb3V0c2lkZUJsb2NrIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCAtMSk7XG59XG5mdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KGVsZW1lbnQsIGNvb3JkcywgYm94KSB7XG4gICAgbGV0IGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBib3gudG9wIDwgYm94LmJvdHRvbSkge1xuICAgICAgICBmb3IgKGxldCBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudEZyb21Qb2ludChjaGlsZCwgY29vcmRzLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudCwgbm9kZSwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgY2FyZXQgPSBjYXJldEZyb21Qb2ludChkb2MsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBpZiAoY2FyZXQpXG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gY2FyZXQpO1xuICAgIGxldCBlbHQgPSAodmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2MpXG4gICAgICAgIC5lbGVtZW50RnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBsZXQgcG9zO1xuICAgIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgICAgICBsZXQgYm94ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghaW5SZWN0KGNvb3JkcywgYm94KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHQgPSBlbGVtZW50RnJvbVBvaW50KHZpZXcuZG9tLCBjb29yZHMsIGJveCk7XG4gICAgICAgIGlmICghZWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgcmV0dXJucyBub25zZW5zZSB3aGVuIG9uIGEgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICBpZiAoc2FmYXJpKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICAgICAgICBpZiAocC5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHdpbGwgc29tZXRpbWVzIHJldHVybiBvZmZzZXRzIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2hcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gYWN0dWFsIGNoaWxkcmVuLCBmcm9tIGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgKCM5NTMpXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gSXQnbGwgYWxzbyBtb3ZlIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBiZWZvcmUgaW1hZ2Ugbm9kZXMsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRob3NlIGFyZSBiZWhpbmQgaXQuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIGJveDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlTmFtZSA9PSBcIklNR1wiICYmIChib3ggPSBuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5yaWdodCA8PSBjb29yZHMubGVmdCAmJlxuICAgICAgICAgICAgICAgICAgICBib3guYm90dG9tID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXY7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgYWJvdmUgdGhlIHJpZ2h0IHNpZGUgb2YgYW4gdW5lZGl0YWJsZSBub2RlLCBDaHJvbWUgd2lsbCByZXBvcnQgYSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLlxuICAgICAgICBpZiAod2Via2l0ICYmIG9mZnNldCAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgKHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0pLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiAmJiBwcmV2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA+PSBjb29yZHMudG9wKVxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIC8vIFN1c3BpY2lvdXNseSBzcGVjaWZpYyBrbHVkZ2UgdG8gd29yayBhcm91bmQgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSAmJiBub2RlLmxhc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb25zIGRpcmVjdGx5IGFmdGVyIGEgQlIsIHNpbmNlIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBCUiBub2RlLlxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT0gMCB8fCBub2RlLm5vZGVUeXBlICE9IDEgfHwgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpO1xuICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xIH07XG59XG5mdW5jdGlvbiBub25aZXJvKHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPCByZWN0LmJvdHRvbSB8fCByZWN0LmxlZnQgPCByZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gc2luZ2xlUmVjdCh0YXJnZXQsIGJpYXMpIHtcbiAgICBsZXQgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9uWmVybyhmaXJzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCBub25aZXJvKSB8fCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5jb25zdCBCSURJID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCwgYXRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgbGV0IHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAgICAgLy8gYmlkaSBjb250ZXh0IG9yIHdoZW4gYXQgdGhlIGVuZCBvZiBhIG5vZGUuXG4gICAgICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgYmFkIHJlc3VsdHMgKHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIHNwYWNlKVxuICAgICAgICAgICAgLy8gd2hlbiBxdWVyeWluZyBhIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIGxpbmUtYnJva2VuXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBEZXRlY3QgdGhpcyBzaXR1YXRpb24gYW5kIGFuZCBrbHVkZ2UgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RBZnRlci50b3AgIT0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG9mZnNldCwgdG8gPSBvZmZzZXQsIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBmcm9tLCB0byksIHRha2VTaWRlKSwgdGFrZVNpZGUgPCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgJGRvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zIC0gKGF0b20gfHwgMCkpO1xuICAgIC8vIFJldHVybiBhIGhvcml6b250YWwgbGluZSBpbiBibG9jayBjb250ZXh0XG4gICAgaWYgKCEkZG9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChiZWZvcmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHNpZGUgPj0gMCk7XG4gICAgfVxuICAgIC8vIElubGluZSwgbm90IGluIHRleHQgbm9kZSAodGhpcyBpcyBub3QgQmlkaS1zYWZlKVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGxldCB0YXJnZXQgPSBiZWZvcmUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShiZWZvcmUsIG5vZGVTaXplKGJlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICAvLyBCUiBub2RlcyB0ZW5kIHRvIG9ubHkgcmV0dXJuIHRoZSByZWN0YW5nbGUgYmVmb3JlIHRoZW0uXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgICAgICA6IGJlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChiZWZvcmUubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUubmV4dFNpYmxpbmcpID8gYmVmb3JlIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgMSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgd2hpbGUgKGFmdGVyLnBtVmlld0Rlc2MgJiYgYWZ0ZXIucG1WaWV3RGVzYy5pZ25vcmVGb3JDb29yZHMpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gIWFmdGVyID8gbnVsbCA6IGFmdGVyLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYWZ0ZXIsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIDogYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IGFmdGVyIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgLTEpLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gQWxsIGVsc2UgZmFpbGVkLCBqdXN0IHRyeSB0byBnZXQgYSByZWN0YW5nbGUgZm9yIHRoZSB0YXJnZXQgbm9kZVxuICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgICBpZiAocmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20sIGxlZnQ6IHgsIHJpZ2h0OiB4IH07XG59XG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgICBpZiAocmVjdC5oZWlnaHQgPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0IH07XG59XG5mdW5jdGlvbiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmKSB7XG4gICAgbGV0IHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgIHZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20pXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlld1N0YXRlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpXG4gICAgICAgICAgICBhY3RpdmUuZm9jdXMoKTtcbiAgICB9XG59XG4vLyBXaGV0aGVyIHZlcnRpY2FsIHBvc2l0aW9uIG1vdGlvbiBpbiBhIGdpdmVuIGRpcmVjdGlvblxuLy8gZnJvbSBhIHBvc2l0aW9uIHdvdWxkIGxlYXZlIGEgdGV4dCBibG9jay5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBsZXQgeyBub2RlOiBkb20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuY29udGVudERPTSB8fCBuZWFyZXN0LmRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBib3hlcztcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChib3guYm90dG9tID4gYm94LnRvcCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5jb25zdCBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LCBhdFN0YXJ0ID0gIW9mZnNldCwgYXRFbmQgPSBvZmZzZXQgPT0gJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAvLyBJZiB0aGUgdGV4dGJsb2NrIGlzIGFsbCBMVFIsIG9yIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydFxuICAgIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBodWdlIGhhY2ssIGJ1dCBhcHBlYXJzIHRvIGJlIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBjdXJyZW50bHkgZG86IHVzZSBgU2VsZWN0aW9uLm1vZGlmeWAgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIGJ5XG4gICAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGJsb2NrIChvciBkb2Vzbid0IG1vdmUgaXQgYXQgYWxsLCB3aGVuIGF0IHRoZSBzdGFydC9lbmQgb2ZcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50KS5cbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBvbGROb2RlLCBmb2N1c09mZnNldDogb2xkT2ZmLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbCAvLyBPbmx5IGZvciBGaXJlZm94XG4gICAgICAgIDtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG5ld05vZGUsIGZvY3VzT2Zmc2V0OiBuZXdPZmYgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ld05vZGUgJiYgIXBhcmVudERPTS5jb250YWlucyhuZXdOb2RlLm5vZGVUeXBlID09IDEgPyBuZXdOb2RlIDogbmV3Tm9kZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgKG9sZE5vZGUgPT0gbmV3Tm9kZSAmJiBvbGRPZmYgPT0gbmV3T2ZmKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvbGROb2RlICYmIChvbGROb2RlICE9IGFuY2hvck5vZGUgfHwgb2xkT2ZmICE9IGFuY2hvck9mZnNldCkgJiYgc2VsLmV4dGVuZClcbiAgICAgICAgICAgICAgICBzZWwuZXh0ZW5kKG9sZE5vZGUsIG9sZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAob2xkQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5sZXQgY2FjaGVkU3RhdGUgPSBudWxsO1xubGV0IGNhY2hlZERpciA9IG51bGw7XG5sZXQgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY2FjaGVkU3RhdGUgPSBzdGF0ZTtcbiAgICBjYWNoZWREaXIgPSBkaXI7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiXG4gICAgICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgICAgICA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxuLy8gVmlldyBkZXNjcmlwdGlvbnMgYXJlIGRhdGEgc3RydWN0dXJlcyB0aGF0IGRlc2NyaWJlIHRoZSBET00gdGhhdCBpc1xuLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGVkaXRvcidzIGNvbnRlbnQuIFRoZXkgYXJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gSW5jcmVtZW50YWwgcmVkcmF3aW5nIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZXNcbi8vXG4vLyAtIEZpZ3VyaW5nIG91dCB3aGF0IHBhcnQgb2YgdGhlIGRvY3VtZW50IGEgZ2l2ZW4gRE9NIHBvc2l0aW9uXG4vLyAgIGNvcnJlc3BvbmRzIHRvXG4vL1xuLy8gLSBXaXJpbmcgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgZWRpdGluZyBpbnRlcmZhY2UgZm9yIGFcbi8vICAgZ2l2ZW4gbm9kZVxuLy9cbi8vIFRoZXkgZm9ybSBhIGRvdWJseS1saW5rZWQgbXV0YWJsZSB0cmVlLCBzdGFydGluZyBhdCBgdmlldy5kb2NWaWV3YC5cbmNvbnN0IE5PVF9ESVJUWSA9IDAsIENISUxEX0RJUlRZID0gMSwgQ09OVEVOVF9ESVJUWSA9IDIsIE5PREVfRElSVFkgPSAzO1xuLy8gU3VwZXJjbGFzcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgZGVzY3JpcHRpb25zLiBEZWZpbmVzIHRoZWlyXG4vLyBiYXNpYyBzdHJ1Y3R1cmUgYW5kIHNoYXJlZCBtZXRob2RzLlxuY2xhc3MgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgXG4gICAgLy8gVGhpcyBpcyB0aGUgbm9kZSB0aGF0IGhvbGRzIHRoZSBjaGlsZCB2aWV3cy4gSXQgbWF5IGJlIG51bGwgZm9yXG4gICAgLy8gZGVzY3MgdGhhdCBkb24ndCBoYXZlIGNoaWxkcmVuLlxuICAgIGNvbnRlbnRET00pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIC8vIEFuIGV4cGFuZG8gcHJvcGVydHkgb24gdGhlIERPTSBub2RlIHByb3ZpZGVzIGEgbGluayBiYWNrIHRvIGl0c1xuICAgICAgICAvLyBkZXNjcmlwdGlvbi5cbiAgICAgICAgZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4gICAgLy8gd2lkZ2V0L21hcmsvbm9kZS5cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbiAgICAvLyBkZXNjcmlwdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBwYXJzZSBydWxlcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvXG4gICAgLy8gcGFyc2UgdGhlbS5cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuICAgIC8vIGZyb20gY2VydGFpbiBkZXNjcy5cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBkZXNjLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLy8gRm9yIGJsb2NrIG5vZGVzLCB0aGlzIHJlcHJlc2VudHMgdGhlIHNwYWNlIHRha2VuIHVwIGJ5IHRoZWlyXG4gICAgLy8gc3RhcnQvZW5kIHRva2Vucy5cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHBvc0JlZm9yZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1ciA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIERPTSBwb3NpdGlvbiBpcyBpbiB0aGUgY29udGVudCwgdXNlIHRoZSBjaGlsZCBkZXNjIGFmdGVyXG4gICAgICAgIC8vIGl0IHRvIGZpZ3VyZSBvdXQgYSBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBkb21CZWZvcmUsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb21BZnRlciwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQWZ0ZXIgJiYgISgoZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgOiB0aGlzLnBvc0F0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHZhcmlvdXMgaGV1cmlzdGljcywgZmFsbGluZyBiYWNrIG9uIHRoZSBiaWFzXG4gICAgICAgIC8vIHBhcmFtZXRlciwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgLy8gc3RhcnQgb3IgYXQgdGhlIGVuZCBvZiB0aGlzIHZpZXcgZGVzYy5cbiAgICAgICAgbGV0IGF0RW5kO1xuICAgICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgYXRFbmQgPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5jb250ZW50RE9NKSAmIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIG5lYXJlc3REZXNjKGRvbSwgb25seU5vZGVzID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgZmlyc3QgPSB0cnVlLCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksIG5vZGVET007XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9tIGlzIG91dHNpZGUgb2YgdGhpcyBkZXNjJ3Mgbm9kZURPTSwgZG9uJ3QgY291bnQgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXNjKGRvbSkge1xuICAgICAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBpZiAoY3VyID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IGRvbTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZGVzYyBmb3IgdGhlIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIHBvcywgaWYgYW55LiAoV2hlbiBhXG4gICAgLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcbiAgICBkZXNjQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwLCBhdG9tOiBwb3MgKyAxIH07XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUZyb21Qb3Mob2Zmc2V0IC0gdGhpcy5jaGlsZHJlbltpXS5ib3JkZXIsIHNpZGUpO1xuICAgICAgICAvLyBHbyBiYWNrIGlmIHRoZXJlIHdlcmUgYW55IHplcm8tbGVuZ3RoIHdpZGdldHMgd2l0aCBzaWRlID49IDAgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgZm9yIChsZXQgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkgeyB9XG4gICAgICAgIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gICAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGktLSwgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2LmJvcmRlciAmJiAhcHJldi5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUZyb21Qb3MocHJldi5zaXplLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2ID8gZG9tSW5kZXgocHJldi5kb20pICsgMSA6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKywgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLmNoaWxkcmVuW2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBmaW5kIGEgRE9NIHJhbmdlIGluIGEgc2luZ2xlIHBhcmVudCBmb3IgYSBnaXZlbiBjaGFuZ2VkXG4gICAgLy8gcmFuZ2UuXG4gICAgcGFyc2VSYW5nZShmcm9tLCB0bywgYmFzZSA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0OiAwLCB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gLTEsIHRvT2Zmc2V0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCYXNlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1heWJlIGRlc2NlbmQgbWFyayB2aWV3cyB0byBwYXJzZSBhIG5hcnJvd2VyIHJhbmdlP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhjaGlsZC5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnNlUmFuZ2UoZnJvbSwgdG8sIGNoaWxkQmFzZSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zaXplICYmIHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFwcmV2LmVtcHR5Q2hpbGRBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b09mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldCwgdG9PZmZzZXQgfTtcbiAgICB9XG4gICAgZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3NpZGUgPCAwID8gMCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgICBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhZnRlciBwb3MgXCIgKyBwb3MpO1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICAgIC8vIFZpZXcgZGVzY3MgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIGFueSBzZWxlY3Rpb24gdGhhdCBmYWxsc1xuICAgIC8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4gICAgLy8gY3VzdG9tIHRoaW5ncyB3aXRoIHRoZSBzZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZhbGxzIGFwYXJ0IHdoZW5cbiAgICAvLyBhIHNlbGVjdGlvbiBzdGFydHMgaW4gc3VjaCBhIG5vZGUgYW5kIGVuZHMgaW4gYW5vdGhlciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gZmFsbHMgZW50aXJlbHkgaW4gYSBjaGlsZCwgZ2l2ZSBpdCB0byB0aGF0IGNoaWxkXG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oYW5jaG9yLCBoZWFkKSwgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgcm9vdCwgZm9yY2UpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IGJyS2x1ZGdlID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIEZpcmVmb3gsIHVzaW5nIFNlbGVjdGlvbi5jb2xsYXBzZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBhXG4gICAgICAgIC8vIEJSIG5vZGUgZm9yIHNvbWUgcmVhc29uIGRvZXNuJ3QgYWx3YXlzIHdvcmsgKCMxMDczKS4gT24gU2FmYXJpLFxuICAgICAgICAvLyB0aGUgY3Vyc29yIHNvbWV0aW1lcyBpbmV4cGxpY2FibGUgdmlzdWFsbHkgbGFncyBiZWhpbmQgaXRzXG4gICAgICAgIC8vIHJlcG9ydGVkIHBvc2l0aW9uIGluIHN1Y2ggc2l0dWF0aW9ucyAoIzEwOTIpLlxuICAgICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gISEob2Zmc2V0ICYmIG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElzc3VlICMxMTI4XG4gICAgICAgICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIGFmdGVyOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTSA9IHsgbm9kZTogYWZ0ZXIucGFyZW50Tm9kZSwgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gcHJldiAmJiAocHJldi5ub2RlTmFtZSA9PSBcIkJSXCIgfHwgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGNhbiBhY3Qgc3RyYW5nZWx5IHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBmcm9udCBvZiBhblxuICAgICAgICAvLyB1bmVkaXRhYmxlIG5vZGUuIFNlZSAjMTE2MyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwOTUzNlxuICAgICAgICBpZiAoZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgIGxldCBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20pO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIH07XG4gICAgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7IH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnQubm9kZSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAodG8gPCBzaXplKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vLyBOb2RlIHZpZXcgZGVzY3MgYXJlIHRoZSBtYWluLCBtb3N0IGNvbW1vbiB0eXBlIG9mIHZpZXcgZGVzYywgYW5kXG4vLyBjb3JyZXNwb25kIHRvIGFuIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudC4gVW5saWtlIG1hcmsgZGVzY3MsXG4vLyB0aGV5IHBvcHVsYXRlIHRoZWlyIGNoaWxkIGFycmF5IHRoZW1zZWx2ZXMuXG5jbGFzcyBOb2RlVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCBhIG5vZGUgaXMgcmVuZGVyZWQgdXNpbmcgdGhlIGB0b0RPTWAgbWV0aG9kIGZyb20gdGhlXG4gICAgLy8gbm9kZSB0eXBlIHNwZWMuIEJ1dCBjbGllbnQgY29kZSBjYW4gdXNlIHRoZSBgbm9kZVZpZXdzYCBzcGVjIHRvXG4gICAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgICAvLyB0aGUgd2F5IHRoZSBub2RlIHdvcmtzLlxuICAgIC8vXG4gICAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgICAvLyBzaW5jZSBpdCdkIHJlcXVpcmUgZXhwb3NpbmcgYSB3aG9sZSBzbGV3IG9mIGZpbmlja3lcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIHRoZSB1c2VyIGNvZGUgdGhhdCB0aGV5IHByb2JhYmx5IHdpbGxcbiAgICAvLyBuZXZlciBuZWVkLilcbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3Nbbm9kZS50eXBlLm5hbWVdLCBkZXNjT2JqO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obm9kZSwgdmlldywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gKFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgY3VzdG9tIHZpZXcgdG8gZmluZCBpdHNcbiAgICAgICAgICAgIC8vIG93biBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmICghZGVzY09iailcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgICAgfSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBsZXQgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvbSkge1xuICAgICAgICAgICAgKHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG5vZGUudHlwZS5zcGVjLnRvRE9NKG5vZGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7IC8vIENocm9tZSBnZXRzIGNvbmZ1c2VkIGJ5IDxiciBjb250ZW50ZWRpdGFibGU9ZmFsc2U+XG4gICAgICAgICAgICBpZiAoIWRvbS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpXG4gICAgICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGVET00gPSBkb207XG4gICAgICAgIGRvbSA9IGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBub2RlKTtcbiAgICAgICAgaWYgKHNwZWMpXG4gICAgICAgICAgICByZXR1cm4gZGVzY09iaiA9IG5ldyBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcyArIDEpO1xuICAgICAgICBlbHNlIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICAvLyBFeHBlcmltZW50YWwga2x1ZGdlIHRvIGFsbG93IG9wdC1pbiByZS1wYXJzaW5nIG9mIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRklYTUUgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGNhbiBhbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgLy8gYXR0cnMgaW4gdGhlIGRvbSwgdGhhdCB3b24ndCBiZSBwaWNrZWQgdXAuIE5vdCBlbnRpcmVseSBzdXJlXG4gICAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBhIHByb2JsZW1cbiAgICAgICAgbGV0IHJ1bGUgPSB7IG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnMgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIilcbiAgICAgICAgICAgIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiB0aGlzLm5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50TG9zdCkge1xuICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBsaWtlcyB0byByYW5kb21seSByZWNyZWF0ZSBwYXJlbnQgbm9kZXMgd2hlblxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgdGhpbmdzLiBXaGVuIHRoYXQgaGFwcGVucywgdGhpcyB0cmllcyB0byBmaW5kIHRoZVxuICAgICAgICAgICAgLy8gbmV3IHBhcmVudC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pICYmIGlubmVyRGVjby5lcSh0aGlzLmlubmVyRGVjbyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplOyB9XG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0xlYWYgPyAwIDogMTsgfVxuICAgIC8vIFN5bmNzIGB0aGlzLmNoaWxkcmVuYCB0byBtYXRjaCBgdGhpcy5ub2RlLmNvbnRlbnRgIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgICAvLyBzZXBhcmF0ZSBzdGVwLCBzeW5jcyB0aGUgRE9NIGluc2lkZSBgdGhpcy5jb250ZW50RE9NYCB0b1xuICAgIC8vIGB0aGlzLmNoaWxkcmVuYC5cbiAgICB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHZpZXcuY29tcG9zaW5nID8gdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIDogbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICAgIGxldCB1cGRhdGVyID0gbmV3IFZpZXdUcmVlVXBkYXRlcih0aGlzLCBsb2NhbENvbXBvc2l0aW9uICYmIGxvY2FsQ29tcG9zaXRpb24ubm9kZSwgdmlldyk7XG4gICAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sICh3aWRnZXQsIGksIGluc2lkZU5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuc3BlYy5tYXJrcylcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzLm5vZGUuY2hpbGRDb3VudCA/IE1hcmsubm9uZSA6IHRoaXMubm9kZS5jaGlsZChpKS5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgICAgfSwgKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB3cmFwcGluZyBtYXJrIGRlc2NzIG1hdGNoIHRoZSBub2RlJ3MgbWFya3MuXG4gICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gVHJ5IHNldmVyYWwgc3RyYXRlZ2llcyBmb3IgZHJhd2luZyB0aGlzIG5vZGVcbiAgICAgICAgICAgIGxldCBjb21wSW5kZXg7XG4gICAgICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvc2l0aW9uSW5DaGlsZCAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID4gb2ZmICYmXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJlxuICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlTm9kZUF0KGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgY29tcEluZGV4LCB2aWV3KSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGksIG9mZikpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhcyBhIG5ldyB2aWV3XG4gICAgICAgICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgICAgdXBkYXRlci5kZXN0cm95UmVzdCgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICBpZiAodXBkYXRlci5jaGFuZ2VkIHx8IHRoaXMuZGlydHkgPT0gQ09OVEVOVF9ESVJUWSkge1xuICAgICAgICAgICAgLy8gTWF5IGhhdmUgdG8gcHJvdGVjdCBmb2N1c2VkIERPTSBmcm9tIGJlaW5nIGNoYW5nZWQgaWYgYSBjb21wb3NpdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgaWYgKGlvcylcbiAgICAgICAgICAgICAgICBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgICAgICAvLyBhcmUgaW5zaWRlIG9mIHRoaXMgbm9kZVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRleHROb2RlID0gdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGU7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiB0aGlzLm5vZGUudGV4dCA9PSB0ZXh0OyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnNwZWMudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRET00gJiYgIW5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBzdXBlci5zZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IHN1cGVyLmRlc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSkge1xuICAgICAgICB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uID8gdGhpcy5zcGVjLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpXG4gICAgICAgICAgICA6IHN1cGVyLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG59XG4vLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSB3aXRoIHRoZSBub2RlcyBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiB2aWV3IGRlc2NzLCByZWN1cnNpbmcgaW50byBtYXJrIGRlc2NzXG4vLyBiZWNhdXNlIHRoaXMgc2hvdWxkIHN5bmMgdGhlIHN1YnRyZWUgZm9yIGEgd2hvbGUgbm9kZSBhdCBhIHRpbWUuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudERPTS5maXJzdENoaWxkLCB3cml0dGVuID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVzYyA9IGRlc2NzW2ldLCBjaGlsZERPTSA9IGRlc2MuZG9tO1xuICAgICAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdyaXR0ZW4gJiYgdmlldy50cmFja1dyaXRlcyA9PSBwYXJlbnRET00pXG4gICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xufVxuY29uc3QgT3V0ZXJEZWNvTGV2ZWwgPSBmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgICBpZiAobm9kZU5hbWUpXG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbn07XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gICAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vRGVjbztcbiAgICBsZXQgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICAgICAgaWYgKCFhdHRycylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYXR0cnMubm9kZU5hbWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5lZWRzV3JhcCAmJiByZXN1bHQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB0b3AuY2xhc3MgPSAodG9wLmNsYXNzID8gdG9wLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgdG9wW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICAgIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pXG4gICAgICAgIHJldHVybiBub2RlRE9NO1xuICAgIGxldCBjdXJET00gPSBub2RlRE9NO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyQ29tcHV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlY28gPSBjdXJDb21wdXRlZFtpXSwgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudCA9IGN1ckRPTS5wYXJlbnROb2RlKSAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBkZWNvLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJET00pO1xuICAgICAgICAgICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1ckRPTTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGN1cilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltuYW1lXSAhPSBwcmV2W25hbWVdKVxuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBjdXJbbmFtZV0pO1xuICAgIGlmIChwcmV2LmNsYXNzICE9IGN1ci5jbGFzcykge1xuICAgICAgICBsZXQgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGxldCBjdXJMaXN0ID0gY3VyLmNsYXNzID8gY3VyLmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZXZMaXN0LmluZGV4T2YoY3VyTGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtpXSk7XG4gICAgICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICAgICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZywgbTtcbiAgICAgICAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKVxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLnN0eWxlKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICAgIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS50eXBlLmVxKGJbaV0udHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbmNsYXNzIFZpZXdUcmVlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3IodG9wLCBsb2NrLCB2aWV3KSB7XG4gICAgICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEluZGV4IGludG8gYHRoaXMudG9wYCdzIGNoaWxkIGFycmF5LCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFdoZW4gZW50ZXJpbmcgYSBtYXJrLCB0aGUgY3VycmVudCB0b3AgYW5kIGluZGV4IGFyZSBwdXNoZWRcbiAgICAgICAgLy8gb250byB0aGlzLlxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIGFueXRoaW5nIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuICAgIC8vIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lSZXN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFyayBkZXNjcyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZlxuICAgIC8vIG1hcmtzLCByZXVzaW5nIGV4aXN0aW5nIG1hcmsgZGVzY3Mgd2hlbiBwb3NzaWJsZS5cbiAgICBzeW5jVG9NYXJrcyhtYXJrcywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBrZWVwID0gMCwgZGVwdGggPSB0aGlzLnN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBsZXQgbWF4S2VlcCA9IE1hdGgubWluKGRlcHRoLCBtYXJrcy5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heEtlZXAgJiZcbiAgICAgICAgICAgIChrZWVwID09IGRlcHRoIC0gMSA/IHRoaXMudG9wIDogdGhpcy5zdGFja1soa2VlcCArIDEpIDw8IDFdKVxuICAgICAgICAgICAgICAgIC5tYXRjaGVzTWFyayhtYXJrc1trZWVwXSkgJiYgbWFya3Nba2VlcF0udHlwZS5zcGVjLnNwYW5uaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UmVzdCgpO1xuICAgICAgICAgICAgdGhpcy50b3AuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlcHRoIDwgbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCBNYXRoLm1pbih0aGlzLmluZGV4ICsgMywgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pICYmICF0aGlzLmlzTG9ja2VkKG5leHQuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIG5vZGUgZGVzYyBtYXRjaGluZyB0aGUgZ2l2ZW4gZGF0YS4gU2tpcCBvdmVyIGl0IGFuZFxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSAtMSwgdGFyZ2V0RGVzYztcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiZcbiAgICAgICAgICAgICh0YXJnZXREZXNjID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVzW2luZGV4IC0gdGhpcy5wcmVNYXRjaC5pbmRleF0pLnBhcmVudCA9PSB0aGlzLnRvcCAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pICYmICF0aGlzLnByZU1hdGNoLm1hdGNoZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKVxuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tTm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gdXBkYXRlIHRoZSBuZXh0IG5vZGUsIGlmIGFueSwgdG8gdGhlIGdpdmVuIGRhdGEuIENoZWNrc1xuICAgIC8vIHByZS1tYXRjaGVzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIG5vZGVzIHRoYXQgY291bGQgc3RpbGwgYmUgdXNlZC5cbiAgICB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBOb2RlVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRET00gPSBuZXh0LmRvbSwgdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSB0ZXh0IG5vZGUgd2hvc2UgY29udGVudCBhbHJlYWR5IG1hdGNoZXMgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdob3NlIGRlY29yYXRpb25zIG1hdGNoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICBsZXQgbG9ja2VkID0gdGhpcy5pc0xvY2tlZChuZXh0RE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcnR5ICE9IE5PREVfRElSVFkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvY2tlZCAmJiAodXBkYXRlZCA9IHRoaXMucmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAod3JhcHBlci5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgICAgIG5leHQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHdyYXBwZXIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2gucGFyZW50ID0gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBhcyBhIG5ld2x5IGNyZWF0ZWQgbm9kZSBkZXNjLlxuICAgIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NKVxuICAgICAgICAgICAgZGVzYy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiZcbiAgICAgICAgICAgICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGEgdGV4dGJsb2NrIGxvb2tzIGFuZCBiZWhhdmVzIGNvcnJlY3RseSBpblxuICAgIC8vIGNvbnRlbnRFZGl0YWJsZS5cbiAgICBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSwgcGFyZW50ID0gdGhpcy50b3A7XG4gICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgLy8gRW1wdHkgdGV4dGJsb2NrXG4gICAgICAgICAgICAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHxcbiAgICAgICAgICAgIC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy52aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSAmJiAvXFxzJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSkpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3MgaW4gU2FmYXJpJ3MgY3Vyc29yIGRyYXdpbmcgKCMxMTY1KSBhbmQgQ2hyb21lJ3MgbW91c2Ugc2VsZWN0aW9uICgjMTE1MilcbiAgICAgICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcCAmJiB0aGlzLmluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAmJiBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICAgICAgICAgIGRvbS5hbHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgICAgICBsZXQgaGFjayA9IG5ldyBUcmFpbGluZ0hhY2tWaWV3RGVzYyh0aGlzLnRvcCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGhhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrICYmIChub2RlID09IHRoaXMubG9jayB8fCBub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpO1xuICAgIH1cbn1cbi8vIEl0ZXJhdGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCBhbmQgYXJyYXkgb2YgZGVzY3MgdG8gZmluZFxuLy8gZGlyZWN0bHkgbWF0Y2hpbmcgb25lcywgaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmVhZ2VybHkgcmV1c2luZyB0aG9zZVxuLy8gZm9yIG90aGVyIG5vZGVzLiBSZXR1cm5zIHRoZSBmcmFnbWVudCBpbmRleCBvZiB0aGUgZmlyc3Qgbm9kZSB0aGF0XG4vLyBpcyBwYXJ0IG9mIHRoZSBzZXF1ZW5jZSBvZiBtYXRjaGVkIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4vLyBmcmFnbWVudC5cbmZ1bmN0aW9uIHByZU1hdGNoKGZyYWcsIHBhcmVudERlc2MpIHtcbiAgICBsZXQgY3VyRGVzYyA9IHBhcmVudERlc2MsIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGZJID0gZnJhZy5jaGlsZENvdW50LCBtYXRjaGVkID0gbmV3IE1hcCwgbWF0Y2hlcyA9IFtdO1xuICAgIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0kgPSBuZXh0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAtLWZJO1xuICAgICAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGZJLCBtYXRjaGVkLCBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKSB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICAgIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgICBsZXQgbG9jYWxzID0gZGVjby5sb2NhbHMocGFyZW50KSwgb2Zmc2V0ID0gMDtcbiAgICAvLyBTaW1wbGUsIGNoZWFwIHZhcmlhbnQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGxvY2FsIGRlY29yYXRpb25zXG4gICAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgICAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgICAgIGxldCB3aWRnZXQsIHdpZGdldHM7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBsb2NhbHNbZGVjb0luZGV4KytdO1xuICAgICAgICAgICAgaWYgKG5leHQud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXRzW2ldLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQsIGluZGV4O1xuICAgICAgICBpZiAocmVzdE5vZGUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDw9IG9mZnNldCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA+IG9mZnNldClcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBjdXRBdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdClcbiAgICAgICAgICAgICAgICBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgICAgIGN1dEF0ID0gYWN0aXZlW2ldLnRvO1xuICAgICAgICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBjaGlsZC5jdXQoY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgZGVjb0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dGVyRGVjbyA9IGNoaWxkLmlzSW5saW5lICYmICFjaGlsZC5pc0xlYWYgPyBhY3RpdmUuZmlsdGVyKGQgPT4gIWQuaW5saW5lKSA6IGFjdGl2ZS5zbGljZSgpO1xuICAgICAgICBvbk5vZGUoY2hpbGQsIG91dGVyRGVjbywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaW5kZXgpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxufVxuLy8gTGlzdCBtYXJrZXJzIGluIE1vYmlsZSBTYWZhcmkgd2lsbCBteXN0ZXJpb3VzbHkgZGlzYXBwZWFyXG4vLyBzb21ldGltZXMuIFRoaXMgd29ya3MgYXJvdW5kIHRoYXQuXG5mdW5jdGlvbiBpb3NIYWNrcyhkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVUxcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJPTFwiKSB7XG4gICAgICAgIGxldCBvbGRDU1MgPSBkb20uc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1MgKyBcIjsgbGlzdC1zdHlsZTogc3F1YXJlICFpbXBvcnRhbnRcIjtcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKS5saXN0U3R5bGU7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgIH1cbn1cbi8vIEZpbmQgYSBwaWVjZSBvZiB0ZXh0IGluIGFuIGlubGluZSBmcmFnbWVudCwgb3ZlcmxhcHBpbmcgZnJvbS10b1xuZnVuY3Rpb24gZmluZFRleHRJbkZyYWdtZW50KGZyYWcsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBmcmFnLmNoaWxkQ291bnQgJiYgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnLmNoaWxkKGkrKyksIGNoaWxkU3RhcnQgPSBwb3M7XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgICAgIHdoaWxlIChpIDwgZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWcuY2hpbGQoaSsrKTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0Lm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAocG9zID49IHRvICYmIHN0ci5zbGljZSh0byAtIHRleHQubGVuZ3RoIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0KSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0byAtIHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY2hpbGRTdGFydCA8IHRvID8gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCAtIDEpIDogLTE7XG4gICAgICAgICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFN0YXJ0ICsgZm91bmQ7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBzdHIubGVuZ3RoID49ICh0byArIHRleHQubGVuZ3RoKSAtIGNoaWxkU3RhcnQgJiZcbiAgICAgICAgICAgICAgICBzdHIuc2xpY2UodG8gLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQgKyB0ZXh0Lmxlbmd0aCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLy8gUmVwbGFjZSByYW5nZSBmcm9tLXRvIGluIGFuIGFycmF5IG9mIHZpZXcgZGVzY3Mgd2l0aCByZXBsYWNlbWVudFxuLy8gKG1heSBiZSBudWxsIHRvIGp1c3QgZGVsZXRlKS4gVGhpcyBnb2VzIHZlcnkgbXVjaCBhZ2FpbnN0IHRoZSBncmFpblxuLy8gb2YgdGhlIHJlc3Qgb2YgdGhpcyBjb2RlLCB3aGljaCB0ZW5kcyB0byBjcmVhdGUgbm9kZXMgd2l0aCB0aGVcbi8vIHJpZ2h0IHNoYXBlIGluIG9uZSBnbywgcmF0aGVyIHRoYW4gbWVzc2luZyB3aXRoIHRoZW0gYWZ0ZXJcbi8vIGNyZWF0aW9uLCBidXQgaXMgbmVjZXNzYXJ5IGluIHRoZSBjb21wb3NpdGlvbiBoYWNrLlxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2Rlc1tpXSwgc3RhcnQgPSBvZmYsIGVuZCA9IG9mZiArPSBjaGlsZC5zaXplO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UoMCwgZnJvbSAtIHN0YXJ0LCB2aWV3KSk7XG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UodG8gLSBzdGFydCwgY2hpbGQuc2l6ZSwgdmlldykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luID0gbnVsbCkge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmICghZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5lYXJlc3REZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbVNlbC5mb2N1c05vZGUpLCBpbldpZGdldCA9IG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjLnNpemUgPT0gMDtcbiAgICBsZXQgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgMSk7XG4gICAgaWYgKGhlYWQgPCAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKSwgJGFuY2hvciwgc2VsZWN0aW9uO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgIHdoaWxlIChuZWFyZXN0RGVzYyAmJiAhbmVhcmVzdERlc2Mubm9kZSlcbiAgICAgICAgICAgIG5lYXJlc3REZXNjID0gbmVhcmVzdERlc2MucGFyZW50O1xuICAgICAgICBsZXQgbmVhcmVzdERlc2NOb2RlID0gbmVhcmVzdERlc2Mubm9kZTtcbiAgICAgICAgaWYgKG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjTm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2NOb2RlKSAmJiBuZWFyZXN0RGVzYy5wYXJlbnRcbiAgICAgICAgICAgICYmICEobmVhcmVzdERlc2NOb2RlLmlzSW5saW5lICYmIGlzT25FZGdlKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgbmVhcmVzdERlc2MuZG9tKSkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBuZWFyZXN0RGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgTm9kZVNlbGVjdGlvbihoZWFkID09IHBvcyA/ICRoZWFkIDogZG9jLnJlc29sdmUocG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBhbmNob3IgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgMSk7XG4gICAgICAgIGlmIChhbmNob3IgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYmlhcyA9IG9yaWdpbiA9PSBcInBvaW50ZXJcIiB8fCAodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCA8ICRoZWFkLnBvcyAmJiAhaW5XaWRnZXQpID8gMSA6IC0xO1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICAgIHJldHVybiB2aWV3LmVkaXRhYmxlID8gdmlldy5oYXNGb2N1cygpIDpcbiAgICAgICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0RPTSh2aWV3LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCk7XG4gICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gVGhlIGRlbGF5ZWQgZHJhZyBzZWxlY3Rpb24gY2F1c2VzIGlzc3VlcyB3aXRoIENlbGwgU2VsZWN0aW9uc1xuICAgIC8vIGluIFNhZmFyaS4gQW5kIHRoZSBkcmFnIHNlbGVjdGlvbiBkZWxheSBpcyB0byB3b3JrYXJvbmQgaXNzdWVzXG4gICAgLy8gd2hpY2ggb25seSBwcmVzZW50IGluIENocm9tZS5cbiAgICBpZiAoIWZvcmNlICYmIHZpZXcuaW5wdXQubW91c2VEb3duICYmIHZpZXcuaW5wdXQubW91c2VEb3duLmFsbG93RGVmYXVsdCAmJiBjaHJvbWUpIHtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgY3VyU2VsID0gdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgJiYgY3VyU2VsLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCBjdXJTZWwuYW5jaG9yTm9kZSwgY3VyU2VsLmFuY2hvck9mZnNldCkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcikge1xuICAgICAgICBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yLCBoZWFkIH0gPSBzZWwsIHJlc2V0RWRpdGFibGVGcm9tLCByZXNldEVkaXRhYmxlVG87XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5ICYmICFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZVRvID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLnRvKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRvY1ZpZXcuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290LCBmb3JjZSk7XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVGcm9tKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZUZyb20pO1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVUbylcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKFwib25zZWxlY3Rpb25jaGFuZ2VcIiBpbiBkb2N1bWVudClcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgdmlldy5kb21PYnNlcnZlci5jb25uZWN0U2VsZWN0aW9uKCk7XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgV2Via2l0IG5vdCBhbGxvd2luZyBhIHNlbGVjdGlvbiB0byBzdGFydC9lbmRcbi8vIGJldHdlZW4gbm9uLWVkaXRhYmxlIGJsb2NrIG5vZGVzLiBXZSBicmllZmx5IG1ha2Ugc29tZXRoaW5nXG4vLyBlZGl0YWJsZSwgc2V0IHRoZSBzZWxlY3Rpb24sIHRoZW4gc2V0IGl0IHVuZWRpdGFibGUgYWdhaW4uXG5jb25zdCBicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSA9IHNhZmFyaSB8fCBjaHJvbWUgJiYgY2hyb21lX3ZlcnNpb24gPCA2MztcbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICBsZXQgYWZ0ZXIgPSBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0gOiBudWxsO1xuICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0gOiBudWxsO1xuICAgIGlmIChzYWZhcmkgJiYgYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICAgICAgaWYgKGFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGJlZm9yZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgaWYgKHNhZmFyaSAmJiBlbGVtZW50LmRyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gcmVzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgaWYgKGVsZW1lbnQud2FzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gZG9tU2VsLmFuY2hvck5vZGUsIG9mZnNldCA9IGRvbVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAhPSBub2RlIHx8IGRvbVNlbC5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gICAgaWYgKGltZylcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCAwKTtcbiAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgLy8gS2x1ZGdlIHRvIGtpbGwgJ2NvbnRyb2wgc2VsZWN0aW9uJyBpbiBJRTExIHdoZW4gc2VsZWN0aW5nIGFuXG4gICAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAgIC8vIHJlc2l6ZSBoYW5kbGVzIGFuZCBhIHNlbGVjdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgYWJzb2x1dGVseVxuICAgIC8vIHBvc2l0aW9uZWQgd3JhcHBlciwgcmF0aGVyIHRoYW4gdGhlIHJvb3QgZWRpdGFibGUgbm9kZSwgdGhlXG4gICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgIGlmICghaW1nICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmIGllICYmIGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpIHtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQoc2VsLmZyb20pO1xuICAgICAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICBkZXNjLnNlbGVjdE5vZGUoKTtcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSBkZXNjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgfVxufVxuLy8gQ2xlYXIgYWxsIERPTSBzdGF0ZWZ1bG5lc3Mgb2YgdGhlIGxhc3Qgbm9kZSBzZWxlY3Rpb24uXG5mdW5jdGlvbiBjbGVhck5vZGVTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLnBhcmVudClcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MuZGVzZWxlY3ROb2RlKCk7XG4gICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlblwiLCBmID0+IGYodmlldywgJGFuY2hvciwgJGhlYWQpKVxuICAgICAgICB8fCBUZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xufVxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3LmVkaXRhYmxlICYmICF2aWV3Lmhhc0ZvY3VzKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhbmNob3JJblJpZ2h0UGxhY2Uodmlldykge1xuICAgIGxldCBhbmNob3JET00gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIDApO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgcmV0dXJuIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGFuY2hvciwgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHNpZGUgPSBkaXIgPiAwID8gJGFuY2hvci5tYXgoJGhlYWQpIDogJGFuY2hvci5taW4oJGhlYWQpO1xuICAgIGxldCAkc3RhcnQgPSAhJHNpZGUucGFyZW50LmlubGluZUNvbnRlbnQgPyAkc2lkZSA6ICRzaWRlLmRlcHRoID8gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzaWRlLmFmdGVyKCkgOiAkc2lkZS5iZWZvcmUoKSkgOiBudWxsO1xuICAgIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKTtcbn1cbmZ1bmN0aW9uIGFwcGx5KHZpZXcsIHNlbCkge1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgJGhlYWQgfSA9IHNlbCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQgfHwgIW5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkbmV3SGVhZCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zICsgbm9kZS5ub2RlU2l6ZSAqIChkaXIgPCAwID8gLTEgOiAxKSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oc2VsLiRhbmNob3IsICRuZXdIZWFkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbC5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkpIHtcbiAgICAgICAgICAgIGxldCAkaGVhZCA9IHNlbC4kaGVhZCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgICAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmtpdCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgaW50cm9kdWNlIGV4dHJhIHBvaW50bGVzcyBjdXJzb3JcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gdGFrZSBvdmVyIGFuZCBtb3ZlIHRoZSBjdXJzb3IgcGFzdCB0aGVtICgjOTM3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGRpciA8IDAgPyBub2RlUG9zIDogbm9kZVBvcyArIG5vZGUubm9kZVNpemUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWwubm9kZS5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20sIGRpcikge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRpciA8IDAgfHwgZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpIHtcbiAgICByZXR1cm4gZGlyIDwgMCA/IHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykgOiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBhZnRlciBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcywgd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBicm93c2VyJ3MgY3Vyc29yIG1vdGlvbiBsb2dpYy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAgIC8vIEdlY2tvIHdpbGwgZG8gb2RkIHRoaW5ncyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZGlyZWN0bHkgaW4gZnJvbnRcbiAgICAvLyBvZiBhIG5vbi1lZGl0YWJsZSBub2RlLCBzbyBpbiB0aGF0IGNhc2UsIG1vdmUgaXQgaW50byB0aGUgbmV4dFxuICAgIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGVMZW4obm9kZSkgJiYgaXNJZ25vcmFibGUobm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIC0xKSlcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYsIC0xKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2UpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0LCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbmV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2s7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMykge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGFmdGVyID0gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYWZ0ZXI7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSA9IHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQsIHNsaWNlIH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG4gICAgaWYgKGFzVGV4dCkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkVGV4dFwiLCBmID0+IHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCwgdmlldyk7IH0pO1xuICAgICAgICBpZiAoaW5Db2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG4vLyBUYWtlcyBhIHNsaWNlIHBhcnNlZCB3aXRoIHBhcnNlU2xpY2UsIHdoaWNoIG1lYW5zIHRoZXJlIGhhc24ndCBiZWVuXG4vLyBhbnkgY29udGVudC1leHByZXNzaW9uIGNoZWNraW5nIGRvbmUgb24gdGhlIHRvcCBub2RlcywgdHJpZXMgdG9cbi8vIGZpbmQgYSBwYXJlbnQgbm9kZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IHRoYXQgbWlnaHQgZml0IHRoZSBub2Rlcyxcbi8vIGFuZCBpZiBzdWNjZXNzZnVsLCByZWJ1aWxkcyB0aGUgc2xpY2Ugc28gdGhhdCBpdCBmaXRzIGludG8gdGhhdCBwYXJlbnQuXG4vL1xuLy8gVGhpcyBhZGRyZXNzZXMgdGhlIHByb2JsZW0gdGhhdCBUcmFuc2Zvcm0ucmVwbGFjZSBleHBlY3RzIGFcbi8vIGNvaGVyZW50IHNsaWNlLCBhbmQgd2lsbCBmYWlsIHRvIHBsYWNlIGEgc2V0IG9mIHNpYmxpbmdzIHRoYXQgZG9uJ3Rcbi8vIGZpdCBhbnl3aGVyZSBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbm9ybWFsaXplU2libGluZ3MoZnJhZ21lbnQsICRjb250ZXh0KSB7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gJGNvbnRleHQubm9kZShkKTtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICAgICAgbGV0IGxhc3RXcmFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGluTGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gY2xvc2VSaWdodChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsYXN0V3JhcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSk7XG4gICAgICAgICAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBmcm9tID0gMCkge1xuICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgICAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyBVc2VkIHRvIGdyb3VwIGFkamFjZW50IG5vZGVzIHdyYXBwZWQgaW4gc2ltaWxhciBwYXJlbnRzIGJ5XG4vLyBub3JtYWxpemVTaWJsaW5ncyBpbnRvIHRoZSBzYW1lIHBhcmVudCBub2RlXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgICAgIGxldCBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUoZGVwdGggPT0gd3JhcC5sZW5ndGggLSAxID8gbm9kZS50eXBlIDogd3JhcFtkZXB0aCArIDFdKSlcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgICBsZXQgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgICBsZXQgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCwgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPiAxKVxuICAgICAgICBvcGVuRW5kID0gMDtcbiAgICBpZiAoZGVwdGggPCB0byAtIDEpXG4gICAgICAgIGlubmVyID0gY2xvc2VSYW5nZShpbm5lciwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoICsgMSwgb3BlbkVuZCk7XG4gICAgaWYgKGRlcHRoID49IGZyb20pXG4gICAgICAgIGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgICAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7XG4gICAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIDEsIG9wZW5FbmQsIHNsaWNlLm9wZW5FbmQsIDAsIDApLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIHJldHVybiBzbGljZTtcbn1cbi8vIFRyaWNrIGZyb20galF1ZXJ5IC0tIHNvbWUgZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIG90aGVyXG4vLyBlbGVtZW50cyBmb3IgaW5uZXJIVE1MIHRvIHdvcmsuIEkuZS4gaWYgeW91IGRvIGBkaXYuaW5uZXJIVE1MID1cbi8vIFwiPHRkPi4uPC90ZD5cImAgdGhlIHRhYmxlIGNlbGxzIGFyZSBpZ25vcmVkLlxuY29uc3Qgd3JhcE1hcCA9IHtcbiAgICB0aGVhZDogW1widGFibGVcIl0sXG4gICAgdGJvZHk6IFtcInRhYmxlXCJdLFxuICAgIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgICBjYXB0aW9uOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2xncm91cDogW1widGFibGVcIl0sXG4gICAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICAgIHRyOiBbXCJ0YWJsZVwiLCBcInRib2R5XCJdLFxuICAgIHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG4gICAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcbmxldCBfZGV0YWNoZWREb2MgPSBudWxsO1xuZnVuY3Rpb24gZGV0YWNoZWREb2MoKSB7XG4gICAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpO1xufVxuZnVuY3Rpb24gcmVhZEhUTUwoaHRtbCkge1xuICAgIGxldCBtZXRhcyA9IC9eKFxccyo8bWV0YSBbXj5dKj4pKi8uZXhlYyhodG1sKTtcbiAgICBpZiAobWV0YXMpXG4gICAgICAgIGh0bWwgPSBodG1sLnNsaWNlKG1ldGFzWzBdLmxlbmd0aCk7XG4gICAgbGV0IGVsdCA9IGRldGFjaGVkRG9jKCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBsZXQgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksIHdyYXA7XG4gICAgaWYgKHdyYXAgPSBmaXJzdFRhZyAmJiB3cmFwTWFwW2ZpcnN0VGFnWzFdLnRvTG93ZXJDYXNlKCldKVxuICAgICAgICBodG1sID0gd3JhcC5tYXAobiA9PiBcIjxcIiArIG4gKyBcIj5cIikuam9pbihcIlwiKSArIGh0bWwgKyB3cmFwLm1hcChuID0+IFwiPC9cIiArIG4gKyBcIj5cIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgZWx0LmlubmVySFRNTCA9IGh0bWw7XG4gICAgaWYgKHdyYXApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVsdCA9IGVsdC5xdWVyeVNlbGVjdG9yKHdyYXBbaV0pIHx8IGVsdDtcbiAgICByZXR1cm4gZWx0O1xufVxuLy8gV2Via2l0IGJyb3dzZXJzIGRvIHNvbWUgaGFyZC10by1wcmVkaWN0IHJlcGxhY2VtZW50IG9mIHJlZ3VsYXJcbi8vIHNwYWNlcyB3aXRoIG5vbi1icmVha2luZyBzcGFjZXMgd2hlbiBwdXR0aW5nIGNvbnRlbnQgb24gdGhlXG4vLyBjbGlwYm9hcmQuIFRoaXMgdHJpZXMgdG8gY29udmVydCBzdWNoIG5vbi1icmVha2luZyBzcGFjZXMgKHdoaWNoXG4vLyB3aWxsIGJlIHdyYXBwZWQgaW4gYSBwbGFpbiBzcGFuIG9uIENocm9tZSwgYSBzcGFuIHdpdGggY2xhc3Ncbi8vIEFwcGxlLWNvbnZlcnRlZC1zcGFjZSBvbiBTYWZhcmkpIGJhY2sgdG8gcmVndWxhciBzcGFjZXMuXG5mdW5jdGlvbiByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKSB7XG4gICAgbGV0IG5vZGVzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoY2hyb21lID8gXCJzcGFuOm5vdChbY2xhc3NdKTpub3QoW3N0eWxlXSlcIiA6IFwic3Bhbi5BcHBsZS1jb252ZXJ0ZWQtc3BhY2VcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUudGV4dENvbnRlbnQgPT0gXCJcXHUwMGEwXCIgJiYgbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIiksIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICBsZXQgc2NoZW1hID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkLnR5cGUuc2NoZW1hLCBhcnJheTtcbiAgICB0cnkge1xuICAgICAgICBhcnJheSA9IEpTT04ucGFyc2UoY29udGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG4gICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBvcGVuRW5kKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIERPTSBldmVudHMgdGhhdCBvY2N1ciB3aXRoaW4gdGhlIGVkaXRvciwgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uc1xuLy8gdG8gaW52b2tlIHdoZW4gdGhlIGV2ZW50IGZpcmVzLlxuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmNvbnN0IGVkaXRIYW5kbGVycyA9IHt9O1xuY29uc3QgcGFzc2l2ZUhhbmRsZXJzID0geyB0b3VjaHN0YXJ0OiB0cnVlLCB0b3VjaG1vdmU6IHRydWUgfTtcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2sgPSB7IHRpbWU6IDAsIHg6IDAsIHk6IDAsIHR5cGU6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEFuZHJvaWREZWxldGUgPSAwO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uSUQgPSAxO1xuICAgICAgICAvLyBTZXQgdG8gYSBjb21wb3NpdGlvbiBJRCB3aGVuIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMgYXQgY29tcG9zaXRpb25lbmRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaGlkZVNlbGVjdGlvbkd1YXJkID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5wdXQodmlldykge1xuICAgIGZvciAobGV0IGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH0sIHBhc3NpdmVIYW5kbGVyc1tldmVudF0gPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAgIC8vIGV2ZW50IGhhbmRsZXIgbWFrZXMgYW4gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW5cbiAgICAvLyB5b3UgcHJlc3MgZW50ZXIgZ28gYXdheS5cbiAgICBpZiAoc2FmYXJpKVxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIG9yaWdpbikge1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpXG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGN1cnJlbnRIYW5kbGVycyA9PiB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKCF2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBldmVudCA9PiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgaGFuZGxlcnMgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIodmlldywgZXZlbnQpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gU3VwcHJlc3MgZW50ZXIga2V5IGV2ZW50cyBvbiBDaHJvbWUgQW5kcm9pZCwgYmVjYXVzZSB0aG9zZSB0ZW5kXG4gICAgLy8gdG8gYmUgcGFydCBvZiBhIGNvbmZ1c2VkIHNlcXVlbmNlIG9mIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlZCxcbiAgICAvLyBhbmQgaGFuZGxpbmcgdGhlbSBlYWdlcmx5IHRlbmRzIHRvIGNvcnJ1cHQgdGhlIGlucHV0LlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAgIC8vIGtleWJvYXJkIGdldHMgY29uZnVzZWQuIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gc2V0IGEgZmxhZyB0aGF0XG4gICAgLy8gbWFrZXMgdGhlIERPTSBjaGFuZ2UgY29kZSByZWNvZ25pemUgdGhhdCB3aGF0IGp1c3QgaGFwcGVucyBzaG91bGRcbiAgICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICAgIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBldmVudCkpIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICAgIH1cbn07XG5lZGl0SGFuZGxlcnMua2V5dXAgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNilcbiAgICAgICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHx8ICFldmVudC5jaGFyQ29kZSB8fFxuICAgICAgICBldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHwgbWFjICYmIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGYgPT4gZih2aWV3LCBldmVudCkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQpKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwic2luZ2xlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwidHJpcGxlQ2xpY2tcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7IHRpbWU6IG5vdywgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdHlwZSB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjICYmIHRhcmdldERlc2MuZG9tLm5vZGVUeXBlID09IDEgPyB0YXJnZXREZXNjLmRvbSA6IG51bGw7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICB0YXJnZXROb2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZyb20gPD0gdGFyZ2V0UG9zICYmIHNlbGVjdGlvbi50byA+IHRhcmdldFBvcylcbiAgICAgICAgICAgIHRoaXMubWlnaHREcmFnID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICAgICAgICAgICAgYWRkQXR0cjogISEodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRyYWdnYWJsZSksXG4gICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogISEodGhpcy50YXJnZXQgJiYgZ2Vja28gJiYgIXRoaXMudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAodGhpcy5taWdodERyYWcuYWRkQXR0ciB8fCB0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcgJiYgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KSk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPSBudWxsO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgIT0gdGhpcy5zdGFydERvYylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RGVmYXVsdCB8fCAhcG9zKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgKHRoaXMuZmx1c2hlZCB8fFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAoc2FmYXJpICYmIHRoaXMubWlnaHREcmFnICYmICF0aGlzLm1pZ2h0RHJhZy5ub2RlLmlzQXRvbSkgfHxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yLCBidXQgc3RpbGwgcmVwb3J0IHRoYXQgdGhlIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFza2VkIHRocm91Z2ggZ2V0U2VsZWN0aW9uLiBZb3UnbGwgdGhlbiBnZXQgYVxuICAgICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIChoaWRkZW4pIGN1cnNvciBpcyBkb2Vzbid0IGNoYW5nZSB0aGUgc2VsZWN0aW9uLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGRvZXNuJ3QgZ2V0IGEgcmVhY3Rpb24gZnJvbSBQcm9zZU1pcnJvci4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAgIChjaHJvbWUgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSwgTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udG8pKSA8PSAyKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmV2ZW50LnkgLSBldmVudC5jbGllbnRZKSA+IDQpKVxuICAgICAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbn1cbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiBmb3JjZURPTUZsdXNoKHZpZXcpO1xuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gICAgLy8gc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCwgY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZVxuICAgIC8vIGVtaXR0ZWQuIFRoZSBrZXlkb3duIGV2ZW50IHRyaWdnZXJzIG5ld2xpbmUgaW5zZXJ0aW9uLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAvLyBXZSBvbmx5IGlnbm9yZSBpdCBvbmNlLCBhcyBwcmVzc2luZyBFbnRlciBhIHNlY29uZCB0aW1lICpzaG91bGQqIGluc2VydCBhIG5ld2xpbmUuXG4gICAgLy8gRnVydGhlcm1vcmUsIHRoZSBrZXlkb3duIGV2ZW50IHRpbWVzdGFtcCBtdXN0IGJlIGNsb3NlIHRvIHRoZSBjb21wb3NpdGlvbkVuZGVkQXQgdGltZXN0YW1wLlxuICAgIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gICAgLy8gKGUuZy4gY2hhcmFjdGVyIGNvbmZpcm1hdGlvbiBtYXkgYmUgZG9uZSB3aXRoIHRoZSBtb3VzZSksIGFuZCBrZXlkb3duIGlzIHRyaWdnZXJlZFxuICAgIC8vIGFmdGVyd2FyZHMtIHdlIHdvdWxkbid0IHdhbnQgdG8gaWdub3JlIHRoZSBrZXlkb3duIGV2ZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoc2FmYXJpICYmIE1hdGguYWJzKGV2ZW50LnRpbWVTdGFtcCAtIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0KSA8IDUwMCkge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBEcm9wIGFjdGl2ZSBjb21wb3NpdGlvbiBhZnRlciA1IHNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiBBbmRyb2lkXG5jb25zdCB0aW1lb3V0Q29tcG9zaXRpb24gPSBhbmRyb2lkID8gNTAwMCA6IC0xO1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBlZGl0SGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpKSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB3cmFwIHRoZSBjdXJzb3IgaW4gbWFyayBub2RlcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lcyBpbiB0aGUgRE9NIGNvbnRleHRcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgfHwgJHBvcy5tYXJrcygpO1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAgICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG9mZnNldCA8IDAgPyBub2RlLmxhc3RDaGlsZCA6IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbVNlbGVjdGlvbigpLmNvbGxhcHNlKGJlZm9yZSwgYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgdGltZW91dENvbXBvc2l0aW9uKTtcbn07XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IHZpZXcuZG9tT2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9IG51bGw7XG4gICAgICAgIGlmICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCsrO1xuICAgICAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgMjApO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgZGVsYXkpIHtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBpZiAoZGVsYXkgPiAtMSlcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBlbmRDb21wb3NpdGlvbih2aWV3KSwgZGVsYXkpO1xufVxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCk7XG4gICAgfVxuICAgIHdoaWxlICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHRleHROb2RlQmVmb3JlJDEoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dEFmdGVyID0gdGV4dE5vZGVBZnRlciQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKHRleHRCZWZvcmUgJiYgdGV4dEFmdGVyICYmIHRleHRCZWZvcmUgIT0gdGV4dEFmdGVyKSB7XG4gICAgICAgIGxldCBkZXNjQWZ0ZXIgPSB0ZXh0QWZ0ZXIucG1WaWV3RGVzYywgbGFzdENoYW5nZWQgPSB2aWV3LmRvbU9ic2VydmVyLmxhc3RDaGFuZ2VkVGV4dE5vZGU7XG4gICAgICAgIGlmICh0ZXh0QmVmb3JlID09IGxhc3RDaGFuZ2VkIHx8IHRleHRBZnRlciA9PSBsYXN0Q2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiBsYXN0Q2hhbmdlZDtcbiAgICAgICAgaWYgKCFkZXNjQWZ0ZXIgfHwgIWRlc2NBZnRlci5pc1RleHQodGV4dEFmdGVyLm5vZGVWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPT0gdGV4dEFmdGVyKSB7XG4gICAgICAgICAgICBsZXQgZGVzY0JlZm9yZSA9IHRleHRCZWZvcmUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmICghKCFkZXNjQmVmb3JlIHx8ICFkZXNjQmVmb3JlLmlzVGV4dCh0ZXh0QmVmb3JlLm5vZGVWYWx1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRCZWZvcmUgfHwgdGV4dEFmdGVyO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRleHQoY2xpcGJvYXJkRGF0YSkge1xuICAgIGxldCB0ZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmICh0ZXh0KVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBsZXQgdXJpcyA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIik7XG4gICAgcmV0dXJuIHVyaXMgPyB1cmlzLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpIDogXCJcIjtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBnZXRUZXh0KGRhdGEpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IG1vdXNlRG93biA9IHZpZXcuaW5wdXQubW91c2VEb3duO1xuICAgIGlmIChtb3VzZURvd24pXG4gICAgICAgIG1vdXNlRG93bi5kb25lKCk7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO1xuICAgIGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgbW91c2VEb3duLm1pZ2h0RHJhZy5wb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZXZlbnQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpXG4gICAgICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIGRlc2MucG9zQmVmb3JlKTtcbiAgICB9XG4gICAgbGV0IGRyYWdnZWRTbGljZSA9IChub2RlIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uKS5jb250ZW50KCk7XG4gICAgbGV0IHsgZG9tLCB0ZXh0LCBzbGljZSB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIGRyYWdnZWRTbGljZSk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGJyb2tlbkNsaXBib2FyZEFQSSA/IFwiVGV4dFwiIDogXCJ0ZXh0L2h0bWxcIiwgZG9tLmlubmVySFRNTCk7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvMTE1NlxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIGlmICghYnJva2VuQ2xpcGJvYXJkQVBJKVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgdmlldy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhzbGljZSwgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdLCBub2RlKTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKVxuICAgICAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfSwgNTApO1xufTtcbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSAoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuZWRpdEhhbmRsZXJzLmRyb3AgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZXZlbnRQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFldmVudFBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkbW91c2UgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGV2ZW50UG9zLnBvcyk7XG4gICAgbGV0IHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZ2V0VGV4dChldmVudC5kYXRhVHJhbnNmZXIpLCBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGZhbHNlLCAkbW91c2UpO1xuICAgIH1cbiAgICBsZXQgbW92ZSA9ICEhKGRyYWdnaW5nICYmICFldmVudFtkcmFnQ29weU1vZGlmaWVyXSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHksIG1vdmUpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBpbnNlcnRQb3MgPSBzbGljZSA/IGRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgICBpZiAoaW5zZXJ0UG9zID09IG51bGwpXG4gICAgICAgIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBkcmFnZ2luZztcbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBub2RlLnJlcGxhY2UodHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgbGV0IGlzTm9kZSA9IHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMTtcbiAgICBsZXQgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgZWxzZVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgICBpZiAodHIuZG9jLmVxKGJlZm9yZUluc2VydCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAgICRwb3Mubm9kZUFmdGVyICYmICRwb3Mubm9kZUFmdGVyLnNhbWVNYXJrdXAoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiBlbmQgPSBuZXdUbyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRwb3MsIHRyLmRvYy5yZXNvbHZlKGVuZCkpKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn07XG5oYW5kbGVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5kb2NWaWV3ICYmIHZpZXcuaGFzRm9jdXMoKSAmJiAhdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmx1ciA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKHZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gZmFsc2U7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgZG8gbW9yZSB3aXRoIGJlZm9yZWlucHV0IGV2ZW50cywgYnV0IHN1cHBvcnRcbiAgICAvLyBpcyBzbyBzcG90dHkgdGhhdCBJJ20gc3RpbGwgd2FpdGluZyB0byBzZWUgd2hlcmUgdGhleSBhcmUgZ29pbmcuXG4gICAgLy8gVmVyeSBzcGVjaWZpYyBoYWNrIHRvIGRlYWwgd2l0aCBiYWNrc3BhY2Ugc29tZXRpbWVzIGZhaWxpbmcgb25cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aGVuIGFmdGVyIGFuIHVuZWRpdGFibGUgbm9kZS5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICAgICAgbGV0IHsgZG9tQ2hhbmdlQ291bnQgfSA9IHZpZXcuaW5wdXQ7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQgIT0gZG9tQ2hhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBFdmVudCBhbHJlYWR5IGhhZCBzb21lIGVmZmVjdFxuICAgICAgICAgICAgLy8gVGhpcyBidWcgdGVuZHMgdG8gY2xvc2UgdGhlIHZpcnR1YWwga2V5Ym9hcmQsIHNvIHdlIHJlZm9jdXNcbiAgICAgICAgICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIENydWRlIGFwcHJveGltYXRpb24gb2YgYmFja3NwYWNlIGJlaGF2aW9yIHdoZW4gbm8gY29tbWFuZCBoYW5kbGVkIGl0XG4gICAgICAgICAgICBpZiAoJGN1cnNvciAmJiAkY3Vyc29yLnBvcyA+IDApXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZSgkY3Vyc29yLnBvcyAtIDEsICRjdXJzb3IucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG4vLyBNYWtlIHN1cmUgYWxsIGhhbmRsZXJzIGdldCByZWdpc3RlcmVkXG5mb3IgKGxldCBwcm9wIGluIGVkaXRIYW5kbGVycylcbiAgICBoYW5kbGVyc1twcm9wXSA9IGVkaXRIYW5kbGVyc1twcm9wXTtcblxuZnVuY3Rpb24gY29tcGFyZU9ianMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodG9ET00sIHNwZWMpIHtcbiAgICAgICAgdGhpcy50b0RPTSA9IHRvRE9NO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5zcGVjLnNpZGUgfHwgMDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IHBvcywgZGVsZXRlZCB9ID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBudWxsIDogbmV3IERlY29yYXRpb24ocG9zIC0gb2Zmc2V0LCBwb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VHlwZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnNwZWMua2V5ICYmIHRoaXMuc3BlYy5rZXkgPT0gb3RoZXIuc3BlYy5rZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b0RPTSA9PSBvdGhlci50b0RPTSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKSk7XG4gICAgfVxuICAgIGRlc3Ryb3kobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveShub2RlKTtcbiAgICB9XG59XG5jbGFzcyBJbmxpbmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVTdGFydCA/IC0xIDogMSkgLSBvZmZzZXQ7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKHNwYW4udG8gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVFbmQgPyAxIDogLTEpIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gZnJvbSA+PSB0byA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKF8sIHNwYW4pIHsgcmV0dXJuIHNwYW4uZnJvbSA8IHNwYW4udG87IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgSW5saW5lVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzKHNwYW4pIHsgcmV0dXJuIHNwYW4udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLnRvICsgb2xkT2Zmc2V0LCAtMSk7XG4gICAgICAgIGlmICh0by5kZWxldGVkIHx8IHRvLnBvcyA8PSBmcm9tLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbS5wb3MgLSBvZmZzZXQsIHRvLnBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKG5vZGUsIHNwYW4pIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pLCBjaGlsZDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PSBzcGFuLmZyb20gJiYgIShjaGlsZCA9IG5vZGUuY2hpbGQoaW5kZXgpKS5pc1RleHQgJiYgb2Zmc2V0ICsgY2hpbGQubm9kZVNpemUgPT0gc3Bhbi50bztcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG4vKipcbkRlY29yYXRpb24gb2JqZWN0cyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHZpZXcgdGhyb3VnaCB0aGVcbltgZGVjb3JhdGlvbnNgIHByb3BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmRlY29yYXRpb25zKS4gVGhleSBjb21lIGluXG5zZXZlcmFsIHZhcmlhbnRzXHUyMDE0c2VlIHRoZSBzdGF0aWMgbWVtYmVycyBvZiB0aGlzIGNsYXNzIGZvciBkZXRhaWxzLlxuKi9cbmNsYXNzIERlY29yYXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbi4gV2lsbCBiZSB0aGUgc2FtZSBhcyBgZnJvbWAgZm9yIFt3aWRnZXRcbiAgICBkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl53aWRnZXQpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lcShvdGhlci50eXBlKSAmJiB0aGlzLmZyb20gKyBvZmZzZXQgPT0gb3RoZXIuZnJvbSAmJiB0aGlzLnRvICsgb2Zmc2V0ID09IG90aGVyLnRvO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLm1hcChtYXBwaW5nLCB0aGlzLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZSB0aGF0J3Mgc2hvd24gaW5cbiAgICB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdVxuICAgIGRlbGF5IHJlbmRlcmluZyB0aGUgd2lkZ2V0IGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAgICBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIGFjdHVhbGx5IGRyYXduIGluIGEgdmlldywgYnV0IHlvdSBjYW5cbiAgICBhbHNvIGRpcmVjdGx5IHBhc3MgYSBET00gbm9kZS4gYGdldFBvc2AgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGVcbiAgICB3aWRnZXQncyBjdXJyZW50IGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChwb3MsIHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihwb3MsIHBvcywgbmV3IFdpZGdldFR5cGUodG9ET00sIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhbiBpbmxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0b1xuICAgIGVhY2ggaW5saW5lIG5vZGUgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBzdGF0aWMgaW5saW5lKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBJbmxpbmVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSBub2RlIGRlY29yYXRpb24uIGBmcm9tYCBhbmQgYHRvYCBzaG91bGQgcG9pbnQgcHJlY2lzZWx5XG4gICAgYmVmb3JlIGFuZCBhZnRlciBhIG5vZGUgaW4gdGhlIGRvY3VtZW50LiBUaGF0IG5vZGUsIGFuZCBvbmx5IHRoYXRcbiAgICBub2RlLCB3aWxsIHJlY2VpdmUgdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgTm9kZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNwZWMgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyB0aGlzIGRlY29yYXRpb24uIENhbiBiZSB1c2VmdWxcbiAgICBpZiB5b3UndmUgc3RvcmVkIGV4dHJhIGluZm9ybWF0aW9uIGluIHRoYXQgb2JqZWN0LlxuICAgICovXG4gICAgZ2V0IHNwZWMoKSB7IHJldHVybiB0aGlzLnR5cGUuc3BlYzsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBXaWRnZXRUeXBlOyB9XG59XG5jb25zdCBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuLyoqXG5BIGNvbGxlY3Rpb24gb2YgW2RlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKSwgb3JnYW5pemVkIGluIHN1Y2hcbmEgd2F5IHRoYXQgdGhlIGRyYXdpbmcgYWxnb3JpdGhtIGNhbiBlZmZpY2llbnRseSB1c2UgYW5kIGNvbXBhcmVcbnRoZW0uIFRoaXMgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlXHUyMDE0aXQgaXMgbm90IG1vZGlmaWVkLFxudXBkYXRlcyBjcmVhdGUgYSBuZXcgdmFsdWUuXG4qL1xuY2xhc3MgRGVjb3JhdGlvblNldCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbCwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zLCB1c2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBUaGlzIHdpbGwgY29uc3VtZSAobW9kaWZ5KSB0aGUgYGRlY29yYXRpb25zYCBhcnJheSwgc29cbiAgICB5b3UgbXVzdCBtYWtlIGEgY29weSBpZiB5b3Ugd2FudCBuZWVkIHRvIHByZXNlcnZlIHRoYXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zLmxlbmd0aCA/IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgZG9jLCAwLCBub1NwZWMpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYWxsIGRlY29yYXRpb25zIGluIHRoaXMgc2V0IHdoaWNoIHRvdWNoIHRoZSBnaXZlbiByYW5nZVxuICAgIChpbmNsdWRpbmcgZGVjb3JhdGlvbnMgdGhhdCBzdGFydCBvciBlbmQgZGlyZWN0bHkgYXQgdGhlXG4gICAgYm91bmRhcmllcykgYW5kIG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGUgb24gdGhlaXIgc3BlYy4gV2hlblxuICAgIGBzdGFydGAgYW5kIGBlbmRgIGFyZSBvbWl0dGVkLCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhlIHNldCBhcmVcbiAgICBjb25zaWRlcmVkLiBXaGVuIGBwcmVkaWNhdGVgIGlzbid0IGdpdmVuLCBhbGwgZGVjb3JhdGlvbnMgYXJlXG4gICAgYXNzdW1lZCB0byBtYXRjaC5cbiAgICAqL1xuICAgIGZpbmQoc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5maW5kSW5uZXIoc3RhcnQgPT0gbnVsbCA/IDAgOiBzdGFydCwgZW5kID09IG51bGwgPyAxZTkgOiBlbmQsIHJlc3VsdCwgMCwgcHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmluZElubmVyKHN0YXJ0LCBlbmQsIHJlc3VsdCwgb2Zmc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGVuZCAmJiBzcGFuLnRvID49IHN0YXJ0ICYmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShzcGFuLnNwZWMpKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFuLmNvcHkoc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA8IGVuZCAmJiB0aGlzLmNoaWxkcmVuW2kgKyAxXSA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT2ZmID0gdGhpcy5jaGlsZHJlbltpXSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMl0uZmluZElubmVyKHN0YXJ0IC0gY2hpbGRPZmYsIGVuZCAtIGNoaWxkT2ZmLCByZXN1bHQsIG9mZnNldCArIGNoaWxkT2ZmLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIGRvYywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSB8fCBtYXBwaW5nLm1hcHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwSW5uZXIobWFwcGluZywgZG9jLCAwLCAwLCBvcHRpb25zIHx8IG5vU3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwSW5uZXIobWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG5ld0xvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICYmIG1hcHBlZC50eXBlLnZhbGlkKG5vZGUsIG1hcHBlZCkpXG4gICAgICAgICAgICAgICAgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHRoaXMubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG1hcENoaWxkcmVuKHRoaXMuY2hpbGRyZW4sIG5ld0xvY2FsIHx8IFtdLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXdMb2NhbCA/IG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBub25lKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb25zIHRvIHRoZSBvbmVzIGluIHRoZSBzZXQsXG4gICAgcHJvZHVjaW5nIGEgbmV3IHNldC4gQ29uc3VtZXMgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXkuIE5lZWRzXG4gICAgYWNjZXNzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IHRvIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHJlZVxuICAgIHN0cnVjdHVyZS5cbiAgICAqL1xuICAgIGFkZChkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiwgY2hpbGRJbmRleCA9IDA7XG4gICAgICAgIGRvYy5mb3JFYWNoKChjaGlsZE5vZGUsIGNoaWxkT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYmFzZU9mZnNldCA9IGNoaWxkT2Zmc2V0ICsgb2Zmc2V0LCBmb3VuZDtcbiAgICAgICAgICAgIGlmICghKGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShkZWNvcmF0aW9ucywgY2hpbGROb2RlLCBiYXNlT2Zmc2V0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXSA9IGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXS5hZGRJbm5lcihjaGlsZE5vZGUsIGZvdW5kLCBiYXNlT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkT2Zmc2V0LCBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQgKyAxLCBub1NwZWMpKTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsb2NhbCA9IG1vdmVTcGFucyhjaGlsZEluZGV4ID8gd2l0aG91dE51bGxzKGRlY29yYXRpb25zKSA6IGRlY29yYXRpb25zLCAtb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghbG9jYWxbaV0udHlwZS52YWxpZChkb2MsIGxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLmxlbmd0aCA/IHRoaXMubG9jYWwuY29uY2F0KGxvY2FsKS5zb3J0KGJ5UG9zKSA6IHRoaXMubG9jYWwsIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc2V0IHRoYXQgY29udGFpbnMgdGhlIGRlY29yYXRpb25zIGluIHRoaXMgc2V0LCBtaW51c1xuICAgIHRoZSBvbmVzIGluIHRoZSBnaXZlbiBhcnJheS5cbiAgICAqL1xuICAgIHJlbW92ZShkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIHJlbW92ZUlubmVyKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQ7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGNoaWxkcmVuW2ldICsgb2Zmc2V0LCB0byA9IGNoaWxkcmVuW2kgKyAxXSArIG9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBzcGFuOyBqIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Bhbi5mcm9tID4gZnJvbSAmJiBzcGFuLnRvIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zW2pdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGNoaWxkcmVuW2kgKyAyXS5yZW1vdmVJbm5lcihmb3VuZCwgZnJvbSArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWwubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxbal0uZXEoc3Bhbiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMubG9jYWwuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIGxvY2FsLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIDogZW1wdHk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFN0YXJ0ID49IGJhc2VPZmZzZXQgJiYgZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlZCArPSBkU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VPZmZzZXQgPSBtYXBwaW5nLm1hcHNbaV0ubWFwKGJhc2VPZmZzZXQsIC0xKTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgY2hpbGQgbm9kZXMgdGhhdCBzdGlsbCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIG5vZGUsXG4gICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBtYXBJbm5lciBvbiB0aGVtIGFuZCB1cGRhdGUgdGhlaXIgcG9zaXRpb25zLlxuICAgIGxldCBtdXN0UmVidWlsZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7IC8vIFRvdWNoZWQgbm9kZXNcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTIpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0KSwgZnJvbUxvY2FsID0gZnJvbSAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChmcm9tTG9jYWwgPCAwIHx8IGZyb21Mb2NhbCA+PSBub2RlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11c3QgcmVhZCBvbGRDaGlsZHJlbiBiZWNhdXNlIGNoaWxkcmVuIHdhcyB0YWdnZWQgd2l0aCAtMVxuICAgICAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baSArIDFdICsgb2xkT2Zmc2V0LCAtMSksIHRvTG9jYWwgPSB0byAtIG9mZnNldDtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQ6IGNoaWxkT2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KGZyb21Mb2NhbCk7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGRPZmZzZXQgPT0gZnJvbUxvY2FsICYmIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplID09IHRvTG9jYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hpbGRyZW5baSArIDJdXG4gICAgICAgICAgICAgICAgICAgIC5tYXBJbm5lcihtYXBwaW5nLCBjaGlsZE5vZGUsIGZyb20gKyAxLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSBmcm9tTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0yO1xuICAgICAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gUmVtYWluaW5nIGNoaWxkcmVuIG11c3QgYmUgY29sbGVjdGVkIGFuZCByZWJ1aWx0IGludG8gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZVxuICAgIGlmIChtdXN0UmVidWlsZCkge1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGxldCBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgICAgIG5ld0xvY2FsID0gYnVpbHQubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1aWx0LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBmcm9tKVxuICAgICAgICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAwLCBidWlsdC5jaGlsZHJlbltpXSwgYnVpbHQuY2hpbGRyZW5baSArIDFdLCBidWlsdC5jaGlsZHJlbltpICsgMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbW92ZVNwYW5zKHNwYW5zLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCB8fCAhc3BhbnMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gc3BhbnM7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgLy8gR2F0aGVyIGFsbCBkZWNvcmF0aW9ucyBmcm9tIHRoZSByZW1haW5pbmcgbWFya2VkIGNoaWxkcmVuXG4gICAgZnVuY3Rpb24gZ2F0aGVyKHNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gc2V0LmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBnYXRoZXIoc2V0LmNoaWxkcmVuW2kgKyAyXSwgc2V0LmNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpXG4gICAgICAgICAgICBnYXRoZXIoY2hpbGRyZW5baSArIDJdLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmZ1bmN0aW9uIHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGVuZCA9IG9mZnNldCArIG5vZGUubm9kZVNpemUsIGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoc3BhbiA9IHNwYW5zW2ldKSAmJiBzcGFuLmZyb20gPiBvZmZzZXQgJiYgc3Bhbi50byA8IGVuZCkge1xuICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgIHNwYW5zW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiB3aXRob3V0TnVsbHMoYXJyYXkpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFycmF5W2ldICE9IG51bGwpXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEJ1aWxkIHVwIGEgdHJlZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgc2V0IG9mIGRlY29yYXRpb25zLiBgb2Zmc2V0YFxuLy8gaXMgYSBiYXNlIG9mZnNldCB0aGF0IHNob3VsZCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGBmcm9tYCBhbmQgYHRvYFxuLy8gcG9zaXRpb25zIGluIHRoZSBzcGFucyAoc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGFsbG9jYXRlIG5ldyBzcGFuc1xuLy8gZm9yIHJlY3Vyc2l2ZSBjYWxscykuXG5mdW5jdGlvbiBidWlsZFRyZWUoc3BhbnMsIG5vZGUsIG9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBoYXNOdWxscyA9IGZhbHNlO1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGROb2RlLCBsb2NhbFN0YXJ0KSA9PiB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgaGFzTnVsbHMgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHN1YnRyZWUgPSBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgb2Zmc2V0ICsgbG9jYWxTdGFydCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUgIT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsb2NhbFN0YXJ0LCBsb2NhbFN0YXJ0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBzdWJ0cmVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBsb2NhbHMgPSBtb3ZlU3BhbnMoaGFzTnVsbHMgPyB3aXRob3V0TnVsbHMoc3BhbnMpIDogc3BhbnMsIC1vZmZzZXQpLnNvcnQoYnlQb3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWxvY2Fsc1tpXS50eXBlLnZhbGlkKG5vZGUsIGxvY2Fsc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpO1xuICAgICAgICAgICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eTtcbn1cbi8vIFVzZWQgdG8gc29ydCBkZWNvcmF0aW9ucyBzbyB0aGF0IG9uZXMgd2l0aCBhIGxvdyBzdGFydCBwb3NpdGlvblxuLy8gY29tZSBmaXJzdCwgYW5kIHdpdGhpbiBhIHNldCB3aXRoIHRoZSBzYW1lIHN0YXJ0IHBvc2l0aW9uLCB0aG9zZVxuLy8gd2l0aCBhbiBzbWFsbGVyIGVuZCBwb3NpdGlvbiBjb21lIGZpcnN0LlxuZnVuY3Rpb24gYnlQb3MoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG87XG59XG4vLyBTY2FuIGEgc29ydGVkIGFycmF5IG9mIGRlY29yYXRpb25zIGZvciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMsXG4vLyBhbmQgc3BsaXQgdGhvc2Ugc28gdGhhdCBvbmx5IGZ1bGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBsZWZ0ICh0b1xuLy8gbWFrZSBzdWJzZXF1ZW50IHJlbmRlcmluZyBlYXNpZXIpLiBXaWxsIHJldHVybiB0aGUgaW5wdXQgYXJyYXkgaWZcbi8vIG5vIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgZm91bmQgKHRoZSBjb21tb24gY2FzZSkuXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwKHNwYW5zKSB7XG4gICAgbGV0IHdvcmtpbmcgPSBzcGFucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmtpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gd29ya2luZ1tpXTtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBzcGFuLnRvKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgd29ya2luZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gd29ya2luZ1tqXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tID09IHNwYW4uZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC50byAhPSBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGxvd2VkIGJ5IGEgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGxhcmdlciBzcGFuLiBTcGxpdCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFuLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tqXSA9IG5leHQuY29weShuZXh0LmZyb20sIHNwYW4udG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiArIDEsIG5leHQuY29weShzcGFuLnRvLCBuZXh0LnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tIDwgc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW5kIG9mIHRoaXMgb25lIG92ZXJsYXBzIHdpdGggYSBzdWJzZXF1ZW50IHNwYW4uIFNwbGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbaV0gPSBzcGFuLmNvcHkoc3Bhbi5mcm9tLCBuZXh0LmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiwgc3Bhbi5jb3B5KG5leHQuZnJvbSwgc3Bhbi50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmtpbmc7XG59XG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoICYmIGJ5UG9zKGRlY28sIGFycmF5W2ldKSA+IDApXG4gICAgICAgIGkrKztcbiAgICBhcnJheS5zcGxpY2UoaSwgMCwgZGVjbyk7XG59XG4vLyBHZXQgdGhlIGRlY29yYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBwcm9wcyBvZiBhIHZpZXcuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIHZpZXcuc29tZVByb3AoXCJkZWNvcmF0aW9uc1wiLCBmID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0ICE9IGVtcHR5KVxuICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpXG4gICAgICAgIGZvdW5kLnB1c2goRGVjb3JhdGlvblNldC5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIFt2aWV3LmN1cnNvcldyYXBwZXIuZGVjb10pKTtcbiAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xufVxuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0byBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcbmNvbnN0IHVzZUNoYXJEYXRhID0gaWUgJiYgaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIFNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBzZXQoc2VsKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICB9XG4gICAgZXEoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PSB0aGlzLmFuY2hvck5vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PSB0aGlzLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldDtcbiAgICB9XG59XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlID0gaGFuZGxlRE9NQ2hhbmdlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMub25DaGFyRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJlxuICAgICAgICAgICAgbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXRhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gUHJvc2VNaXJyb3IgdG8gbWlzcyB0aGUgY2hhbmdlIChzZWUgIzkzMClcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZmx1c2hpbmdTb29uID0gLTE7IHRoaXMuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmZsdXNoaW5nU29vbik7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgbGV0IHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICBpZiAodGFrZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0YWtlW2ldKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoKCksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCkge1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZSwgNTApO1xuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KTtcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFXG4gICAgICAgICAgICBpZiAoc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHNldEN1clNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldCh0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgfVxuICAgIGlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpIHtcbiAgICAgICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBhbmNlc3RvcnMgPSBuZXcgU2V0LCBjb250YWluZXI7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuZm9jdXNOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGFuY2VzdG9ycy5hZGQoc2Nhbik7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuYW5jaG9yTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhzY2FuKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHNjYW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gY29udGFpbmVyICYmIHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF2aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG11dGF0aW9ucyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSAhdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgJiYgIXRoaXMuY3VycmVudFNlbGVjdGlvbi5lcShzZWwpICYmIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpICYmICF0aGlzLmlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlLCBhZGRlZCA9IFtdO1xuICAgICAgICBpZiAodmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZWdpc3Rlck11dGF0aW9uKG11dGF0aW9uc1tpXSwgYWRkZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0LmZyb20gOiBNYXRoLm1pbihyZXN1bHQuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gdG8gPCAwID8gcmVzdWx0LnRvIDogTWF0aC5tYXgocmVzdWx0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZWNrbyAmJiBhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IFthLCBiXSA9IGJycztcbiAgICAgICAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmb2N1c05vZGUgfSA9IHRoaXMuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiciBvZiBicnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGJyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lID09IFwiTElcIiAmJiAoIWZvY3VzTm9kZSB8fCBibG9ja1BhcmVudCh2aWV3LCBmb2N1c05vZGUpICE9IHBhcmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBici5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRTZWwgPSBudWxsO1xuICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIHRoZSBicm93c2VyIGhhcyByZXNldCB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAgICAgICAvLyBzdGFydCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgZm9jdXMsIHJlc3RvcmUgdGhlIHNlbGVjdGlvbiBmcm9tXG4gICAgICAgIC8vIHRoZSBzdGF0ZVxuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgbmV3U2VsICYmIHZpZXcuaW5wdXQubGFzdEZvY3VzID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgTWF0aC5tYXgodmlldy5pbnB1dC5sYXN0VG91Y2gsIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUpIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkgJiYgKHJlYWRTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpKSAmJlxuICAgICAgICAgICAgcmVhZFNlbC5lcShTZWxlY3Rpb24ubmVhcih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKDApLCAxKSkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gMDtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgICAgICAgdmlldy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb20gPiAtMSB8fCBuZXdTZWwpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBjaGVja0NTUyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiZcbiAgICAgICAgICAgIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNvbWV0aW1lcyBmaXJlcyBzcHVyaW91cyBldmVudHMgZm9yIG51bGwvZW1wdHkgc3R5bGVzXG4gICAgICAgICAgICAgICAgKG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXIgfTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbXV0LnByZXZpb3VzU2libGluZywgbmV4dCA9IG11dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dC5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgICAgICAgICAgIC8vIGluc2VydGlvbnMsIHNvIGlmIHRoZXJlIGFyZSBhZGRlZCBub2RlcywgcmVjb21wdXRlIHRob3NlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nIH0gPSBtdXQuYWRkZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgcHJldmlvdXNTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIG5leHRTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChwcmV2KSArIDEgOiAwO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCBmcm9tT2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICBsZXQgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChuZXh0KSA6IG11dC50YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG8gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCB0b09mZnNldCwgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciwgdG86IGRlc2MucG9zQXRFbmQgKyBkZXNjLmJvcmRlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBcImNoYXJhY3RlckRhdGFcIlxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbXV0LnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgZm9yIGEgdGV4dCBjaGFuZ2UgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gYW55IHRleHQuIE1hcmsgdGhlIGRvbSBjaGFuZ2UgdG8gZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBjc3NDaGVja2VkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBjc3NDaGVja1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICAgIGlmIChjc3NDaGVja2VkLmhhcyh2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNzc0NoZWNrZWQuc2V0KHZpZXcsIG51bGwpO1xuICAgIGlmIChbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlLWxpbmUnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UpICE9PSAtMSkge1xuICAgICAgICB2aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGdlY2tvO1xuICAgICAgICBpZiAoY3NzQ2hlY2tXYXJuZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiUHJvc2VNaXJyb3IgZXhwZWN0cyB0aGUgQ1NTIHdoaXRlLXNwYWNlIHByb3BlcnR5IHRvIGJlIHNldCwgcHJlZmVyYWJseSB0byAncHJlLXdyYXAnLiBJdCBpcyByZWNvbW1lbmRlZCB0byBsb2FkIHN0eWxlL3Byb3NlbWlycm9yLmNzcyBmcm9tIHRoZSBwcm9zZW1pcnJvci12aWV3IHBhY2thZ2UuXCIpO1xuICAgICAgICBjc3NDaGVja1dhcm5lZCA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IHJhbmdlLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1cnJlbnRBbmNob3IgPSB2aWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VycmVudEFuY2hvci5ub2RlLCBjdXJyZW50QW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1Z1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTQgZml4XG5mdW5jdGlvbiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kO1xuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjIpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93Um9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl0XHUyMDE0dXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIGZvdW5kKSA6IG51bGw7XG59XG5mdW5jdGlvbiBibG9ja1BhcmVudCh2aWV3LCBub2RlKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGUucGFyZW50Tm9kZTsgcCAmJiBwICE9IHZpZXcuZG9tOyBwID0gcC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHAsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmICEkZnJvbS5zYW1lUGFyZW50KCR0bykgJiZcbiAgICAgICAgICAgIChuZXh0U2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKHBhcnNlLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpLCAxLCB0cnVlKSkgJiZcbiAgICAgICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlQmFja3NwYWNlKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpIHtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTsgLy8gIzgyMFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgb2NjYXNpb25hbGx5LCBkdXJpbmcgY29tcG9zaXRpb24sIGRlbGV0ZSB0aGVcbiAgICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gICAgLy8gdXNlZCB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydClcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0QW5kcm9pZERlbGV0ZSA9IERhdGUubm93KCk7XG4gICAgLy8gVGhpcyB0cmllcyB0byBkZXRlY3QgQW5kcm9pZCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgICAvLyAjMTA1OSkgZmlyc3QgZmlyZXMgYSBET00gbXV0YXRpb24sIGJlZm9yZSBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0b1xuICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIGJsb2NrLiBBbmQgdGhlbiwgYmVjYXVzZSBQcm9zZU1pcnJvciBjbGVhbnMgdXBcbiAgICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gICAgLy8gbGVhdmluZyB0aGUgY3Vyc29yIGluIHRoZSB3cm9uZyBwbGFjZS4gV2hlbiB0aGF0IGhhcHBlbnMsIHdlIGRyb3BcbiAgICAvLyB0aGUgbmV3IHBhcmFncmFwaCBmcm9tIHRoZSBpbml0aWFsIGNoYW5nZSwgYW5kIGZpcmUgYSBzaW11bGF0ZWRcbiAgICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgICBpZiAoYW5kcm9pZCAmJiAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnN0YXJ0KCkgIT0gJHRvLnN0YXJ0KCkgJiYgJHRvLnBhcmVudE9mZnNldCA9PSAwICYmICRmcm9tLmRlcHRoID09ICR0by5kZXB0aCAmJlxuICAgICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgICAgICBjaGFuZ2UuZW5kQiAtPSAyO1xuICAgICAgICAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxuICAgIGxldCBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcbiAgICBsZXQgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIC8vIEFkZGluZyBvciByZW1vdmluZyBhIG1hcmtcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgICAgIChtYXJrQ2hhbmdlID0gaXNNYXJrQ2hhbmdlKCRmcm9tLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpLCAkZnJvbUEucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tQS5wYXJlbnRPZmZzZXQsIGNoYW5nZS5lbmRBIC0gJGZyb21BLnN0YXJ0KCkpKSkpIHtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkZnJvbS5wYXJlbnQuY2hpbGQoJGZyb20uaW5kZXgoKSkuaXNUZXh0ICYmICRmcm9tLmluZGV4KCkgPT0gJHRvLmluZGV4KCkgLSAoJHRvLnRleHRPZmZzZXQgPyAwIDogMSkpIHtcbiAgICAgICAgICAgIC8vIEJvdGggcG9zaXRpb25zIGluIHRoZSBzYW1lIHRleHQgbm9kZSAtLSBzaW1wbHkgaW5zZXJ0IHRleHRcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCwgY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyKVxuICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHRyLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBzb21ldGltZXMsIGR1cmluZyBjb21wb3NpdGlvbiwgcmVwb3J0IHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIHdyb25nIHBsYWNlLiBJZiBpdCBsb29rcyBsaWtlIHRoYXQgaXNcbiAgICAgICAgLy8gaGFwcGVuaW5nLCBkb24ndCB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgLy8gRWRnZSBqdXN0IGRvZXNuJ3QgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgd2hlbiB5b3Ugc3RhcnQgdHlwaW5nXG4gICAgICAgIC8vIGluIGFuIGVtcHR5IGJsb2NrIG9yIGJldHdlZW4gYnIgbm9kZXMuXG4gICAgICAgIGlmIChzZWwgJiYgIShjaHJvbWUgJiYgYW5kcm9pZCAmJiB2aWV3LmNvbXBvc2luZyAmJiBzZWwuZW1wdHkgJiZcbiAgICAgICAgICAgIChjaGFuZ2Uuc3RhcnQgIT0gY2hhbmdlLmVuZEIgfHwgdmlldy5pbnB1dC5sYXN0QW5kcm9pZERlbGV0ZSA8IERhdGUubm93KCkgLSAxMDApICYmXG4gICAgICAgICAgICAoc2VsLmhlYWQgPT0gY2hGcm9tIHx8IHNlbC5oZWFkID09IHRyLm1hcHBpbmcubWFwKGNoVG8pIC0gMSkgfHxcbiAgICAgICAgICAgIGllICYmIHNlbC5lbXB0eSAmJiBzZWwuaGVhZCA9PSBjaEZyb20pKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgfVxuICAgIGlmIChzdG9yZWRNYXJrcylcbiAgICAgICAgdHIuZW5zdXJlTWFya3Moc3RvcmVkTWFya3MpO1xuICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb24odmlldywgZG9jLCBwYXJzZWRTZWwpIHtcbiAgICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG4vLyBHaXZlbiB0d28gc2FtZS1sZW5ndGgsIG5vbi1lbXB0eSBmcmFnbWVudHMgb2YgaW5saW5lIGNvbnRlbnQsXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmlyc3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBzZWNvbmQgYnlcbi8vIHJlbW92aW5nIG9yIGFkZGluZyBhIHNpbmdsZSBtYXJrIHR5cGUuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gICAgbGV0IGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsIHByZXZNYXJrcyA9IHByZXYuZmlyc3RDaGlsZC5tYXJrcztcbiAgICBsZXQgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZW1vdmVkID0gY3VyTWFya3NbaV0ucmVtb3ZlRnJvbVNldChyZW1vdmVkKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgICAgIHR5cGUgPSBcImFkZFwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgICAgICB0eXBlID0gXCJyZW1vdmVcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKGkpKSk7XG4gICAgaWYgKEZyYWdtZW50LmZyb20odXBkYXRlZCkuZXEoY3VyKSlcbiAgICAgICAgcmV0dXJuIHsgbWFyaywgdHlwZSB9O1xufVxuZnVuY3Rpb24gbG9va3NMaWtlQmFja3NwYWNlKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSwgcmF0aGVyIHRoYW4gam9pbmluZyBibG9ja3MsIHRoZSBjaGFuZ2UganVzdCByZW1vdmVkIGFuIGVudGlyZSBibG9ja1xuICAgIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSAkc3RhcnQubm9kZUFmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXIgIT0gbnVsbCAmJiBlbmQgPT0gc3RhcnQgKyBhZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9IGZpbmRDb21wb3NpdGlvbk5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAhdGhpcy50cmFja1dyaXRlcylcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIGFuIGlzc3VlIHdoZXJlIGFuIHVwZGF0ZSBhcnJpdmluZyByaWdodCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIHNwdXJpb3VzIERPTSBzZWxlY3Rpb24gdXBkYXRlLCBkaXNydXB0aW5nIG1vdXNlXG4gICAgICAgICAgICAvLyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb2RlU2VsZWN0aW9uKHRoaXMsIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuZHJhZ2dpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlKSAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ2dlZE5vZGUodGhpcy5kcmFnZ2luZywgcHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICh0aGlzLnNvbWVQcm9wKFwiaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb25cIiwgZiA9PiBmKHRoaXMpKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgMSksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICB3aGlsZSAodmlldyA9IHRoaXMucGx1Z2luVmlld3MucG9wKCkpXG4gICAgICAgICAgICBpZiAodmlldy5kZXN0cm95KVxuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlLnBsdWdpbnMgIT0gdGhpcy5zdGF0ZS5wbHVnaW5zIHx8IHRoaXMuZGlyZWN0UGx1Z2lucyAhPSB0aGlzLnByZXZEaXJlY3RQbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURyYWdnZWROb2RlKGRyYWdnaW5nLCBwcmV2KSB7XG4gICAgICAgIGxldCBzZWwgPSBkcmFnZ2luZy5ub2RlLCBmb3VuZCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kb2Mubm9kZUF0KHNlbC5mcm9tKSA9PSBzZWwubm9kZSkge1xuICAgICAgICAgICAgZm91bmQgPSBzZWwuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3ZlZFBvcyA9IHNlbC5mcm9tICsgKHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIHByZXYuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBtb3ZlZFBvcyA+IDAgJiYgdGhpcy5zdGF0ZS5kb2Mubm9kZUF0KG1vdmVkUG9zKTtcbiAgICAgICAgICAgIGlmIChtb3ZlZCA9PSBzZWwubm9kZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG1vdmVkUG9zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoZHJhZ2dpbmcuc2xpY2UsIGRyYWdnaW5nLm1vdmUsIGZvdW5kIDwgMCA/IHVuZGVmaW5lZCA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRoaXMuc3RhdGUuZG9jLCBmb3VuZCkpO1xuICAgIH1cbiAgICBzb21lUHJvcChwcm9wTmFtZSwgZikge1xuICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BzICYmIHRoaXMuX3Byb3BzW3Byb3BOYW1lXSwgdmFsdWU7XG4gICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgdmlldyBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgSUUgbm90IGhhbmRsaW5nIGZvY3VzIGNvcnJlY3RseSBpZiByZXNpemUgaGFuZGxlcyBhcmUgc2hvd24uXG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCByZXNpemUgaGFuZGxlcywgYWN0aXZlRWxlbWVudFxuICAgICAgICAvLyB3aWxsIGJlIHRoYXQgZWxlbWVudCBpbnN0ZWFkIG9mIHRoaXMuZG9tLlxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZUVsZW1lbnQgaXMgd2l0aGluIHRoaXMuZG9tLCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBjb250ZW50ZWRpdGFibGVgIHRvIGZhbHNlIGluIGJldHdlZW4sIHRyZWF0IGl0IGFzIGZvY3VzZWQuXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIHRoaXMuZG9tICE9IG5vZGUgJiYgdGhpcy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb207XG4gICAgfVxuICAgIC8qKlxuICAgIEZvY3VzIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKVxuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuZG9tKTtcbiAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbiAgICB1c3VhbGx5IGJlIHRoZSB0b3AtbGV2ZWwgYGRvY3VtZW50YCwgYnV0IG1pZ2h0IGJlIGEgW3NoYWRvd1xuICAgIERPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvU2hhZG93X0RPTSlcbiAgICByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbiAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgICAgICAgaWYgKGNhY2hlZCA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gdGhpcy5kb20ucGFyZW50Tm9kZTsgc2VhcmNoOyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubm9kZVR5cGUgPT0gOSB8fCAoc2VhcmNoLm5vZGVUeXBlID09IDExICYmIHNlYXJjaC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlYXJjaC5nZXRTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSAoKSA9PiBzZWFyY2gub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIGFuIGV4aXN0aW5nIGVkaXRvciB2aWV3IGlzIG1vdmVkIHRvIGEgbmV3IGRvY3VtZW50IG9yXG4gICAgc2hhZG93IHRyZWUsIGNhbGwgdGhpcyB0byBtYWtlIGl0IHJlY29tcHV0ZSBpdHMgcm9vdC5cbiAgICAqL1xuICAgIHVwZGF0ZVJvb3QoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZW0uIE1heSByZXR1cm4gbnVsbCBpZiB0aGUgZ2l2ZW5cbiAgICBjb29yZGluYXRlcyBhcmVuJ3QgaW5zaWRlIG9mIHRoZSBlZGl0b3IuIFdoZW4gYW4gb2JqZWN0IGlzXG4gICAgcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbiAgICBjb29yZGluYXRlcywgYW5kIGl0cyBgaW5zaWRlYCBwcm9wZXJ0eSBob2xkcyB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgaW5uZXIgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBmYWxscyBpbnNpZGUgb2YsIG9yIC0xIGlmIGl0IGlzIGF0XG4gICAgdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuICAgICovXG4gICAgcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUgYXQgYSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgbGVmdGAgYW5kIGByaWdodGAgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIsIGFzIHRoaXMgcmV0dXJucyBhXG4gICAgZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuICAgIHRoYXQgYXJlbid0IGRpcmVjdGx5IGFkamFjZW50LCBgc2lkZWAgZGV0ZXJtaW5lcyB3aGljaCBlbGVtZW50XG4gICAgaXMgdXNlZC4gV2hlbiA8IDAsIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgdXNlZCxcbiAgICBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNBdFBvcyh0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICBwb3NpdGlvbi4gV2hlbiBgc2lkZWAgaXMgbmVnYXRpdmUsIGZpbmQgdGhlIHBvc2l0aW9uIGFzIGNsb3NlIGFzXG4gICAgcG9zc2libGUgdG8gdGhlIGNvbnRlbnQgYmVmb3JlIHRoZSBwb3NpdGlvbi4gV2hlbiBwb3NpdGl2ZSxcbiAgICBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuICAgIHplcm8sIHByZWZlciBhcyBzaGFsbG93IGEgcG9zaXRpb24gYXMgcG9zc2libGUuXG4gICAgXG4gICAgTm90ZSB0aGF0IHlvdSBzaG91bGQgKipub3QqKiBtdXRhdGUgdGhlIGVkaXRvcidzIGludGVybmFsIERPTSxcbiAgICBvbmx5IGluc3BlY3QgaXQgKGFuZCBldmVuIHRoYXQgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQgbm9kZSBhZnRlciB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuICAgIGluIGZyb250IG9mIGEgbm9kZSBvciBpZiB0aGUgbm9kZSBpcyBpbnNpZGUgYW4gb3BhcXVlIG5vZGUgdmlldy5cbiAgICBcbiAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGluZ3MgbGlrZVxuICAgIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG9uIHRoYXQgRE9NIG5vZGUuIERvICoqbm90KiogbXV0YXRlIHRoZVxuICAgIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbiAgICBpbW1lZGlhdGVseSBvdmVycmlkZW4gYnkgdGhlIGVkaXRvciBhcyBpdCByZWRyYXdzIHRoZSBub2RlLlxuICAgICovXG4gICAgbm9kZURPTShwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmRvY1ZpZXcuZGVzY0F0KHBvcyk7XG4gICAgICAgIHJldHVybiBkZXNjID8gZGVzYy5ub2RlRE9NIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIERPTVxuICAgIHBvc2l0aW9uLiAoV2hlbmV2ZXIgcG9zc2libGUsIGl0IGlzIHByZWZlcmFibGUgdG8gaW5zcGVjdCB0aGVcbiAgICBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4gICAgRE9NLCBidXQgc29tZXRpbWVzXHUyMDE0Zm9yIGV4YW1wbGUgd2hlbiBpbnRlcnByZXRpbmcgYW4gZXZlbnRcbiAgICB0YXJnZXRcdTIwMTR5b3UgZG9uJ3QgaGF2ZSBhIGNob2ljZS4pXG4gICAgXG4gICAgVGhlIGBiaWFzYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHdoaWNoIHNpZGUgb2YgYSBET01cbiAgICBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQsIGJpYXMgPSAtMSkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJET00gcG9zaXRpb24gbm90IGluc2lkZSB0aGUgZWRpdG9yXCIpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIG91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jayB3aGVuXG4gICAgbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbiAgICBpdCB3aWxsIHJldHVybiB0cnVlIGlmIG1vdmluZyBsZWZ0IGZyb20gdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgcG9zaXRpb24gd291bGQgbGVhdmUgdGhhdCBwb3NpdGlvbidzIHBhcmVudCB0ZXh0YmxvY2suIFdpbGwgYXBwbHlcbiAgICB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4gICAgcGFzcyBhIGRpZmZlcmVudCBzdGF0ZS5cbiAgICAqL1xuICAgIGVuZE9mVGV4dGJsb2NrKGRpciwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGVuZE9mVGV4dGJsb2NrKHRoaXMsIHN0YXRlIHx8IHRoaXMuc3RhdGUsIGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gSFRNTCBzdHJpbmcuIFRoZVxuICAgIGBldmVudGAsIGlmIGdpdmVuLCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICBbYGhhbmRsZVBhc3RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlUGFzdGUpIGhvb2suXG4gICAgKi9cbiAgICBwYXN0ZUhUTUwoaHRtbCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgXCJcIiwgaHRtbCwgZmFsc2UsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBwbGFpbi10ZXh0IGlucHV0LlxuICAgICovXG4gICAgcGFzdGVUZXh0KHRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIHRleHQsIG51bGwsIHRydWUsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgICAgIGNsZWFyUmV1c2VkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIERpc3BhdGNoIGEgdHJhbnNhY3Rpb24uIFdpbGwgY2FsbFxuICAgIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgd2hlbiBnaXZlbiwgYW5kIG90aGVyd2lzZSBkZWZhdWx0cyB0byBhcHBseWluZyB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2FsbGluZ1xuICAgIFtgdXBkYXRlU3RhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4gICAgVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIHZpZXcgaW5zdGFuY2UsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgKi9cbiAgICBkaXNwYXRjaCh0cikge1xuICAgICAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHRoaXMsIHNlbCkgfHwgc2VsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBhdHRycy5jbGFzcyA9IFwiUHJvc2VNaXJyb3JcIjtcbiAgICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gICAgdmlldy5zb21lUHJvcChcImF0dHJpYnV0ZXNcIiwgdmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGZvciAobGV0IGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmNsYXNzICs9IFwiIFwiICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ciA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gKGF0dHJzLnN0eWxlID8gYXR0cnMuc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0dHJzW2F0dHJdICYmIGF0dHIgIT0gXCJjb250ZW50ZWRpdGFibGVcIiAmJiBhdHRyICE9IFwibm9kZU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0cl0gPSBTdHJpbmcodmFsdWVbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYXR0cnMudHJhbnNsYXRlKVxuICAgICAgICBhdHRycy50cmFuc2xhdGUgPSBcIm5vXCI7XG4gICAgcmV0dXJuIFtEZWNvcmF0aW9uLm5vZGUoMCwgdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBhdHRycyldO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgaWYgKHZpZXcubWFya0N1cnNvcikge1xuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFsdFwiLCBcIlwiKTtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0geyBkb20sIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIGRvbSwgeyByYXc6IHRydWUsIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3IgfSkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RWRpdGFibGUodmlldykge1xuICAgIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIHZhbHVlID0+IHZhbHVlKHZpZXcuc3RhdGUpID09PSBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gICAgbGV0IGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgICByZXR1cm4gc2VsMS4kYW5jaG9yLnN0YXJ0KGRlcHRoKSAhPSBzZWwyLiRhbmNob3Iuc3RhcnQoZGVwdGgpO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIGFkZChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHByb3ApKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcIm5vZGVWaWV3c1wiLCBhZGQpO1xuICAgIHZpZXcuc29tZVByb3AoXCJtYXJrVmlld3NcIiwgYWRkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gICAgbGV0IG5BID0gMCwgbkIgPSAwO1xuICAgIGZvciAobGV0IHByb3AgaW4gYSkge1xuICAgICAgICBpZiAoYVtwcm9wXSAhPSBiW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG5BKys7XG4gICAgfVxuICAgIGZvciAobGV0IF8gaW4gYilcbiAgICAgICAgbkIrKztcbiAgICByZXR1cm4gbkEgIT0gbkI7XG59XG5mdW5jdGlvbiBjaGVja1N0YXRlQ29tcG9uZW50KHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpO1xufVxuXG5leHBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3LCBfX2VuZENvbXBvc2l0aW9uLCBfX3BhcnNlRnJvbUNsaXBib2FyZCwgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgfTtcbiIsICJleHBvcnQgdmFyIGJhc2UgPSB7XG4gIDg6IFwiQmFja3NwYWNlXCIsXG4gIDk6IFwiVGFiXCIsXG4gIDEwOiBcIkVudGVyXCIsXG4gIDEyOiBcIk51bUxvY2tcIixcbiAgMTM6IFwiRW50ZXJcIixcbiAgMTY6IFwiU2hpZnRcIixcbiAgMTc6IFwiQ29udHJvbFwiLFxuICAxODogXCJBbHRcIixcbiAgMjA6IFwiQ2Fwc0xvY2tcIixcbiAgMjc6IFwiRXNjYXBlXCIsXG4gIDMyOiBcIiBcIixcbiAgMzM6IFwiUGFnZVVwXCIsXG4gIDM0OiBcIlBhZ2VEb3duXCIsXG4gIDM1OiBcIkVuZFwiLFxuICAzNjogXCJIb21lXCIsXG4gIDM3OiBcIkFycm93TGVmdFwiLFxuICAzODogXCJBcnJvd1VwXCIsXG4gIDM5OiBcIkFycm93UmlnaHRcIixcbiAgNDA6IFwiQXJyb3dEb3duXCIsXG4gIDQ0OiBcIlByaW50U2NyZWVuXCIsXG4gIDQ1OiBcIkluc2VydFwiLFxuICA0NjogXCJEZWxldGVcIixcbiAgNTk6IFwiO1wiLFxuICA2MTogXCI9XCIsXG4gIDkxOiBcIk1ldGFcIixcbiAgOTI6IFwiTWV0YVwiLFxuICAxMDY6IFwiKlwiLFxuICAxMDc6IFwiK1wiLFxuICAxMDg6IFwiLFwiLFxuICAxMDk6IFwiLVwiLFxuICAxMTA6IFwiLlwiLFxuICAxMTE6IFwiL1wiLFxuICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAxNjA6IFwiU2hpZnRcIixcbiAgMTYxOiBcIlNoaWZ0XCIsXG4gIDE2MjogXCJDb250cm9sXCIsXG4gIDE2MzogXCJDb250cm9sXCIsXG4gIDE2NDogXCJBbHRcIixcbiAgMTY1OiBcIkFsdFwiLFxuICAxNzM6IFwiLVwiLFxuICAxODY6IFwiO1wiLFxuICAxODc6IFwiPVwiLFxuICAxODg6IFwiLFwiLFxuICAxODk6IFwiLVwiLFxuICAxOTA6IFwiLlwiLFxuICAxOTE6IFwiL1wiLFxuICAxOTI6IFwiYFwiLFxuICAyMTk6IFwiW1wiLFxuICAyMjA6IFwiXFxcXFwiLFxuICAyMjE6IFwiXVwiLFxuICAyMjI6IFwiJ1wiXG59XG5cbmV4cG9ydCB2YXIgc2hpZnQgPSB7XG4gIDQ4OiBcIilcIixcbiAgNDk6IFwiIVwiLFxuICA1MDogXCJAXCIsXG4gIDUxOiBcIiNcIixcbiAgNTI6IFwiJFwiLFxuICA1MzogXCIlXCIsXG4gIDU0OiBcIl5cIixcbiAgNTU6IFwiJlwiLFxuICA1NjogXCIqXCIsXG4gIDU3OiBcIihcIixcbiAgNTk6IFwiOlwiLFxuICA2MTogXCIrXCIsXG4gIDE3MzogXCJfXCIsXG4gIDE4NjogXCI6XCIsXG4gIDE4NzogXCIrXCIsXG4gIDE4ODogXCI8XCIsXG4gIDE4OTogXCJfXCIsXG4gIDE5MDogXCI+XCIsXG4gIDE5MTogXCI/XCIsXG4gIDE5MjogXCJ+XCIsXG4gIDIxOTogXCJ7XCIsXG4gIDIyMDogXCJ8XCIsXG4gIDIyMTogXCJ9XCIsXG4gIDIyMjogXCJcXFwiXCJcbn1cblxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIC8vIE9uIG1hY09TLCBrZXlzIGhlbGQgd2l0aCBTaGlmdCBhbmQgQ21kIGRvbid0IHJlZmxlY3QgdGhlIGVmZmVjdCBvZiBTaGlmdCBpbiBgLmtleWAuXG4gIC8vIE9uIElFLCBzaGlmdCBlZmZlY3QgaXMgbmV2ZXIgaW5jbHVkZWQgaW4gYC5rZXlgLlxuICB2YXIgaWdub3JlS2V5ID0gbWFjICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fFxuICAgICAgaWUgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMSB8fFxuICAgICAgZXZlbnQua2V5ID09IFwiVW5pZGVudGlmaWVkXCJcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiXG4gIC8vIEVkZ2Ugc29tZXRpbWVzIHByb2R1Y2VzIHdyb25nIG5hbWVzIChJc3N1ZSAjMylcbiAgaWYgKG5hbWUgPT0gXCJFc2NcIikgbmFtZSA9IFwiRXNjYXBlXCJcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiXG4gIGlmIChuYW1lID09IFwiVXBcIikgbmFtZSA9IFwiQXJyb3dVcFwiXG4gIGlmIChuYW1lID09IFwiUmlnaHRcIikgbmFtZSA9IFwiQXJyb3dSaWdodFwiXG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIlxuICByZXR1cm4gbmFtZVxufVxuIiwgImltcG9ydCB7IGtleU5hbWUsIGJhc2UgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgbGV0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyksIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAobWFjKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShtYXApIHtcbiAgICBsZXQgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgIGNvcHlbbm9ybWFsaXplS2V5TmFtZShwcm9wKV0gPSBtYXBbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0ID0gdHJ1ZSkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbi8qKlxuQ3JlYXRlIGEga2V5bWFwIHBsdWdpbiBmb3IgdGhlIGdpdmVuIHNldCBvZiBiaW5kaW5ncy5cblxuQmluZGluZ3Mgc2hvdWxkIG1hcCBrZXkgbmFtZXMgdG8gW2NvbW1hbmRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcyktc3R5bGVcbmZ1bmN0aW9ucywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBgKEVkaXRvclN0YXRlLCBkaXNwYXRjaCxcbkVkaXRvclZpZXcpYCBhcmd1bWVudHMsIGFuZCBzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGV5J3ZlIGhhbmRsZWRcbnRoZSBrZXkuIE5vdGUgdGhhdCB0aGUgdmlldyBhcmd1bWVudCBpc24ndCBwYXJ0IG9mIHRoZSBjb21tYW5kXG5wcm90b2NvbCwgYnV0IGNhbiBiZSB1c2VkIGFzIGFuIGVzY2FwZSBoYXRjaCBpZiBhIGJpbmRpbmcgbmVlZHMgdG9cbmRpcmVjdGx5IGludGVyYWN0IHdpdGggdGhlIFVJLlxuXG5LZXkgbmFtZXMgbWF5IGJlIHN0cmluZ3MgbGlrZSBgXCJTaGlmdC1DdHJsLUVudGVyXCJgXHUyMDE0YSBrZXlcbmlkZW50aWZpZXIgcHJlZml4ZWQgd2l0aCB6ZXJvIG9yIG1vcmUgbW9kaWZpZXJzLiBLZXkgaWRlbnRpZmllcnNcbmFyZSBiYXNlZCBvbiB0aGUgc3RyaW5ncyB0aGF0IGNhbiBhcHBlYXIgaW5cbltgS2V5RXZlbnQua2V5YF0oaHR0cHM6ZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleSkuXG5Vc2UgbG93ZXJjYXNlIGxldHRlcnMgdG8gcmVmZXIgdG8gbGV0dGVyIGtleXMgKG9yIHVwcGVyY2FzZSBsZXR0ZXJzXG5pZiB5b3Ugd2FudCBzaGlmdCB0byBiZSBoZWxkKS4gWW91IG1heSB1c2UgYFwiU3BhY2VcImAgYXMgYW4gYWxpYXNcbmZvciB0aGUgYFwiIFwiYCBuYW1lLlxuXG5Nb2RpZmllcnMgY2FuIGJlIGdpdmVuIGluIGFueSBvcmRlci4gYFNoaWZ0LWAgKG9yIGBzLWApLCBgQWx0LWAgKG9yXG5gYS1gKSwgYEN0cmwtYCAob3IgYGMtYCBvciBgQ29udHJvbC1gKSBhbmQgYENtZC1gIChvciBgbS1gIG9yXG5gTWV0YS1gKSBhcmUgcmVjb2duaXplZC4gRm9yIGNoYXJhY3RlcnMgdGhhdCBhcmUgY3JlYXRlZCBieSBob2xkaW5nXG5zaGlmdCwgdGhlIGBTaGlmdC1gIHByZWZpeCBpcyBpbXBsaWVkLCBhbmQgc2hvdWxkIG5vdCBiZSBhZGRlZFxuZXhwbGljaXRseS5cblxuWW91IGNhbiB1c2UgYE1vZC1gIGFzIGEgc2hvcnRoYW5kIGZvciBgQ21kLWAgb24gTWFjIGFuZCBgQ3RybC1gIG9uXG5vdGhlciBwbGF0Zm9ybXMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcCBwbHVnaW5zIHRvIGFuIGVkaXRvci4gVGhlIG9yZGVyIGluXG53aGljaCB0aGV5IGFwcGVhciBkZXRlcm1pbmVzIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIGVhcmx5IGluXG50aGUgYXJyYXkgZ2V0IHRvIGRpc3BhdGNoIGZpcnN0KS5cbiovXG5mdW5jdGlvbiBrZXltYXAoYmluZGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7IHByb3BzOiB7IGhhbmRsZUtleURvd246IGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB9IH0pO1xufVxuLyoqXG5HaXZlbiBhIHNldCBvZiBiaW5kaW5ncyAodXNpbmcgdGhlIHNhbWUgZm9ybWF0IGFzXG5bYGtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNrZXltYXAua2V5bWFwKSksIHJldHVybiBhIFtrZXlkb3duXG5oYW5kbGVyXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVLZXlEb3duKSB0aGF0IGhhbmRsZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykge1xuICAgIGxldCBtYXAgPSBub3JtYWxpemUoYmluZGluZ3MpO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmlldywgZXZlbnQpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KSwgYmFzZU5hbWUsIGRpcmVjdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQpXTtcbiAgICAgICAgaWYgKGRpcmVjdCAmJiBkaXJlY3Qodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQSBjaGFyYWN0ZXIga2V5XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAxICYmIG5hbWUgIT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG5hbWUgd2FzIGFscmVhZHkgbW9kaWZpZWQgYnkgc2hpZnQsIHRyeSBsb29raW5nXG4gICAgICAgICAgICAgICAgLy8gaXQgdXAgd2l0aG91dCBpdHMgc2hpZnQgbW9kaWZpZXJcbiAgICAgICAgICAgICAgICBsZXQgbm9TaGlmdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsIGZhbHNlKV07XG4gICAgICAgICAgICAgICAgaWYgKG5vU2hpZnQgJiYgbm9TaGlmdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IG5hbWUuY2hhckNvZGVBdCgwKSA+IDEyNykgJiZcbiAgICAgICAgICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGZhbGxpbmcgYmFjayB0byB0aGUga2V5Q29kZSB3aGVuIHRoZXJlJ3MgYSBtb2RpZmllclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2ZSBvciB0aGUgY2hhcmFjdGVyIHByb2R1Y2VkIGlzbid0IEFTQ0lJLCBhbmQgb3VyIHRhYmxlXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjZXMgYSBkaWZmZXJlbnQgbmFtZSBmcm9tIHRoZSB0aGUga2V5Q29kZS4gU2VlICM2NjgsXG4gICAgICAgICAgICAgICAgLy8gIzEwNjBcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUNvZGUgPSBtYXBbbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCldO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQ29kZSAmJiBmcm9tQ29kZSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGtleWRvd25IYW5kbGVyLCBrZXltYXAgfTtcbiIsICJpbXBvcnQgeyBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCwgUmVwbGFjZVN0ZXAsIGNhbkpvaW4sIGpvaW5Qb2ludCwgY2FuU3BsaXQsIFJlcGxhY2VBcm91bmRTdGVwLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiovXG5jb25zdCBkZWxldGVTZWxlY3Rpb24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgdHJ5IHRvXG5yZWR1Y2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBiZWZvcmUgaXRcdTIwMTRpZlxudGhlcmUncyBhIGJsb2NrIGRpcmVjdGx5IGJlZm9yZSBpdCB0aGF0IGNhbiBiZSBqb2luZWQsIGpvaW4gdGhlbS5cbklmIG5vdCwgdHJ5IHRvIG1vdmUgdGhlIHNlbGVjdGVkIGJsb2NrIGNsb3NlciB0byB0aGUgbmV4dCBvbmUgaW5cbnRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYnkgbGlmdGluZyBpdCBvdXQgb2YgaXRzIHBhcmVudCBvciBtb3ZpbmcgaXRcbmludG8gYSBwYXJlbnQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBXaWxsIHVzZSB0aGUgdmlldyBmb3IgYWNjdXJhdGVcbihiaWRpLWF3YXJlKSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5CYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gICAgaWYgKCEkY3V0KSB7XG4gICAgICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZTtcbiAgICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoIWJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGJlbG93IGFuZCBzZWxlY3QgdGhlIG9uZSBhYm92ZS5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zLCAtMSkpLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBiZWZvcmUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luQmFja3dhcmRgXSgkY29tbWFuZHMuam9pbkJhY2t3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYmVmb3JlXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkZvcndhcmRgXSgkY29tbWFuZHMuam9pbkZvcndhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlclxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGJlZm9yZVRleHQgPSBiZWZvcmUsIGJlZm9yZVBvcyA9ICRjdXQucG9zIC0gMTtcbiAgICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgICAgIGlmIChiZWZvcmVUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyUG9zKyspIHtcbiAgICAgICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBhZnRlclRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWZ0ZXJUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBTbGljZS5lbXB0eSk7XG4gICAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHxcbiAgICAgICAgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBiZWZvcmVQb3MpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSAoc2lkZSA9PSBcInN0YXJ0XCIgPyBzY2FuLmZpcnN0Q2hpbGQgOiBzY2FuLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9ubHkgJiYgc2Nhbi5jaGlsZENvdW50ICE9IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgYmVmb3JlIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuYm91bmQgdG8ga2V5cyBsaWtlIGJhY2tzcGFjZSwgYWZ0ZXJcbltgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZCkgb3Igb3RoZXIgZGVsZXRpbmdcbmNvbW1hbmRzLCBhcyBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndCBhbGxvd1xuZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEJlZm9yZSgkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5iZWZvcmUoaSArIDEpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXRCbG9ja0VuZChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGFcbnRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSBvciByZW1vdmUgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdGhhdCBibG9ja1xuYW5kIHRoZSBvbmUgYWZ0ZXIgaXQsIGVpdGhlciBieSBqb2luaW5nIHRoZW0gb3IgYnkgbW92aW5nIHRoZSBvdGhlclxuYmxvY2sgY2xvc2VyIHRvIHRoaXMgb25lIGluIHRoZSB0cmVlIHN0cnVjdHVyZS4gV2lsbCB1c2UgdGhlIHZpZXdcbmZvciBhY2N1cmF0ZSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5Gb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBhZnRlciB0aGlzLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoISRjdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlcjtcbiAgICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYWJvdmUgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGJlbG93IGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGFib3ZlIGFuZCBzZWxlY3QgdGhlIG9uZSBiZWxvdy5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpLCAxKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbnRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG5bYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3RcbmFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpICsgMSA8IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYWZ0ZXIoaSArIDEpKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG5jbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG50aGUgc2libGluZyBhYm92ZSBpdC5cbiovXG5jb25zdCBqb2luVXAgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChub2RlU2VsKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLmZyb20sIC0xKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICAgICAgaWYgKG5vZGVTZWwpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgc2VsZWN0aW9uXG50aGF0IGNhbiBiZSBqb2luZWQsIHdpdGggdGhlIHNpYmxpbmcgYWZ0ZXIgaXQuXG4qL1xuY29uc3Qgam9pbkRvd24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwudG87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4ocG9pbnQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTGlmdCB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZVxuc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGxpZnRlZCwgb3V0IG9mIGl0cyBwYXJlbnQgbm9kZS5cbiovXG5jb25zdCBsaWZ0ID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdob3NlIHR5cGUgaGFzIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIHJlcGxhY2UgdGhlXG5zZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgY2hhcmFjdGVyLlxuKi9cbmNvbnN0IG5ld2xpbmVJbkNvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dChcIlxcblwiKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdpdGggYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgY3JlYXRlIGFcbmRlZmF1bHQgYmxvY2sgYWZ0ZXIgdGhlIGNvZGUgYmxvY2ssIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdGhlcmUuXG4qL1xuY29uc3QgZXhpdENvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgICBpZiAoIXR5cGUgfHwgIWFib3ZlLmNhblJlcGxhY2VXaXRoKGFmdGVyLCBhZnRlciwgdHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHBvcyA9ICRoZWFkLmFmdGVyKCksIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgYSBibG9jayBub2RlIGlzIHNlbGVjdGVkLCBjcmVhdGUgYW4gZW1wdHkgcGFyYWdyYXBoIGJlZm9yZSAoaWZcbml0IGlzIGl0cyBwYXJlbnQncyBmaXJzdCBjaGlsZCkgb3IgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uIHx8ICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8ICR0by5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoJHRvLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkdG8uaW5kZXhBZnRlcigpKSk7XG4gICAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5pbnNlcnQoc2lkZSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgY3Vyc29yIGlzIGluIGFuIGVtcHR5IHRleHRibG9jayB0aGF0IGNhbiBiZSBsaWZ0ZWQsIGxpZnQgdGhlXG5ibG9jay5cbiovXG5jb25zdCBsaWZ0RW1wdHlCbG9jayA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSAkY3Vyc29yLmJlZm9yZSgpO1xuICAgICAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DcmVhdGUgYSB2YXJpYW50IG9mIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSB0aGF0IHVzZXNcbmEgY3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgbmV3bHkgc3BsaXQgb2ZmIGJsb2NrLlxuKi9cbmZ1bmN0aW9uIHNwbGl0QmxvY2tBcyhzcGxpdE5vZGUpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT0gJHRvLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICRmcm9tLmRlcHRoID09IDAgPyBudWxsIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICAgICAgICAgIGxldCBzcGxpdFR5cGUgPSBzcGxpdE5vZGUgJiYgc3BsaXROb2RlKCR0by5wYXJlbnQsIGF0RW5kKTtcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHNwbGl0VHlwZSA/IFtzcGxpdFR5cGVdIDogYXRFbmQgJiYgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgIGlmICghdHlwZXMgJiYgIWNhbiAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0KVxuICAgICAgICAgICAgICAgICAgICB0eXBlcyA9IFt7IHR5cGU6IGRlZmx0IH1dO1xuICAgICAgICAgICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIGlmICghYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmICRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuU3BsaXQgdGhlIHBhcmVudCBibG9jayBvZiB0aGUgc2VsZWN0aW9uLiBJZiB0aGUgc2VsZWN0aW9uIGlzIGEgdGV4dFxuc2VsZWN0aW9uLCBhbHNvIGRlbGV0ZSBpdHMgY29udGVudC5cbiovXG5jb25zdCBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jayksIGJ1dCB3aXRob3V0XG5yZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5jb25zdCBzcGxpdEJsb2NrS2VlcE1hcmtzID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiAodHIgPT4ge1xuICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9KSk7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5vZGUgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBpZlxuYW55LiAoV2lsbCBub3Qgc2VsZWN0IHRoZSBkb2N1bWVudCBub2RlLilcbiovXG5jb25zdCBzZWxlY3RQYXJlbnROb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLCBwb3M7XG4gICAgbGV0IHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgaWYgKHNhbWUgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24oc3RhdGUuZG9jKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkcG9zLCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50clxuICAgICAgICAgICAgLmNsZWFySW5jb21wYXRpYmxlKCRwb3MucG9zLCBiZWZvcmUudHlwZSwgYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSlcbiAgICAgICAgICAgIC5qb2luKCRwb3MucG9zKVxuICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgICBpZiAoYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChqb2luTWF5YmVDbGVhcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgY2FuRGVsQWZ0ZXIgPSAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAgIChjb25uID0gKG1hdGNoID0gYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuZmluZFdyYXBwaW5nKGFmdGVyLnR5cGUpKSAmJlxuICAgICAgICBtYXRjaC5tYXRjaFR5cGUoY29ublswXSB8fCBhZnRlci50eXBlKS52YWxpZEVuZCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29ubi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShjb25uW2ldLmNyZWF0ZShudWxsLCB3cmFwKSk7XG4gICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgICAgICAgbGV0IGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbkF0KSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5BdCk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNlbEFmdGVyID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICAgIGxldCByYW5nZSA9IHNlbEFmdGVyICYmIHNlbEFmdGVyLiRmcm9tLmJsb2NrUmFuZ2Uoc2VsQWZ0ZXIuJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldCA+PSAkY3V0LmRlcHRoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgICAgICBsZXQgYXQgPSBiZWZvcmUsIHdyYXAgPSBbXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgd3JhcC5wdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdC5pc1RleHRibG9jaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJEZXB0aCA9IDE7XG4gICAgICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIGFmdGVyRGVwdGgrKztcbiAgICAgICAgaWYgKGF0LmNhblJlcGxhY2UoYXQuY2hpbGRDb3VudCwgYXQuY2hpbGRDb3VudCwgYWZ0ZXJUZXh0LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IEZyYWdtZW50LmZyb20od3JhcFtpXS5jb3B5KGVuZCkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gd3JhcC5sZW5ndGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsICRjdXQucG9zICsgYWZ0ZXJEZXB0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSAtIGFmdGVyRGVwdGgsIG5ldyBTbGljZShlbmQsIHdyYXAubGVuZ3RoLCAwKSwgMCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGV4dGJsb2NrU2lkZShzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICAgICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aDtcbiAgICAgICAgd2hpbGUgKCRwb3Mubm9kZShkZXB0aCkuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHNpZGUgPCAwID8gJHBvcy5zdGFydChkZXB0aCkgOiAkcG9zLmVuZChkZXB0aCkpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG4vKipcbldyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZ2l2ZW5cbmF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgIGlmICghd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCB0cmllcyB0byBzZXQgdGhlIHNlbGVjdGVkIHRleHRibG9ja3MgdG8gdGhlXG5naXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwbGljYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IGNhbiA9ICRmcm9tLmRlcHRoID09IDAgPyBkb2MuaW5saW5lQ29udGVudCAmJiBkb2MudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKSA6IGZhbHNlO1xuICAgICAgICBkb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhbiA9IG5vZGUuaW5saW5lQ29udGVudCAmJiBub2RlLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHRvZ2dsZXMgdGhlIGdpdmVuIG1hcmsgd2l0aCB0aGVcbmdpdmVuIGF0dHJpYnV0ZXMuIFdpbGwgcmV0dXJuIGBmYWxzZWAgd2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbmRvZXNuJ3Qgc3VwcG9ydCB0aGF0IG1hcmsuIFRoaXMgd2lsbCByZW1vdmUgdGhlIG1hcmsgaWYgYW55IG1hcmtzXG5vZiB0aGF0IHR5cGUgZXhpc3QgaW4gdGhlIHNlbGVjdGlvbiwgb3IgYWRkIGl0IG90aGVyd2lzZS4gSWYgdGhlXG5zZWxlY3Rpb24gaXMgZW1wdHksIHRoaXMgYXBwbGllcyB0byB0aGUgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykgaW5zdGVhZCBvZiBhIHJhbmdlIG9mIHRoZVxuZG9jdW1lbnQuXG4qL1xuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgZW1wdHksICRjdXJzb3IsIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKGVtcHR5ICYmICEkY3Vyc29yKSB8fCAhbWFya0FwcGxpZXMoc3RhdGUuZG9jLCByYW5nZXMsIG1hcmtUeXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhcyA9IGZhbHNlLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyAhaGFzICYmIGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBoYXMgPSBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9ICRmcm9tLnBvcywgdG8gPSAkdG8ucG9zLCBzdGFydCA9ICRmcm9tLm5vZGVBZnRlciwgZW5kID0gJHRvLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gc3BhY2VTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gICAgcmV0dXJuICh0cikgPT4ge1xuICAgICAgICBpZiAoIXRyLmlzR2VuZXJpYylcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh0cik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7XG4gICAgICAgICAgICBtYXAuZm9yRWFjaCgoX3MsIF9lLCBmcm9tLCB0bykgPT4gcmFuZ2VzLnB1c2goZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGpvaW5hYmxlIHBvaW50cyBleGlzdCBpbnNpZGUgdGhvc2UgcmFuZ2VzLFxuICAgICAgICAvLyBieSBjaGVja2luZyBhbGwgbm9kZSBib3VuZGFyaWVzIGluIHRoZWlyIHBhcmVudCBub2Rlcy5cbiAgICAgICAgbGV0IGpvaW5hYmxlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpXSwgdG8gPSByYW5nZXNbaSArIDFdO1xuICAgICAgICAgICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5hYmxlLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGFmdGVyLm5vZGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gdGhlIGpvaW5hYmxlIHBvaW50c1xuICAgICAgICBqb2luYWJsZS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAobGV0IGkgPSBqb2luYWJsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpXSkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luYWJsZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH07XG59XG4vKipcbldyYXAgYSBjb21tYW5kIHNvIHRoYXQsIHdoZW4gaXQgcHJvZHVjZXMgYSB0cmFuc2Zvcm0gdGhhdCBjYXVzZXNcbnR3byBqb2luYWJsZSBub2RlcyB0byBlbmQgdXAgbmV4dCB0byBlYWNoIG90aGVyLCB0aG9zZSBhcmUgam9pbmVkLlxuTm9kZXMgYXJlIGNvbnNpZGVyZWQgam9pbmFibGUgd2hlbiB0aGV5IGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZFxud2hlbiB0aGUgYGlzSm9pbmFibGVgIHByZWRpY2F0ZSByZXR1cm5zIHRydWUgZm9yIHRoZW0gb3IsIGlmIGFuXG5hcnJheSBvZiBzdHJpbmdzIHdhcyBwYXNzZWQsIGlmIHRoZWlyIG5vZGUgdHlwZSBuYW1lIGlzIGluIHRoYXRcbmFycmF5LlxuKi9cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgICBsZXQgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyAobm9kZSkgPT4gaXNKb2luYWJsZS5pbmRleE9mKG5vZGUudHlwZS5uYW1lKSA+IC0xXG4gICAgICAgIDogaXNKb2luYWJsZTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgY2FuSm9pbiksIHZpZXcpO1xufVxuLyoqXG5Db21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG5jYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG4qL1xuZnVuY3Rpb24gY2hhaW5Db21tYW5kcyguLi5jb21tYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5sZXQgYmFja3NwYWNlID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5CYWNrd2FyZCwgc2VsZWN0Tm9kZUJhY2t3YXJkKTtcbmxldCBkZWwgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkZvcndhcmQsIHNlbGVjdE5vZGVGb3J3YXJkKTtcbi8qKlxuQSBiYXNpYyBrZXltYXAgY29udGFpbmluZyBiaW5kaW5ncyBub3Qgc3BlY2lmaWMgdG8gYW55IHNjaGVtYS5cbkJpbmRzIHRoZSBmb2xsb3dpbmcga2V5cyAod2hlbiBtdWx0aXBsZSBjb21tYW5kcyBhcmUgbGlzdGVkLCB0aGV5XG5hcmUgY2hhaW5lZCB3aXRoIFtgY2hhaW5Db21tYW5kc2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5jaGFpbkNvbW1hbmRzKSk6XG5cbiogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2BcbiogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4qICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbiogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG4qL1xuY29uc3QgcGNCYXNlS2V5bWFwID0ge1xuICAgIFwiRW50ZXJcIjogY2hhaW5Db21tYW5kcyhuZXdsaW5lSW5Db2RlLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBsaWZ0RW1wdHlCbG9jaywgc3BsaXRCbG9jayksXG4gICAgXCJNb2QtRW50ZXJcIjogZXhpdENvZGUsXG4gICAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJTaGlmdC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1EZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLWFcIjogc2VsZWN0QWxsXG59O1xuLyoqXG5BIGNvcHkgb2YgYHBjQmFzZUtleW1hcGAgdGhhdCBhbHNvIGJpbmRzICoqQ3RybC1oKiogbGlrZSBCYWNrc3BhY2UsXG4qKkN0cmwtZCoqIGxpa2UgRGVsZXRlLCAqKkFsdC1CYWNrc3BhY2UqKiBsaWtlIEN0cmwtQmFja3NwYWNlLCBhbmRcbioqQ3RybC1BbHQtQmFja3NwYWNlKiosICoqQWx0LURlbGV0ZSoqLCBhbmQgKipBbHQtZCoqIGxpa2VcbkN0cmwtRGVsZXRlLlxuKi9cbmNvbnN0IG1hY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICAgIFwiQ3RybC1kXCI6IHBjQmFzZUtleW1hcFtcIkRlbGV0ZVwiXSxcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LWRcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgICBcIkN0cmwtZVwiOiBzZWxlY3RUZXh0YmxvY2tFbmRcbn07XG5mb3IgKGxldCBrZXkgaW4gcGNCYXNlS2V5bWFwKVxuICAgIG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldO1xuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbi8qKlxuRGVwZW5kaW5nIG9uIHRoZSBkZXRlY3RlZCBwbGF0Zm9ybSwgdGhpcyB3aWxsIGhvbGRcbltgcGNCYXNla2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnBjQmFzZUtleW1hcCkgb3JcbltgbWFjQmFzZUtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5tYWNCYXNlS2V5bWFwKS5cbiovXG5jb25zdCBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcblxuZXhwb3J0IHsgYXV0b0pvaW4sIGJhc2VLZXltYXAsIGNoYWluQ29tbWFuZHMsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGRlbGV0ZVNlbGVjdGlvbiwgZXhpdENvZGUsIGpvaW5CYWNrd2FyZCwgam9pbkRvd24sIGpvaW5Gb3J3YXJkLCBqb2luVGV4dGJsb2NrQmFja3dhcmQsIGpvaW5UZXh0YmxvY2tGb3J3YXJkLCBqb2luVXAsIGxpZnQsIGxpZnRFbXB0eUJsb2NrLCBtYWNCYXNlS2V5bWFwLCBuZXdsaW5lSW5Db2RlLCBwY0Jhc2VLZXltYXAsIHNlbGVjdEFsbCwgc2VsZWN0Tm9kZUJhY2t3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCwgc2VsZWN0UGFyZW50Tm9kZSwgc2VsZWN0VGV4dGJsb2NrRW5kLCBzZWxlY3RUZXh0YmxvY2tTdGFydCwgc2V0QmxvY2tUeXBlLCBzcGxpdEJsb2NrLCBzcGxpdEJsb2NrQXMsIHNwbGl0QmxvY2tLZWVwTWFya3MsIHRvZ2dsZU1hcmssIHdyYXBJbiB9O1xuIiwgImltcG9ydCB7IGZpbmRXcmFwcGluZywgUmVwbGFjZUFyb3VuZFN0ZXAsIGNhblNwbGl0LCBsaWZ0VGFyZ2V0LCBjYW5Kb2luIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IE5vZGVSYW5nZSwgRnJhZ21lbnQsIFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5jb25zdCBvbERPTSA9IFtcIm9sXCIsIDBdLCB1bERPTSA9IFtcInVsXCIsIDBdLCBsaURPTSA9IFtcImxpXCIsIDBdO1xuLyoqXG5BbiBvcmRlcmVkIGxpc3QgW25vZGUgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjKS4gSGFzIGEgc2luZ2xlXG5hdHRyaWJ1dGUsIGBvcmRlcmAsIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBhdCB3aGljaCB0aGUgbGlzdFxuc3RhcnRzIGNvdW50aW5nLCBhbmQgZGVmYXVsdHMgdG8gMS4gUmVwcmVzZW50ZWQgYXMgYW4gYDxvbD5gXG5lbGVtZW50LlxuKi9cbmNvbnN0IG9yZGVyZWRMaXN0ID0ge1xuICAgIGF0dHJzOiB7IG9yZGVyOiB7IGRlZmF1bHQ6IDEgfSB9LFxuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwib2xcIiwgZ2V0QXR0cnMoZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxIH07XG4gICAgICAgICAgICB9IH1dLFxuICAgIHRvRE9NKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwgeyBzdGFydDogbm9kZS5hdHRycy5vcmRlciB9LCAwXTtcbiAgICB9XG59O1xuLyoqXG5BIGJ1bGxldCBsaXN0IG5vZGUgc3BlYywgcmVwcmVzZW50ZWQgaW4gdGhlIERPTSBhcyBgPHVsPmAuXG4qL1xuY29uc3QgYnVsbGV0TGlzdCA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcInVsXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiB1bERPTTsgfVxufTtcbi8qKlxuQSBsaXN0IGl0ZW0gKGA8bGk+YCkgc3BlYy5cbiovXG5jb25zdCBsaXN0SXRlbSA9IHtcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcImxpXCIgfV0sXG4gICAgdG9ET00oKSB7IHJldHVybiBsaURPTTsgfSxcbiAgICBkZWZpbmluZzogdHJ1ZVxufTtcbmZ1bmN0aW9uIGFkZChvYmosIHByb3BzKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKVxuICAgICAgICBjb3B5W3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vKipcbkNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhZGRpbmcgbGlzdC1yZWxhdGVkIG5vZGUgdHlwZXMgdG8gYSBtYXBcbnNwZWNpZnlpbmcgdGhlIG5vZGVzIGZvciBhIHNjaGVtYS4gQWRkc1xuW2BvcmRlcmVkTGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5vcmRlcmVkTGlzdCkgYXMgYFwib3JkZXJlZF9saXN0XCJgLFxuW2BidWxsZXRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0LmJ1bGxldExpc3QpIGFzIGBcImJ1bGxldF9saXN0XCJgLCBhbmRcbltgbGlzdEl0ZW1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QubGlzdEl0ZW0pIGFzIGBcImxpc3RfaXRlbVwiYC5cblxuYGl0ZW1Db250ZW50YCBkZXRlcm1pbmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoZSBsaXN0IGl0ZW1zLlxuSWYgeW91IHdhbnQgdGhlIGNvbW1hbmRzIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUgdG8gYXBwbHkgdG8geW91clxubGlzdCBzdHJ1Y3R1cmUsIGl0IHNob3VsZCBoYXZlIGEgc2hhcGUgbGlrZSBgXCJwYXJhZ3JhcGggYmxvY2sqXCJgIG9yXG5gXCJwYXJhZ3JhcGggKG9yZGVyZWRfbGlzdCB8IGJ1bGxldF9saXN0KSpcImAuIGBsaXN0R3JvdXBgIGNhbiBiZVxuZ2l2ZW4gdG8gYXNzaWduIGEgZ3JvdXAgbmFtZSB0byB0aGUgbGlzdCBub2RlIHR5cGVzLCBmb3IgZXhhbXBsZVxuYFwiYmxvY2tcImAuXG4qL1xuZnVuY3Rpb24gYWRkTGlzdE5vZGVzKG5vZGVzLCBpdGVtQ29udGVudCwgbGlzdEdyb3VwKSB7XG4gICAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgICAgIG9yZGVyZWRfbGlzdDogYWRkKG9yZGVyZWRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBidWxsZXRfbGlzdDogYWRkKGJ1bGxldExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGxpc3RfaXRlbTogYWRkKGxpc3RJdGVtLCB7IGNvbnRlbnQ6IGl0ZW1Db250ZW50IH0pXG4gICAgfSk7XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIHNlbGVjdGlvbiBpbiBhIGxpc3Qgd2l0aFxudGhlIGdpdmVuIHR5cGUgYW4gYXR0cmlidXRlcy4gSWYgYGRpc3BhdGNoYCBpcyBudWxsLCBvbmx5IHJldHVybiBhXG52YWx1ZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgaXMgcG9zc2libGUsIGJ1dCBkb24ndCBhY3R1YWxseVxucGVyZm9ybSB0aGUgY2hhbmdlLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCBkb0pvaW4gPSBmYWxzZSwgb3V0ZXJSYW5nZSA9IHJhbmdlO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGlzIGF0IHRoZSB0b3Agb2YgYW4gZXhpc3RpbmcgbGlzdCBpdGVtXG4gICAgICAgIGlmIChyYW5nZS5kZXB0aCA+PSAyICYmICRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlLmNvbXBhdGlibGVDb250ZW50KGxpc3RUeXBlKSAmJiByYW5nZS5zdGFydEluZGV4ID09IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgaWYgKCRmcm9tLmluZGV4KHJhbmdlLmRlcHRoIC0gMSkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJGluc2VydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgICAgICBvdXRlclJhbmdlID0gbmV3IE5vZGVSYW5nZSgkaW5zZXJ0LCAkaW5zZXJ0LCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGZyb20sIHN0YXRlLmRvYy5yZXNvbHZlKCR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgZG9Kb2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd3JhcCA9IGZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChkb1dyYXBJbkxpc3Qoc3RhdGUudHIsIHJhbmdlLCB3cmFwLCBkb0pvaW4sIGxpc3RUeXBlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0VHlwZSkge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbiAgICBsZXQgZm91bmQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcHBlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh3cmFwcGVyc1tpXS50eXBlID09IGxpc3RUeXBlKVxuICAgICAgICAgICAgZm91bmQgPSBpICsgMTtcbiAgICBsZXQgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICAgIGxldCBzcGxpdFBvcyA9IHJhbmdlLnN0YXJ0ICsgd3JhcHBlcnMubGVuZ3RoIC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IGkgPCBlOyBpKyssIGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmaXJzdCAmJiBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXRQb3MgKz0gcGFyZW50LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG4vKipcbkJ1aWxkIGEgY29tbWFuZCB0aGF0IHNwbGl0cyBhIG5vbi1lbXB0eSB0ZXh0YmxvY2sgYXQgdGhlIHRvcCBsZXZlbFxub2YgYSBsaXN0IGl0ZW0gYnkgYWxzbyBzcGxpdHRpbmcgdGhhdCBsaXN0IGl0ZW0uXG4qL1xuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSwgaXRlbUF0dHJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0bywgbm9kZSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAgICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgICAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgICAgICAgICBpZiAoJGZyb20uZGVwdGggPT0gMyB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9IGl0ZW1UeXBlIHx8XG4gICAgICAgICAgICAgICAgJGZyb20uaW5kZXgoLTIpICE9ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pXG4gICAgICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxXG4gICAgICAgICAgICAgICAgICAgIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gLTE7XG4gICAgICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmIG5vZGUuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0VHlwZSA9ICR0by5wb3MgPT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgICAgICBsZXQgdHlwZXMgPSBuZXh0VHlwZSA/IFtpdGVtQXR0cnMgPyB7IHR5cGU6IGl0ZW1UeXBlLCBhdHRyczogaXRlbUF0dHJzIH0gOiBudWxsLCB7IHR5cGU6IG5leHRUeXBlIH1dIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyLCB0eXBlcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdExpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0LnNwbGl0TGlzdEl0ZW0pLCBidXRcbndpdGhvdXQgcmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbUtlZXBNYXJrcyhpdGVtVHlwZSwgaXRlbUF0dHJzKSB7XG4gICAgbGV0IHNwbGl0ID0gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSwgaXRlbUF0dHJzKTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gc3BsaXQoc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgYWZ0ZXIgPSB0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDE7XG4gICAgaWYgKGNhbkpvaW4odHIuZG9jLCBhZnRlcikpXG4gICAgICAgIHRyLmpvaW4oYWZ0ZXIpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW1LZWVwTWFya3MsIHdyYXBJbkxpc3QgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG4vKipcbiAqIFRha2VzIGEgVHJhbnNhY3Rpb24gJiBFZGl0b3IgU3RhdGUgYW5kIHR1cm5zIGl0IGludG8gYSBjaGFpbmFibGUgc3RhdGUgb2JqZWN0XG4gKiBAcGFyYW0gY29uZmlnIFRoZSB0cmFuc2FjdGlvbiBhbmQgc3RhdGUgdG8gY3JlYXRlIHRoZSBjaGFpbmFibGUgc3RhdGUgZnJvbVxuICogQHJldHVybnMgQSBjaGFpbmFibGUgRWRpdG9yIHN0YXRlIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnOiB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbn0pOiBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWdcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvblxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcbiAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xuICAgICAgcmV0dXJuIHN0b3JlZE1hcmtzXG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgIH0sXG4gICAgZ2V0IGRvYygpIHtcbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuICAgIGdldCB0cigpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvblxuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzXG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29tbWFuZHMsIENhbkNvbW1hbmRzLCBDaGFpbmVkQ29tbWFuZHMsIENvbW1hbmRQcm9wcywgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgcmF3Q29tbWFuZHM6IEFueUNvbW1hbmRzXG5cbiAgY3VzdG9tU3RhdGU/OiBFZGl0b3JTdGF0ZVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBzdGF0ZT86IEVkaXRvclN0YXRlIH0pIHtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvclxuICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzXG4gICAgdGhpcy5jdXN0b21TdGF0ZSA9IHByb3BzLnN0YXRlXG4gIH1cblxuICBnZXQgaGFzQ3VzdG9tU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZVxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IEVkaXRvclN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFNpbmdsZUNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYWxsYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgfVxuXG4gIGdldCBjaGFpbigpOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKClcbiAgfVxuXG4gIGdldCBjYW4oKTogKCkgPT4gQ2FuQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNhbigpXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2hhaW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuICAgIGNvbnN0IGNhbGxiYWNrczogYm9vbGVhbltdID0gW11cbiAgICBjb25zdCBoYXNTdGFydFRyYW5zYWN0aW9uID0gISFzdGFydFRyXG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyXG5cbiAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICYmIHNob3VsZERpc3BhdGNoXG4gICAgICAgICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKVxuICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFja3MuZXZlcnkoY2FsbGJhY2sgPT4gY2FsbGJhY2sgPT09IHRydWUpXG4gICAgfVxuXG4gICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3M6IG5ldmVyW10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaClcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcylcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG5cbiAgICAgICAgICAgIHJldHVybiBjaGFpblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHJ1bixcbiAgICB9IGFzIHVua25vd24gYXMgQ2hhaW5lZENvbW1hbmRzXG5cbiAgICByZXR1cm4gY2hhaW5cbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVDYW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uKTogQ2FuQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZVxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaClcbiAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHsgLi4ucHJvcHMsIGRpc3BhdGNoOiB1bmRlZmluZWQgfSldXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXR0ZWRDb21tYW5kcyxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaCksXG4gICAgfSBhcyBDYW5Db21tYW5kc1xuICB9XG5cbiAgcHVibGljIGJ1aWxkUHJvcHModHI6IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDb21tYW5kUHJvcHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gICAgY29uc3QgcHJvcHM6IENvbW1hbmRQcm9wcyA9IHtcbiAgICAgIHRyLFxuICAgICAgZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICB9KSxcbiAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3M6IG5ldmVyW10pID0+IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXVxuICAgICAgICAgIH0pLFxuICAgICAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cbn1cbiIsICJ0eXBlIFN0cmluZ0tleU9mPFQ+ID0gRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XG50eXBlIENhbGxiYWNrVHlwZTxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9IFRbRXZlbnROYW1lXSBleHRlbmRzIGFueVtdID8gVFtFdmVudE5hbWVdIDogW1RbRXZlbnROYW1lXV1cbnR5cGUgQ2FsbGJhY2tGdW5jdGlvbjxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9ICguLi5wcm9wczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pID0+IGFueVxuXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG5cbiAgcHJpdmF0ZSBjYWxsYmFja3M6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge31cblxuICBwdWJsaWMgb248RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuOiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbilcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgZW1pdDxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgLi4uYXJnczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgb2ZmPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbj86IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge31cbiAgfVxufVxuIiwgImltcG9ydCB7IEFueUV4dGVuc2lvbiwgTWF5YmVUaGlzUGFyYW1ldGVyVHlwZSwgUmVtb3ZlVGhpcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG4vKipcbiAqIFJldHVybnMgYSBmaWVsZCBmcm9tIGFuIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBUaGUgVGlwdGFwIGV4dGVuc2lvblxuICogQHBhcmFtIGZpZWxkIFRoZSBmaWVsZCwgZm9yIGV4YW1wbGUgYHJlbmRlckhUTUxgIG9yIGBwcmlvcml0eWBcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgYXMgYHRoaXNgIGludG8gdGhlIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBUaGUgZmllbGQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkPFQgPSBhbnk+KFxuICBleHRlbnNpb246IEFueUV4dGVuc2lvbixcbiAgZmllbGQ6IHN0cmluZyxcbiAgY29udGV4dD86IE9taXQ8TWF5YmVUaGlzUGFyYW1ldGVyVHlwZTxUPiwgJ3BhcmVudCc+LFxuKTogUmVtb3ZlVGhpczxUPiB7XG5cbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB1bmRlZmluZWQgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudFxuICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICA6IG51bGwsXG4gICAgfSlcblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgTWFyayB9IGZyb20gJy4uL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJykgYXMgRXh0ZW5zaW9uW11cbiAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJykgYXMgTm9kZVtdXG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIGFzIE1hcmtbXVxuXG4gIHJldHVybiB7XG4gICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgbm9kZUV4dGVuc2lvbnMsXG4gICAgbWFya0V4dGVuc2lvbnMsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9uQXR0cmlidXRlLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxufSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdIHtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10gPSBbXVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IG5vZGVBbmRNYXJrRXh0ZW5zaW9ucyA9IFsuLi5ub2RlRXh0ZW5zaW9ucywgLi4ubWFya0V4dGVuc2lvbnNdXG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGU6IFJlcXVpcmVkPEF0dHJpYnV0ZT4gPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICByZW5kZXJlZDogdHJ1ZSxcbiAgICByZW5kZXJIVE1MOiBudWxsLFxuICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgICBpc1JlcXVpcmVkOiBmYWxzZSxcbiAgfVxuXG4gIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkR2xvYmFsQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRHbG9iYWxBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEdsb2JhbEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSBhcyBHbG9iYWxBdHRyaWJ1dGVzXG5cbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goZ2xvYmFsQXR0cmlidXRlID0+IHtcbiAgICAgIGdsb2JhbEF0dHJpYnV0ZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBPYmplY3RcbiAgICAgICAgICAuZW50cmllcyhnbG9iYWxBdHRyaWJ1dGUuYXR0cmlidXRlcylcbiAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZToge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIG5vZGVBbmRNYXJrRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkQXR0cmlidXRlcyddIHwgTWFya0NvbmZpZ1snYWRkQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKSBhcyBBdHRyaWJ1dGVzXG5cbiAgICBPYmplY3RcbiAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VkQXR0cj8uaXNSZXF1aXJlZCAmJiBtZXJnZWRBdHRyPy5kZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgbWVyZ2VkQXR0ci5kZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSlcblxuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVR5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlcyguLi5vYmplY3RzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIG9iamVjdHNcbiAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgIC5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9XG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdHMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV1cblxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXM6IHN0cmluZ1tdID0gdmFsdWUgPyB2YWx1ZS5zcGxpdCgnICcpIDogW11cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXM6IHN0cmluZ1tdID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXVxuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoXG4gICAgICAgICAgICB2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcyksXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gW21lcmdlZEF0dHJpYnV0ZXNba2V5XSwgdmFsdWVdLmpvaW4oJzsgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbWVyZ2VkQXR0cmlidXRlc1xuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB7IE1hcmssIE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMoXG4gIG5vZGVPck1hcms6IE5vZGUgfCBNYXJrLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2l0ZW0ubmFtZV06IG5vZGVPck1hcmsuYXR0cnNbaXRlbS5uYW1lXSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fVxuICAgIH0pXG4gICAgLnJlZHVjZSgoYXR0cmlidXRlcywgYXR0cmlidXRlKSA9PiBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgYXR0cmlidXRlKSwge30pXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWU6IGFueSk6IHZhbHVlIGlzIEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwgImltcG9ydCB7IE1heWJlUmV0dXJuVHlwZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbi5qcydcblxuLyoqXG4gKiBPcHRpb25hbGx5IGNhbGxzIGB2YWx1ZWAgYXMgYSBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAqIEBwYXJhbSB2YWx1ZSBGdW5jdGlvbiBvciBhbnkgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gZnVuY3Rpb24uXG4gKiBAcGFyYW0gcHJvcHMgT3B0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxPclJldHVybjxUPih2YWx1ZTogVCwgY29udGV4dDogYW55ID0gdW5kZWZpbmVkLCAuLi5wcm9wczogYW55W10pOiBNYXliZVJldHVyblR5cGU8VD4ge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmJpbmQoY29udGV4dCkoLi4ucHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlKC4uLnByb3BzKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlIGFzIE1heWJlUmV0dXJuVHlwZTxUPlxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KHZhbHVlID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDAgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdFxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlOiBhbnkpOiBhbnkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKHZhbHVlLm1hdGNoKC9eWystXT8oPzpcXGQqXFwuKT9cXGQrJC8pKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VSdWxlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2Zyb21TdHJpbmcuanMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtZXJnZXMgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgaW50byBwYXJzZXJ1bGUgYXR0cmlidXRlcyAoYGF0dHJzYCBvciBgZ2V0QXR0cnNgKS5cbiAqIENhbmNlbHMgd2hlbiBgZ2V0QXR0cnNgIHJldHVybmVkIGBmYWxzZWAuXG4gKiBAcGFyYW0gcGFyc2VSdWxlIFByb3NlTWlycm9yIFBhcnNlUnVsZVxuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGluamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKFxuICBwYXJzZVJ1bGU6IFBhcnNlUnVsZSxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBQYXJzZVJ1bGUge1xuICBpZiAocGFyc2VSdWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIHBhcnNlUnVsZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IG5vZGUgPT4ge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHBhcnNlUnVsZS5nZXRBdHRycyA/IHBhcnNlUnVsZS5nZXRBdHRycyhub2RlKSA6IHBhcnNlUnVsZS5hdHRyc1xuXG4gICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICA/IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTChub2RlIGFzIEhUTUxFbGVtZW50KVxuICAgICAgICAgIDogZnJvbVN0cmluZygobm9kZSBhcyBIVE1MRWxlbWVudCkuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpXG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9XG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtTcGVjLCBOb2RlU3BlYywgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yLCBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBBbnlDb25maWcsIEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBpc0VtcHR5T2JqZWN0IH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIH0gZnJvbSAnLi9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW08VD4oZGF0YTogVCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlIGFzIHt9IHwgdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICB9KSxcbiAgKSBhcyBUXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQcm9zZW1pcnJvciBzY2hlbWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuc2lvbnMuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlXG4gKiBAcmV0dXJucyBBIFByb3NlbWlycm9yIHNjaGVtYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHRvcE5vZGUgPSBub2RlRXh0ZW5zaW9ucy5maW5kKGV4dGVuc2lvbiA9PiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd0b3BOb2RlJykpPy5uYW1lXG5cbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICApXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhTm9kZUZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snZXh0ZW5kTm9kZVNjaGVtYSddPihcbiAgICAgICAgICBlLFxuICAgICAgICAgICdleHRlbmROb2RlU2NoZW1hJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uKGV4dGVuZE5vZGVTY2hlbWEgPyBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICBjb25zdCBzY2hlbWE6IE5vZGVTcGVjID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXG4gICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb250ZW50J10+KGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgbWFya3M6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydtYXJrcyddPihleHRlbnNpb24sICdtYXJrcycsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaW5saW5lJ10+KGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXRvbTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2F0b20nXT4oZXh0ZW5zaW9uLCAnYXRvbScsIGNvbnRleHQpKSxcbiAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3NlbGVjdGFibGUnXT4oZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkcmFnZ2FibGUnXT4oZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb2RlJ10+KGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZGVmaW5pbmcnXT4oZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaXNvbGF0aW5nJ10+KGV4dGVuc2lvbiwgJ2lzb2xhdGluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0IH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3BhcnNlSFRNTCddPihleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSxcbiAgICAgIClcblxuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlckhUTUwnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlckhUTUwnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSBub2RlID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlclRleHQnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlclRleHQnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVyVGV4dCkge1xuICAgICAgICBzY2hlbWEudG9UZXh0ID0gcmVuZGVyVGV4dFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFNYXJrRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmRNYXJrU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydleHRlbmRNYXJrU2NoZW1hJ10+KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgJ2V4dGVuZE1hcmtTY2hlbWEnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTWFya1NwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snaW5jbHVzaXZlJ10+KGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2V4Y2x1ZGVzJ10+KGV4dGVuc2lvbiwgJ2V4Y2x1ZGVzJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgIHNwYW5uaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snc3Bhbm5pbmcnXT4oZXh0ZW5zaW9uLCAnc3Bhbm5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8uZGVmYXVsdCB9XVxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCksXG4gICAgICApXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydyZW5kZXJIVE1MJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJIVE1MJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbWFyayA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV1cbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzLFxuICB9KVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuLyoqXG4gKiBUcmllcyB0byBnZXQgYSBub2RlIG9yIG1hcmsgdHlwZSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsgdHlwZVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBvciBtYXJrIHR5cGUsIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUgfCBNYXJrVHlwZSB8IG51bGwge1xuICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsXG59XG4iLCAiaW1wb3J0IHsgQW55RXh0ZW5zaW9uLCBFbmFibGVSdWxlcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uOiBBbnlFeHRlbnNpb24sIGVuYWJsZWQ6IEVuYWJsZVJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVuYWJsZWQpKSB7XG4gICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBlbmFibGVkRXh0ZW5zaW9uXG4gICAgICAgIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lXG5cbiAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZW5hYmxlZFxufVxuIiwgImltcG9ydCB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSByZXNvbHZlZCBwcm9zZW1pcnJvciBwb3NpdGlvblxuICogQHBhcmFtICRmcm9tIFRoZSByZXNvbHZlZCBwb3NpdGlvbiB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tXG4gKiBAcGFyYW0gbWF4TWF0Y2ggVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IGNvbnRlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tOiBSZXNvbHZlZFBvcywgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSAnJ1xuXG4gIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0XG5cbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihcbiAgICBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSxcbiAgICBzbGljZUVuZFBvcyxcbiAgICAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaHVuayA9IG5vZGUudHlwZS5zcGVjLnRvVGV4dD8uKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGluZGV4LFxuICAgICAgfSlcbiAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICB8fCAnJWxlYWYlJ1xuXG4gICAgICB0ZXh0QmVmb3JlICs9IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSlcbiAgICB9LFxuICApXG5cbiAgcmV0dXJuIHRleHRCZWZvcmVcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlZ0V4cCB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksXG4gIFJhbmdlLFxuICBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcpID0+IElucHV0UnVsZU1hdGNoIHwgbnVsbClcblxuZXhwb3J0IGNsYXNzIElucHV0UnVsZSB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICByYW5nZTogUmFuZ2VcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIH0pID0+IHZvaWQgfCBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZFxuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyXG4gIH1cbn1cblxuY29uc3QgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAoXG4gIHRleHQ6IHN0cmluZyxcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IHwgbnVsbCA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBmaW5kLmV4ZWModGV4dClcbiAgfVxuXG4gIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KVxuXG4gIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF1cblxuICByZXN1bHQuaW5kZXggPSBpbnB1dFJ1bGVNYXRjaC5pbmRleFxuICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YVxuXG4gIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1t0aXB0YXAgd2Fybl06IFwiaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJpbnB1dFJ1bGVNYXRjaC50ZXh0XCIuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcnVsZXM6IElucHV0UnVsZVtdXG4gIHBsdWdpbjogUGx1Z2luXG59KTogYm9vbGVhbiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luLFxuICB9ID0gY29uZmlnXG4gIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG5cbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSlcblxuICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZVxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG1hcmtcbiAgICB8fCAhISgkZnJvbS5ub2RlQmVmb3JlIHx8ICRmcm9tLm5vZGVBZnRlcik/Lm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBtYXRjaGVkID0gZmFsc2VcblxuICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dFxuXG4gIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKVxuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZTogdmlldy5zdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICB9KVxuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgZnJvbTogZnJvbSAtIChtYXRjaFswXS5sZW5ndGggLSB0ZXh0Lmxlbmd0aCksXG4gICAgICB0byxcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGUsXG4gICAgfSlcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgc3RhdGUsXG4gICAgICByYW5nZSxcbiAgICAgIG1hdGNoLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBjaGFpbixcbiAgICAgIGNhbixcbiAgICB9KVxuXG4gICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgIGlmIChoYW5kbGVyID09PSBudWxsIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAvLyBzbyB3ZSBjYW4gdW5kbyBpbnB1dCBydWxlcyB3aXRoaW4gdGhlIGB1bmRvSW5wdXRSdWxlc2AgY29tbWFuZFxuICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgdGV4dCxcbiAgICB9KVxuXG4gICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICBtYXRjaGVkID0gdHJ1ZVxuICB9KVxuXG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGlucHV0IHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHRleHRcbiAqIGlucHV0IHRoYXQgbWF0Y2hlcyBhbnkgb2YgdGhlIGdpdmVuIHJ1bGVzIHRvIHRyaWdnZXIgdGhlIHJ1bGXigJlzXG4gKiBhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBydWxlczogSW5wdXRSdWxlW10gfSk6IFBsdWdpbiB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pXG5cbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIElucHV0UnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZElucHV0TWV0YSA9IHRyLmdldE1ldGEoJ2FwcGx5SW5wdXRSdWxlcycpXG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkSW5wdXQgPSAhIXNpbXVsYXRlZElucHV0TWV0YVxuXG4gICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRleHQgfSA9IHNpbXVsYXRlZElucHV0TWV0YVxuICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGhcblxuICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgcGx1Z2luLFxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiB2aWV3ID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gJ0VudGVyJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdGV4dDogJ1xcbicsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlLFxuICB9KSBhcyBQbHVnaW5cblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LFxuICBSYW5nZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4vdXRpbGl0aWVzL2lzTnVtYmVyLmpzJ1xuaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL3V0aWxpdGllcy9pc1JlZ0V4cC5qcydcblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlTWF0Y2ggPSB7XG4gIGluZGV4OiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJlcGxhY2VXaXRoPzogc3RyaW5nXG4gIG1hdGNoPzogUmVnRXhwTWF0Y2hBcnJheVxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgdHlwZSBQYXN0ZVJ1bGVGaW5kZXIgPSBSZWdFeHAgfCAoKHRleHQ6IHN0cmluZywgZXZlbnQ/OiBDbGlwYm9hcmRFdmVudCB8IG51bGwpID0+IFBhc3RlUnVsZU1hdGNoW10gfCBudWxsIHwgdW5kZWZpbmVkKVxuXG4vKipcbiAqIFBhc3RlIHJ1bGVzIGFyZSB1c2VkIHRvIHJlYWN0IHRvIHBhc3RlZCBjb250ZW50LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI3Bhc3RlLXJ1bGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXN0ZVJ1bGUge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudCB8IG51bGxcbiAgICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbiAgfSkgPT4gdm9pZCB8IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgZHJvcEV2ZW50OiBEcmFnRXZlbnQgfCBudWxsXG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudCB8IG51bGxcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXIsXG4gIGV2ZW50PzogQ2xpcGJvYXJkRXZlbnQgfCBudWxsLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5W10gPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldXG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudClcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLm1hcChwYXN0ZVJ1bGVNYXRjaCA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF1cblxuICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dFxuICAgIHJlc3VsdC5kYXRhID0gcGFzdGVSdWxlTWF0Y2guZGF0YVxuXG4gICAgaWYgKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgcnVsZTogUGFzdGVSdWxlXG4gIHBhc3RlRXZlbnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLCBwYXN0ZUV2ZW50LCBkcm9wRXZlbnQsXG4gIH0gPSBjb25maWdcblxuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZSxcbiAgfSlcblxuICBjb25zdCBoYW5kbGVyczogKHZvaWQgfCBudWxsKVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpXG5cbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIGZyb206IHN0YXRlLnRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgfSlcblxuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbClcblxuICByZXR1cm4gc3VjY2Vzc1xufVxuXG5jb25zdCBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICBjb25zdCBldmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxuICB9KVxuXG4gIGV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvaHRtbCcsIHRleHQpXG5cbiAgcmV0dXJuIGV2ZW50XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHBhc3RlIHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHBhc3RlZFxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IFBhc3RlUnVsZVtdIH0pOiBQbHVnaW5bXSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgbGV0IGRyYWdTb3VyY2VFbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2VcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBwYXN0ZUV2ZW50ID0gdHlwZW9mIENsaXBib2FyZEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnKSA6IG51bGxcbiAgbGV0IGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbFxuXG4gIGNvbnN0IHByb2Nlc3NFdmVudCA9ICh7XG4gICAgc3RhdGUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBydWxlLFxuICAgIHBhc3RlRXZ0LFxuICB9OiB7XG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgZnJvbTogbnVtYmVyXG4gICAgdG86IHsgYjogbnVtYmVyIH1cbiAgICBydWxlOiBQYXN0ZVJ1bGVcbiAgICBwYXN0ZUV2dDogQ2xpcGJvYXJkRXZlbnQgfCBudWxsXG4gIH0pID0+IHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyXG4gICAgY29uc3QgY2hhaW5hYmxlU3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICB9KVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHJ1bih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXG4gICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICB0bzogdG8uYiAtIDEsXG4gICAgICBydWxlLFxuICAgICAgcGFzdGVFdmVudDogcGFzdGVFdnQsXG4gICAgICBkcm9wRXZlbnQsXG4gICAgfSlcblxuICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBEcmFnRXZlbnQoJ2Ryb3AnKSA6IG51bGxcbiAgICBwYXN0ZUV2ZW50ID0gdHlwZW9mIENsaXBib2FyZEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnKSA6IG51bGxcblxuICAgIHJldHVybiB0clxuICB9XG5cbiAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgdmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudDogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50Py5jb250YWlucyhldmVudC50YXJnZXQgYXMgRWxlbWVudClcbiAgICAgICAgICAgID8gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgZHJvcDogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IGV2ZW50IGFzIERyYWdFdmVudFxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gKGV2ZW50IGFzIENsaXBib2FyZEV2ZW50KS5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuXG4gICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnRcblxuICAgICAgICAgICAgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSAhIWh0bWw/LmluY2x1ZGVzKCdkYXRhLXBtLXNsaWNlJylcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbMF1cbiAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3VpRXZlbnQnKSA9PT0gJ3Bhc3RlJyAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3JcbiAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAnZHJvcCcgJiYgIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvclxuXG4gICAgICAgIC8vIGlmIFBhc3RlUnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZFBhc3RlTWV0YSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2FwcGx5UGFzdGVSdWxlcycpXG4gICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkUGFzdGUgPSAhIXNpbXVsYXRlZFBhc3RlTWV0YVxuXG4gICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgc2ltdWxhdGVkIHBhc3RlXG4gICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgY29uc3QgeyBmcm9tLCB0ZXh0IH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGFcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIGNvbnN0IHBhc3RlRXZ0ID0gY3JlYXRlQ2xpcGJvYXJkUGFzdGVFdmVudCh0ZXh0KVxuXG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG86IHsgYjogdG8gfSxcbiAgICAgICAgICAgIHBhc3RlRXZ0LFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYWN0dWFsIHBhc3RlL2Ryb3BcbiAgICAgICAgY29uc3QgZnJvbSA9IG9sZFN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoc3RhdGUuZG9jLmNvbnRlbnQpXG4gICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpXG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBjaGFuZ2VkIHJhbmdlXG4gICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwYXN0ZUV2dDogcGFzdGVFdmVudCxcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luc1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtczogYW55W10pOiBhbnlbXSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleClcblxuICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXVxufVxuIiwgImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJ1xuaW1wb3J0IHsgTm9kZSBhcyBQcm9zZW1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVCeU5hbWUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIH0gZnJvbSAnLi9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IE1hcmssIE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlLCBpbnB1dFJ1bGVzUGx1Z2luIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIHBhc3RlUnVsZXNQbHVnaW4gfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEFueUNvbmZpZywgRXh0ZW5zaW9ucywgUmF3Q29tbWFuZHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgZmluZER1cGxpY2F0ZXMgfSBmcm9tICcuL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy5qcydcblxuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHNjaGVtYTogU2NoZW1hXG5cbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9uc1xuXG4gIHNwbGl0dGFibGVNYXJrczogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcbiAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKVxuICAgIHRoaXMuc2V0dXBFeHRlbnNpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGFuZCBzb3J0ZWQgZXh0ZW5zaW9uIGxpc3Qgd2hpbGVcbiAgICogYWxzbyBjaGVja2luZyBmb3IgZHVwbGljYXRlZCBleHRlbnNpb25zIGFuZCB3YXJucyB0aGUgdXNlci5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAgICogQHJldHVybnMgQW4gZmxhdHRlbmVkIGFuZCBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAgICovXG4gIHN0YXRpYyByZXNvbHZlKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKVxuICAgIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSlcblxuICAgIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBEdXBsaWNhdGUgZXh0ZW5zaW9uIG5hbWVzIGZvdW5kOiBbJHtkdXBsaWNhdGVkTmFtZXNcbiAgICAgICAgICAubWFwKGl0ZW0gPT4gYCcke2l0ZW19J2ApXG4gICAgICAgICAgLmpvaW4oJywgJyl9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZmxhdHRlbmVkIGFycmF5IG9mIGV4dGVuc2lvbnMgYnkgdHJhdmVyc2luZyB0aGUgYGFkZEV4dGVuc2lvbnNgIGZpZWxkLlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgKiBAcmV0dXJucyBBIGZsYXR0ZW5lZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIHJldHVybiAoXG4gICAgICBleHRlbnNpb25zXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEV4dGVuc2lvbnMnXT4oXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAnYWRkRXh0ZW5zaW9ucycsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbiwgLi4udGhpcy5mbGF0dGVuKGFkZEV4dGVuc2lvbnMoKSldXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblxuICAgICAgICB9KVxuICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxuICAgICAgICAuZmxhdCgxMClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU29ydCBleHRlbnNpb25zIGJ5IHByaW9yaXR5LlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgKiBAcmV0dXJucyBBIHNvcnRlZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9ucyBieSBwcmlvcml0eVxuICAgKi9cbiAgc3RhdGljIHNvcnQoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMFxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydwcmlvcml0eSddPihhLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHlcbiAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDBcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgY29tbWFuZHMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIGNvbW1hbmRzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGNvbW1hbmQgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjb21tYW5kIGZ1bmN0aW9uXG4gICAqL1xuICBnZXQgY29tbWFuZHMoKTogUmF3Q29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFkZENvbW1hbmRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRDb21tYW5kcyddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnYWRkQ29tbWFuZHMnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAoIWFkZENvbW1hbmRzKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb21tYW5kcyxcbiAgICAgICAgLi4uYWRkQ29tbWFuZHMoKSxcbiAgICAgIH1cbiAgICB9LCB7fSBhcyBSYXdDb21tYW5kcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgUHJvc2VtaXJyb3IgcGx1Z2lucyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAqL1xuICBnZXQgcGx1Z2lucygpOiBQbHVnaW5bXSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIC8vIFdpdGggUHJvc2VNaXJyb3IsIGZpcnN0IHBsdWdpbnMgd2l0aGluIGFuIGFycmF5IGFyZSBleGVjdXRlZCBmaXJzdC5cbiAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcbiAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAvLyBUaGF04oCZcyB3aHkgd2UgaGF2ZSB0byByZXZlcnNlIHRoZSBgZXh0ZW5zaW9uc2AgYXJyYXkgYW5kIHNvcnQgYWdhaW5cbiAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpXG5cbiAgICBjb25zdCBpbnB1dFJ1bGVzOiBJbnB1dFJ1bGVbXSA9IFtdXG4gICAgY29uc3QgcGFzdGVSdWxlczogUGFzdGVSdWxlW10gPSBbXVxuXG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuXG4gICAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRLZXlib2FyZFNob3J0Y3V0cyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5nczogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgICAgIC8vIGJpbmQgZXhpdCBoYW5kbGluZ1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyAmJiBleHRlbnNpb24uY29uZmlnLmV4aXRhYmxlKSB7XG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiBhcyBNYXJrIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKVxuXG4gICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pXG5cbiAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkSW5wdXRSdWxlcyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZElucHV0UnVsZXMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFBhc3RlUnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQYXN0ZVJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZFByb3NlTWlycm9yUGx1Z2lucycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKVxuXG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW5zXG4gICAgICB9KVxuICAgICAgLmZsYXQoKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5wYXN0ZVJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4uYWxsUGx1Z2lucyxcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAgICovXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9kZSB2aWV3cyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbGwgbm9kZSB2aWV3cyB3aGVyZSB0aGUga2V5IGlzIHRoZSBub2RlIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgbm9kZSB2aWV3IGZ1bmN0aW9uXG4gICAqL1xuICBnZXQgbm9kZVZpZXdzKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBub2RlRXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JykpXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2FkZE5vZGVWaWV3J10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZE5vZGVWaWV3JyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKCFhZGROb2RlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAoXG4gICAgICAgICAgICBub2RlOiBQcm9zZW1pcnJvck5vZGUsXG4gICAgICAgICAgICB2aWV3OiBFZGl0b3JWaWV3LFxuICAgICAgICAgICAgZ2V0UG9zOiAoKCkgPT4gbnVtYmVyKSB8IGJvb2xlYW4sXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcylcblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGdldFBvcyxcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XVxuICAgICAgICB9KSxcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR28gdGhyb3VnaCBhbGwgZXh0ZW5zaW9ucywgY3JlYXRlIGV4dGVuc2lvbiBzdG9yYWdlcyAmIHNldHVwIG1hcmtzXG4gICAqICYgYmluZCBlZGl0b3IgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBwcml2YXRlIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgLy8gc3RvcmUgZXh0ZW5zaW9uIHN0b3JhZ2UgaW4gZWRpdG9yXG4gICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5zdG9yYWdlXG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkgPz8gdHJ1ZVxuXG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmVmb3JlQ3JlYXRlJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvbkJlZm9yZUNyZWF0ZScsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG4gICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25DcmVhdGUnXT4oZXh0ZW5zaW9uLCAnb25DcmVhdGUnLCBjb250ZXh0KVxuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uVXBkYXRlJ10+KGV4dGVuc2lvbiwgJ29uVXBkYXRlJywgY29udGV4dClcbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblNlbGVjdGlvblVwZGF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25TZWxlY3Rpb25VcGRhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25UcmFuc2FjdGlvbiddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG4gICAgICBjb25zdCBvbkZvY3VzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkZvY3VzJ10+KGV4dGVuc2lvbiwgJ29uRm9jdXMnLCBjb250ZXh0KVxuICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJsdXInXT4oZXh0ZW5zaW9uLCAnb25CbHVyJywgY29udGV4dClcbiAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25EZXN0cm95J10+KGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmVmb3JlQ3JlYXRlJywgb25CZWZvcmVDcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignY3JlYXRlJywgb25DcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChvblNlbGVjdGlvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignc2VsZWN0aW9uVXBkYXRlJywgb25TZWxlY3Rpb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIG9uVHJhbnNhY3Rpb24pXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCBvbkJsdXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2Rlc3Ryb3knLCBvbkRlc3Ryb3kpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwgIi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lc3F1ZWViL2lzLXdoYXQvYmxvYi84OGQ2ZTRjYTkyZmIyYmFhYjYwMDNjNTRlMDJlZWRmNGU3MjllNWFiL3NyYy9pbmRleC50c1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlXG59XG4iLCAiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQ6IFJlY29yZDxzdHJpbmcsIGFueT4sIHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBFeHRlbnNpb25Db25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVuc2lvbiBuYW1lIC0gdGhpcyBtdXN0IGJlIHVuaXF1ZS5cbiAgICAgKiBJdCB3aWxsIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlICdteUV4dGVuc2lvbidcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmlvcml0eSBvZiB5b3VyIGV4dGVuc2lvbi4gVGhlIGhpZ2hlciwgdGhlIGxhdGVyIGl0IHdpbGwgYmUgY2FsbGVkXG4gICAgICogYW5kIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgb3RoZXIgZXh0ZW5zaW9ucyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkuXG4gICAgICogQGRlZmF1bHQgMTAwMFxuICAgICAqIEBleGFtcGxlIDEwMDFcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBleHRlbnNpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkZWZhdWx0T3B0aW9uczoge1xuICAgICAqICAgbXlPcHRpb246ICdmb28nLFxuICAgICAqICAgbXlPdGhlck9wdGlvbjogMTAsXG4gICAgICogfVxuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgb3B0aW9ucyB0byB0aGlzIGV4dGVuc2lvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3NldHRpbmdzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRPcHRpb25zKCkge1xuICAgICAqICByZXR1cm4ge1xuICAgICAqICAgIG15T3B0aW9uOiAnZm9vJyxcbiAgICAgKiAgICBteU90aGVyT3B0aW9uOiAxMCxcbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc3RvcmFnZSB0aGlzIGV4dGVuc2lvbiBjYW4gc2F2ZSBkYXRhIHRvLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3N0b3JhZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRlZmF1bHRTdG9yYWdlOiB7XG4gICAgICogICBwcmVmZXRjaGVkVXNlcnM6IFtdLFxuICAgICAqICAgbG9hZGluZzogZmFsc2UsXG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZFN0b3JhZ2U/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBnbG9iYWxBdHRyaWJ1dGVzIHRvIHNwZWNpZmljIG5vZGVzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2dsb2JhbC1hdHRyaWJ1dGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAge1xuICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbnNcbiAgICAgKiAgICAgICB0eXBlczogW1xuICAgICAqICAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAqICAgICAgICAgJ3BhcmFncmFwaCcsXG4gICAgICogICAgICAgXSxcbiAgICAgKiAgICAgICAvLyDigKYgd2l0aCB0aG9zZSBhdHRyaWJ1dGVzXG4gICAgICogICAgICAgYXR0cmlidXRlczoge1xuICAgICAqICAgICAgICAgdGV4dEFsaWduOiB7XG4gICAgICogICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgKiAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiAoe1xuICAgICAqICAgICAgICAgICAgIHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gLFxuICAgICAqICAgICAgICAgICB9KSxcbiAgICAgKiAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduIHx8ICdsZWZ0JyxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIF1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNvbW1hbmRzIHRvIHRoZSBlZGl0b3JcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNrZXlib2FyZC1zaG9ydGN1dHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZENvbW1hbmRzKCkge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgbXlDb21tYW5kOiAoKSA9PiAoeyBjaGFpbiB9KSA9PiBjaGFpbigpLnNldE1hcmsoJ3R5cGUnLCAnZm9vJykucnVuKCksXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZWdpc3RlcnMga2V5Ym9hcmQgc2hvcnRjdXRzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2tleWJvYXJkLXNob3J0Y3V0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICogICByZXR1cm4ge1xuICAgICAqICAgICAnTW9kLWwnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KCksXG4gICAgICogICB9XG4gICAgICogfSxcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRLZXlib2FyZFNob3J0Y3V0cyddXG4gICAgfSkgPT4ge1xuICAgICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgaW5wdXQgcnVsZXMgdG8gdGhlIGVkaXRvci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNpbnB1dC1ydWxlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAqICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICogICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAqICAgICB9KSxcbiAgICAgKiAgIF1cbiAgICAgKiB9LFxuICAgICAqL1xuICAgIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBwYXN0ZSBydWxlcyB0byB0aGUgZWRpdG9yLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3Bhc3RlLXJ1bGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICogICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgKiAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICogICAgIH0pLFxuICAgICAqICAgXVxuICAgICAqIH0sXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIFByb3NlbWlycm9yIHBsdWdpbnMgdG8gdGhlIGVkaXRvclxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3Byb3NlbWlycm9yLXBsdWdpbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIGN1c3RvbVBsdWdpbigpLFxuICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGFkZGl0aW9uYWwgZXh0ZW5zaW9ucyB0byB0aGUgZWRpdG9yLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBidWlsZGluZyBleHRlbnNpb24ga2l0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgICogICByZXR1cm4gW1xuICAgICAqICAgICBCdWxsZXRMaXN0LFxuICAgICAqICAgICBPcmRlcmVkTGlzdCxcbiAgICAgKiAgICAgTGlzdEl0ZW1cbiAgICAgKiAgIF1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkRXh0ZW5zaW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXh0ZW5kcyB0aGUgc2NoZW1hIG9mIHRoZSBub2RlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXh0ZW5kTm9kZVNjaGVtYSgpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleHRlbmRzIHRoZSBzY2hlbWEgb2YgdGhlIG1hcmsuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBleHRlbmRNYXJrU2NoZW1hKCkge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAqICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTWFyayxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICovXG4gICAgb25CZWZvcmVDcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CZWZvcmVDcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIG9uQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uU2VsZWN0aW9uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblRyYW5zYWN0aW9uPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmx1ciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9uRGVzdHJveT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkRlc3Ryb3knXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbjxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnZXh0ZW5zaW9uJ1xuXG4gIG5hbWUgPSAnZXh0ZW5zaW9uJ1xuXG4gIHBhcmVudDogRXh0ZW5zaW9uIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogRXh0ZW5zaW9uIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogRXh0ZW5zaW9uQ29uZmlnID0ge1xuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuc2lvbjxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb248RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFJhbmdlLCBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgYmV0d2VlbiB0d28gcG9zaXRpb25zIGluIGEgUHJvc2VtaXJyb3Igbm9kZVxuICogYW5kIHNlcmlhbGl6ZXMgaXQgdXNpbmcgdGhlIGdpdmVuIHRleHQgc2VyaWFsaXplcnMgYW5kIGJsb2NrIHNlcGFyYXRvciAoc2VlIGdldFRleHQpXG4gKiBAcGFyYW0gc3RhcnROb2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHRleHQgdG8gZ2V0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBiZXR3ZWVuIHRoZSB0d28gcG9zaXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihcbiAgc3RhcnROb2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHJhbmdlOiBSYW5nZSxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuICBsZXQgdGV4dCA9ICcnXG5cbiAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gZnJvbSkge1xuICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvclxuICAgIH1cblxuICAgIGNvbnN0IHRleHRTZXJpYWxpemVyID0gdGV4dFNlcmlhbGl6ZXJzPy5bbm9kZS50eXBlLm5hbWVdXG5cbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhbmdlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gZG8gbm90IGRlc2NlbmQgaW50byBjaGlsZCBub2RlcyB3aGVuIHRoZXJlIGV4aXN0cyBhIHNlcmlhbGl6ZXJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgdGV4dCArPSBub2RlPy50ZXh0Py5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdGV4dFxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogRmluZCB0ZXh0IHNlcmlhbGl6ZXJzIGB0b1RleHRgIGluIGEgUHJvc2VtaXJyb3Igc2NoZW1hXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcnJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBBIHJlY29yZCBvZiB0ZXh0IHNlcmlhbGl6ZXJzIGJ5IG5vZGUgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWE6IFNjaGVtYSk6IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm5vZGVzKVxuICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSksXG4gIClcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0QmV0d2Vlbi5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCB0eXBlIENsaXBib2FyZFRleHRTZXJpYWxpemVyT3B0aW9ucyA9IHtcbiAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmcsXG59XG5cbmV4cG9ydCBjb25zdCBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGU8Q2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJPcHRpb25zPih7XG4gIG5hbWU6ICdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tTZXBhcmF0b3I6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNsaXBib2FyZFRleHRTZXJpYWxpemVyOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3JcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKVxuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKVxuICAgICAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXJzID0gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4oZG9jLCByYW5nZSwge1xuICAgICAgICAgICAgICAuLi4odGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHsgYmxvY2tTZXBhcmF0b3I6IHRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgIHRleHRTZXJpYWxpemVycyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJsdXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuYmx1cigpXG4gICAgICAgKi9cbiAgICAgIGJsdXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBibHVyOiBSYXdDb21tYW5kc1snYmx1ciddID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgKHZpZXcuZG9tIGFzIEhUTUxFbGVtZW50KS5ibHVyKClcblxuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIHJlbW92ZSB0aGUgY2FyZXQgb24gYmx1ciBidXQgc2FmYXJpIGRvZXMgbm90LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcbiAgICAgIHdpbmRvdz8uZ2V0U2VsZWN0aW9uKCk/LnJlbW92ZUFsbFJhbmdlcygpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyQ29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhciB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKiBAcGFyYW0gZW1pdFVwZGF0ZSBXaGV0aGVyIHRvIGVtaXQgYW4gdXBkYXRlIGV2ZW50LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmNsZWFyQ29udGVudCgpXG4gICAgICAgKi9cbiAgICAgIGNsZWFyQ29udGVudDogKGVtaXRVcGRhdGU/OiBib29sZWFuKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJDb250ZW50OiBSYXdDb21tYW5kc1snY2xlYXJDb250ZW50J10gPSAoZW1pdFVwZGF0ZSA9IGZhbHNlKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRDb250ZW50KCcnLCBlbWl0VXBkYXRlKVxufVxuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyTm9kZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogTm9ybWFsaXplIG5vZGVzIHRvIGEgc2ltcGxlIHBhcmFncmFwaC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAqL1xuICAgICAgY2xlYXJOb2RlczogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFyTm9kZXM6IFJhd0NvbW1hbmRzWydjbGVhck5vZGVzJ10gPSAoKSA9PiAoeyBzdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkb2MsIG1hcHBpbmcgfSA9IHRyXG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpXG4gICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSlcbiAgICAgIGNvbnN0IG5vZGVSYW5nZSA9ICRtYXBwZWRGcm9tLmJsb2NrUmFuZ2UoJG1hcHBlZFRvKVxuXG4gICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpXG5cbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpXG5cbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29tbWFuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmUgYSBjb21tYW5kIGlubGluZS5cbiAgICAgICAqIEBwYXJhbSBmbiBUaGUgY29tbWFuZCBmdW5jdGlvbi5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBlZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciwgc3RhdGUgfSkgPT4ge1xuICAgICAgICogICAuLi5cbiAgICAgICAqICAgcmV0dXJuIHRydWVcbiAgICAgICAqIH0pXG4gICAgICAgKi9cbiAgICAgIGNvbW1hbmQ6IChmbjogKHByb3BzOiBQYXJhbWV0ZXJzPENvbW1hbmQ+WzBdKSA9PiBib29sZWFuKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29tbWFuZDogUmF3Q29tbWFuZHNbJ2NvbW1hbmQnXSA9IGZuID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGZuKHByb3BzKVxufVxuIiwgImltcG9ydCB7IGNyZWF0ZVBhcmFncmFwaE5lYXIgYXMgb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgcGFyYWdyYXBoIG5lYXJieS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKClcbiAgICAgICAqL1xuICAgICAgY3JlYXRlUGFyYWdyYXBoTmVhcjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhcjogUmF3Q29tbWFuZHNbJ2NyZWF0ZVBhcmFncmFwaE5lYXInXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEN1dHMgY29udGVudCBmcm9tIGEgcmFuZ2UgYW5kIGluc2VydHMgaXQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gY3V0LlxuICAgICAgICogQHBhcmFtIHJhbmdlLmZyb20gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSByYW5nZS50byBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB0YXJnZXRQb3MgVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgY29udGVudCBhdC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jdXQoeyBmcm9tOiAxLCB0bzogMyB9LCA1KVxuICAgICAgICovXG4gICAgICBjdXQ6ICh7IGZyb20sIHRvIH06IHsgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyIH0sIHRhcmdldFBvczogbnVtYmVyKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3V0OiBSYXdDb21tYW5kc1snY3V0J10gPSAob3JpZ2luUmFuZ2UsIHRhcmdldFBvcykgPT4gKHsgZWRpdG9yLCB0ciB9KSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuXG4gIGNvbnN0IGNvbnRlbnRTbGljZSA9IHN0YXRlLmRvYy5zbGljZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcblxuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcbiAgY29uc3QgbmV3UG9zID0gdHIubWFwcGluZy5tYXAodGFyZ2V0UG9zKVxuXG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KVxuXG4gIHRyLnNldFNlbGVjdGlvbihuZXcgVGV4dFNlbGVjdGlvbih0ci5kb2MucmVzb2x2ZShuZXdQb3MgLSAxKSkpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlQ3VycmVudE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBub2RlIHRoYXQgY3VycmVudGx5IGhhcyB0aGUgc2VsZWN0aW9uIGFuY2hvci5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZUN1cnJlbnROb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlQ3VycmVudE5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVDdXJyZW50Tm9kZSddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IGN1cnJlbnROb2RlID0gc2VsZWN0aW9uLiRhbmNob3Iubm9kZSgpXG5cbiAgLy8gaWYgdGhlcmUgaXMgY29udGVudCBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZSwgYnJlYWsgb3V0IG9mIHRoaXMgY29tbWFuZFxuICBpZiAoY3VycmVudE5vZGUuY29udGVudC5zaXplID4gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gY3VycmVudE5vZGUudHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aClcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZU5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgbm9kZSB3aXRoIGEgZ2l2ZW4gdHlwZSBvciBuYW1lLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVOb2RlKCdwYXJhZ3JhcGgnKVxuICAgICAgICovXG4gICAgICBkZWxldGVOb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVOb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlTm9kZSddID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aClcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlUmFuZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgZ2l2ZW4gcmFuZ2UuXG4gICAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIGRlbGV0ZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb206IDEsIHRvOiAzIH0pXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVJhbmdlOiAocmFuZ2U6IFJhbmdlKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUmFuZ2U6IFJhd0NvbW1hbmRzWydkZWxldGVSYW5nZSddID0gcmFuZ2UgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKVxuICAgICAgICovXG4gICAgICBkZWxldGVTZWxlY3Rpb246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ2RlbGV0ZVNlbGVjdGlvbiddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBlbnRlci5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5lbnRlcigpXG4gICAgICAgKi9cbiAgICAgIGVudGVyOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZW50ZXI6IFJhd0NvbW1hbmRzWydlbnRlciddID0gKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKVxufVxuIiwgImltcG9ydCB7IGV4aXRDb2RlIGFzIG9yaWdpbmFsRXhpdENvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXhpdENvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXhpdCBmcm9tIGEgY29kZSBibG9jay5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpXG4gICAgICAgKi9cbiAgICAgIGV4aXRDb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleGl0Q29kZTogUmF3Q29tbWFuZHNbJ2V4aXRDb2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL2lzUmVnRXhwLmpzJ1xuXG4vKipcbiAqIENoZWNrIGlmIG9iamVjdDEgaW5jbHVkZXMgb2JqZWN0MlxuICogQHBhcmFtIG9iamVjdDEgT2JqZWN0XG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKFxuICBvYmplY3QxOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvYmplY3QyOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvcHRpb25zOiB7IHN0cmljdDogYm9vbGVhbiB9ID0geyBzdHJpY3Q6IHRydWUgfSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0MilcblxuICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWdFeHAob2JqZWN0MltrZXldKSkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XS50ZXN0KG9iamVjdDFba2V5XSlcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrIGFzIFByb3NlTWlycm9yTWFyaywgTWFya1R5cGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KFxuICBtYXJrczogUHJvc2VNaXJyb3JNYXJrW10sXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBQcm9zZU1pcnJvck1hcmsgfCB1bmRlZmluZWQge1xuICByZXR1cm4gbWFya3MuZmluZChpdGVtID0+IHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlICYmIG9iamVjdEluY2x1ZGVzKGl0ZW0uYXR0cnMsIGF0dHJpYnV0ZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzTWFya0luU2V0KFxuICBtYXJrczogUHJvc2VNaXJyb3JNYXJrW10sXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuICEhZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtSYW5nZShcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBSYW5nZSB8IHZvaWQge1xuICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpXG5cbiAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09PSBzdGFydC5vZmZzZXQgJiYgc3RhcnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEJlZm9yZSgkcG9zLnBhcmVudE9mZnNldClcbiAgfVxuXG4gIGlmICghc3RhcnQubm9kZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5pbmRleFxuICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXRcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDFcbiAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgc3RhcnQubm9kZS5ub2RlU2l6ZVxuXG4gIGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIHdoaWxlIChzdGFydEluZGV4ID4gMCAmJiBtYXJrLmlzSW5TZXQoJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzKSkge1xuICAgIHN0YXJ0SW5kZXggLT0gMVxuICAgIHN0YXJ0UG9zIC09ICRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpLm5vZGVTaXplXG4gIH1cblxuICB3aGlsZSAoXG4gICAgZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XG4gICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG4gICkge1xuICAgIGVuZFBvcyArPSAkcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubm9kZVNpemVcbiAgICBlbmRJbmRleCArPSAxXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZyb206IHN0YXJ0UG9zLFxuICAgIHRvOiBlbmRQb3MsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtUeXBlKG5hbWVPclR5cGU6IHN0cmluZyB8IE1hcmtUeXBlLCBzY2hlbWE6IFNjaGVtYSk6IE1hcmtUeXBlIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdXG4gIH1cblxuICByZXR1cm4gbmFtZU9yVHlwZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtSYW5nZS5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBleHRlbmRNYXJrUmFuZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXh0ZW5kcyB0aGUgdGV4dCBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnQgbWFyayBieSB0eXBlIG9yIG5hbWUuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBtYXJrLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1hcmsuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZXh0ZW5kTWFya1JhbmdlKCdib2xkJylcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5leHRlbmRNYXJrUmFuZ2UoJ21lbnRpb24nLCB7IHVzZXJJZDogXCIxXCIgfSlcbiAgICAgICAqL1xuICAgICAgZXh0ZW5kTWFya1JhbmdlOiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBtYXJrLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrLlxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4dGVuZE1hcmtSYW5nZTogUmF3Q29tbWFuZHNbJ2V4dGVuZE1hcmtSYW5nZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmaXJzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIG9uZSBjb21tYW5kIGFmdGVyIHRoZSBvdGhlciBhbmQgc3RvcHMgYXQgdGhlIGZpcnN0IHdoaWNoIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqIEBwYXJhbSBjb21tYW5kcyBUaGUgY29tbWFuZHMgdG8gcnVuLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmZpcnN0KFtjb21tYW5kMSwgY29tbWFuZDJdKVxuICAgICAgICovXG4gICAgICBmaXJzdDogKGNvbW1hbmRzOiBDb21tYW5kW10gfCAoKHByb3BzOiBDb21tYW5kUHJvcHMpID0+IENvbW1hbmRbXSkpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaXJzdDogUmF3Q29tbWFuZHNbJ2ZpcnN0J10gPSBjb21tYW5kcyA9PiBwcm9wcyA9PiB7XG4gIGNvbnN0IGl0ZW1zID0gdHlwZW9mIGNvbW1hbmRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBjb21tYW5kcyhwcm9wcylcbiAgICA6IGNvbW1hbmRzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpdGVtc1tpXShwcm9wcykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUZXh0U2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvblxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKFxuICBkb2M6IFByb3NlTWlycm9yTm9kZSxcbiAgcG9zaXRpb246IEZvY3VzUG9zaXRpb24gPSBudWxsLFxuKTogU2VsZWN0aW9uIHwgbnVsbCB7XG4gIGlmICghcG9zaXRpb24pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYylcbiAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKVxuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0XG4gIH1cblxuICBpZiAocG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kXG4gIH1cblxuICBjb25zdCBtaW5Qb3MgPSBzZWxlY3Rpb25BdFN0YXJ0LmZyb21cbiAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG9cblxuICBpZiAocG9zaXRpb24gPT09ICdhbGwnKSB7XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKFxuICAgICAgZG9jLFxuICAgICAgbWluTWF4KDAsIG1pblBvcywgbWF4UG9zKSxcbiAgICAgIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKFxuICAgIGRvYyxcbiAgICBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSxcbiAgICBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSxcbiAgKVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc2lPUygpOiBib29sZWFuIHtcbiAgcmV0dXJuIFtcbiAgICAnaVBhZCBTaW11bGF0b3InLFxuICAgICdpUGhvbmUgU2ltdWxhdG9yJyxcbiAgICAnaVBvZCBTaW11bGF0b3InLFxuICAgICdpUGFkJyxcbiAgICAnaVBob25lJyxcbiAgICAnaVBvZCcsXG4gIF0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudClcbn1cbiIsICJpbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi5qcydcbmltcG9ydCB7IHJlc29sdmVGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi5qcydcbmltcG9ydCB7IEZvY3VzUG9zaXRpb24sIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGZvY3VzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvY3VzIHRoZSBlZGl0b3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBmb2N1cyBhdC5cbiAgICAgICAqIEBwYXJhbSBvcHRpb25zLnNjcm9sbEludG9WaWV3IFNjcm9sbCB0aGUgZm9jdXNlZCBwb3NpdGlvbiBpbnRvIHZpZXcgYWZ0ZXIgZm9jdXNpbmdcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5mb2N1cygpXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZm9jdXMoMzIsIHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pXG4gICAgICAgKi9cbiAgICAgIGZvY3VzOiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gdG8gZm9jdXMgYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbj86IEZvY3VzUG9zaXRpb24sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG9wdGlvbnNcbiAgICAgICAgICogQGRlZmF1bHQgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9XG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3PzogYm9vbGVhbixcbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvY3VzOiBSYXdDb21tYW5kc1snZm9jdXMnXSA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPU1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGlzXG4gICAgaWYgKGlzaU9TKCkpIHtcbiAgICAgICh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKVxuICAgIH1cblxuICAgIC8vIEZvciBSZWFjdCB3ZSBoYXZlIHRvIGZvY3VzIGFzeW5jaHJvbm91c2x5LiBPdGhlcndpc2Ugd2lsZCB0aGluZ3MgaGFwcGVuLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKVxuXG4gICAgICAgIGlmIChvcHRpb25zPy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwpIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIC8vIGB0ci5zZXRTZWxlY3Rpb25gIHJlc2V0cyB0aGUgc3RvcmVkIG1hcmtzXG4gICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBkZWxheWVkRm9jdXMoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb3JFYWNoOiB7XG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbiBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgZm9yRWFjaDogPFQ+KFxuICAgICAgICBpdGVtczogVFtdLFxuICAgICAgICBmbjogKFxuICAgICAgICAgIGl0ZW06IFQsXG4gICAgICAgICAgcHJvcHM6IENvbW1hbmRQcm9wcyAmIHtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9yRWFjaDogUmF3Q29tbWFuZHNbJ2ZvckVhY2gnXSA9IChpdGVtcywgZm4pID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50KCc8aDE+RXhhbXBsZTwvaDE+JylcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50KCc8aDE+RXhhbXBsZTwvaDE+JywgeyB1cGRhdGVTZWxlY3Rpb246IGZhbHNlIH0pXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnQ6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBQcm9zZU1pcnJvciBjb250ZW50IHRvIGluc2VydC5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBDb250ZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE9wdGlvbnMgZm9yIHBhcnNpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIHRvIHVwZGF0ZSB0aGUgc2VsZWN0aW9uIGFmdGVyIGluc2VydGluZyB0aGUgY29udGVudC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgICAgYXBwbHlJbnB1dFJ1bGVzPzogYm9vbGVhblxuICAgICAgICAgIGFwcGx5UGFzdGVSdWxlcz86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJ0Q29udGVudDogUmF3Q29tbWFuZHNbJ2luc2VydENvbnRlbnQnXSA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdChcbiAgICB7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sXG4gICAgdmFsdWUsXG4gICAgb3B0aW9ucyxcbiAgKVxufVxuIiwgImNvbnN0IHJlbW92ZVdoaXRlc3BhY2VzID0gKG5vZGU6IEhUTUxFbGVtZW50KSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzXG5cbiAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXVxuXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZSAmJiAvXihcXG5cXHNcXHN8XFxuKSQvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZW1vdmVXaGl0ZXNwYWNlcyhjaGlsZCBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWU6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcblxuICByZXR1cm4gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbClcbn1cbiIsICJpbXBvcnQge1xuICBET01QYXJzZXIsXG4gIEZyYWdtZW50LFxuICBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSxcbiAgUGFyc2VPcHRpb25zLFxuICBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuXG5leHBvcnQgdHlwZSBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zID0ge1xuICBzbGljZT86IGJvb2xlYW5cbiAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG59XG5cbi8qKlxuICogVGFrZXMgYSBKU09OIG9yIEhUTUwgY29udGVudCBhbmQgY3JlYXRlcyBhIFByb3NlbWlycm9yIG5vZGUgb3IgZnJhZ21lbnQgZnJvbSBpdC5cbiAqIEBwYXJhbSBjb250ZW50IFRoZSBKU09OIG9yIEhUTUwgY29udGVudCB0byBjcmVhdGUgdGhlIG5vZGUgZnJvbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIG5vZGVcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFByb3NlbWlycm9yIG5vZGUgb3IgZnJhZ21lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChcbiAgY29udGVudDogQ29udGVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIG9wdGlvbnM/OiBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zLFxuKTogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQge1xuICBvcHRpb25zID0ge1xuICAgIHNsaWNlOiB0cnVlLFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGNvbnN0IGlzSlNPTkNvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgY29udGVudCAhPT0gbnVsbFxuICBjb25zdCBpc1RleHRDb250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnXG5cbiAgaWYgKGlzSlNPTkNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNBcnJheUNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMFxuXG4gICAgICAvLyBpZiB0aGUgSlNPTiBDb250ZW50IGlzIGFuIGFycmF5IG9mIG5vZGVzLCBjcmVhdGUgYSBmcmFnbWVudCBmb3IgZWFjaCBub2RlXG4gICAgICBpZiAoaXNBcnJheUNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShjb250ZW50Lm1hcChpdGVtID0+IHNjaGVtYS5ub2RlRnJvbUpTT04oaXRlbSkpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcilcblxuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc1RleHRDb250ZW50KSB7XG4gICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuc2xpY2VcbiAgICAgID8gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XG4gICAgICA6IHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHI6IFRyYW5zYWN0aW9uLCBzdGFydExlbjogbnVtYmVyLCBiaWFzOiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDFcblxuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF1cblxuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdXG4gIGxldCBlbmQgPSAwXG5cbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvXG4gICAgfVxuICB9KVxuXG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSlcbn1cbiIsICJpbXBvcnQgeyBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuaW1wb3J0IHsgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQgfSBmcm9tICcuLi9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50QXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnRBdCgwLCAnPGgxPkV4YW1wbGU8L2gxPicpXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnRBdDogKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgY29udGVudCBhdC5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uOiBudW1iZXIgfCBSYW5nZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFByb3NlTWlycm9yIGNvbnRlbnQgdG8gaW5zZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IENvbnRlbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogT3B0aW9ucyBmb3IgcGFyc2luZyB0aGUgY29udGVudC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gdXBkYXRlIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgaW5zZXJ0aW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICAgICAgICBhcHBseUlucHV0UnVsZXM/OiBib29sZWFuXG4gICAgICAgICAgYXBwbHlQYXN0ZVJ1bGVzPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRnJhZ21lbnQgPSAobm9kZU9yRnJhZ21lbnQ6IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50KTogbm9kZU9yRnJhZ21lbnQgaXMgRnJhZ21lbnQgPT4ge1xuICByZXR1cm4gbm9kZU9yRnJhZ21lbnQudG9TdHJpbmcoKS5zdGFydHNXaXRoKCc8Jylcbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnRBdDogUmF3Q29tbWFuZHNbJ2luc2VydENvbnRlbnRBdCddID0gKHBvc2l0aW9uLCB2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGFwcGx5SW5wdXRSdWxlczogZmFsc2UsXG4gICAgICBhcHBseVBhc3RlUnVsZXM6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHtcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gZG9u4oCZdCBkaXNwYXRjaCBhbiBlbXB0eSBmcmFnbWVudCBiZWNhdXNlIHRoaXMgY2FuIGxlYWQgdG8gc3RyYW5nZSBlcnJvcnNcbiAgICBpZiAoY29udGVudC50b1N0cmluZygpID09PSAnPD4nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9XG5cbiAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlXG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWVcbiAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdXG5cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgYWRkZWQgbm9kZSBpcyB2YWxpZFxuICAgICAgbm9kZS5jaGVjaygpXG5cbiAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlXG5cbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlXG4gICAgfSlcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZXBsYWNlIHRoZSB3cmFwcGluZyBub2RlIGJ5XG4gICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAvLyBleGFtcGxlOlxuICAgIC8vIHJlcGxhY2UgYW4gZW1wdHkgcGFyYWdyYXBoIGJ5IGFuIGluc2VydGVkIGltYWdlXG4gICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSlcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnRcblxuICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgZnJvbSAtPSAxXG4gICAgICAgIHRvICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmV3Q29udGVudFxuXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBwbGFpbiB0ZXh0IHdlIGhhdmUgdG8gdXNlIGBpbnNlcnRUZXh0YFxuICAgIC8vIGJlY2F1c2UgdGhpcyB3aWxsIGtlZXAgdGhlIGN1cnJlbnQgbWFya3NcbiAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgIC8vIGlmIHZhbHVlIGlzIHN0cmluZywgd2UgY2FuIHVzZSBpdCBkaXJlY3RseVxuICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUubWFwKHYgPT4gdi50ZXh0IHx8ICcnKS5qb2luKCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEhdmFsdWUgJiYgISF2YWx1ZS50ZXh0KSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS50ZXh0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUgYXMgc3RyaW5nXG4gICAgICB9XG5cbiAgICAgIHRyLmluc2VydFRleHQobmV3Q29udGVudCwgZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50XG5cbiAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBuZXdDb250ZW50KVxuICAgIH1cblxuICAgIC8vIHNldCBjdXJzb3IgYXQgZW5kIG9mIGluc2VydGVkIGNvbnRlbnRcbiAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hcHBseUlucHV0UnVsZXMpIHtcbiAgICAgIHRyLnNldE1ldGEoJ2FwcGx5SW5wdXRSdWxlcycsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFwcGx5UGFzdGVSdWxlcykge1xuICAgICAgdHIuc2V0TWV0YSgnYXBwbHlQYXN0ZVJ1bGVzJywgeyBmcm9tLCB0ZXh0OiBuZXdDb250ZW50IH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQge1xuICBqb2luQmFja3dhcmQgYXMgb3JpZ2luYWxKb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duIGFzIG9yaWdpbmFsSm9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkIGFzIG9yaWdpbmFsSm9pbkZvcndhcmQsXG4gIGpvaW5VcCBhcyBvcmlnaW5hbEpvaW5VcCxcbn0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5VcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGggdGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuam9pblVwKClcbiAgICAgICAqL1xuICAgICAgam9pblVwOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5Eb3duOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5qb2luRG93bigpXG4gICAgICAgKi9cbiAgICAgIGpvaW5Eb3duOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5CYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBiZWZvcmUgaXTigJRpZiB0aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuICAgICAgICogSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpbiB0aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0c1xuICAgICAgICogcGFyZW50IG9yIG1vdmluZyBpdCBpbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlIChiaWRpLWF3YXJlKSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmpvaW5CYWNrd2FyZCgpXG4gICAgICAgKi9cbiAgICAgIGpvaW5CYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYWZ0ZXIgaXQsXG4gICAgICAgKiBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXIgYmxvY2sgY2xvc2VyIHRvIHRoaXMgb25lIGluIHRoZSB0cmVlIHN0cnVjdHVyZS5cbiAgICAgICAqIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmpvaW5Gb3J3YXJkKClcbiAgICAgICAqL1xuICAgICAgam9pbkZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5VcDogUmF3Q29tbWFuZHNbJ2pvaW5VcCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pblVwKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Eb3duOiBSYXdDb21tYW5kc1snam9pbkRvd24nXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Eb3duKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5CYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5CYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Gb3J3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gaXRlbXMgYmFja3dhcmQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuam9pbkl0ZW1CYWNrd2FyZCgpXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luSXRlbUJhY2t3YXJkJ10gPSAoKSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBpdGVtcyBGb3J3YXJkcy5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUZvcndhcmQoKVxuICAgICAgICovXG4gICAgICBqb2luSXRlbUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5JdGVtRm9yd2FyZCddID0gKCkgPT4gKHtcbiAgc3RhdGUsXG4gIGRpc3BhdGNoLFxuICB0cixcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsICsxKVxuXG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyLmpvaW4ocG9pbnQsIDIpXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBvcmlnaW5hbENvbW1hbmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblRleHRibG9ja0JhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbW9yZSBsaW1pdGVkIGZvcm0gb2Ygam9pbkJhY2t3YXJkIHRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZSBpdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gICAgICAgKi9cbiAgICAgIGpvaW5UZXh0YmxvY2tCYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pblRleHRibG9ja0JhY2t3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDb21tYW5kKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBqb2luVGV4dGJsb2NrRm9yd2FyZCBhcyBvcmlnaW5hbENvbW1hbmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblRleHRibG9ja0ZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBqb2luRm9yd2FyZCB0aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlciBpdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuICAgICAgICovXG4gICAgICBqb2luVGV4dGJsb2NrRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luVGV4dGJsb2NrRm9yd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ29tbWFuZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTWFjT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgOiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKVxuICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cblxuICBpZiAocmVzdWx0ID09PSAnU3BhY2UnKSB7XG4gICAgcmVzdWx0ID0gJyAnXG4gIH1cblxuICBsZXQgYWx0XG4gIGxldCBjdHJsXG4gIGxldCBzaGlmdFxuICBsZXQgbWV0YVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgbW9kID0gcGFydHNbaV1cblxuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIG1ldGEgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGFsdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGN0cmwgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgc2hpZnQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICBtZXRhID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogJHttb2R9YClcbiAgICB9XG4gIH1cblxuICBpZiAoYWx0KSB7XG4gICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoY3RybCkge1xuICAgIHJlc3VsdCA9IGBDdHJsLSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChtZXRhKSB7XG4gICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGtleWJvYXJkU2hvcnRjdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBhIGtleWJvYXJkIHNob3J0Y3V0LlxuICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleWJvYXJkIHNob3J0Y3V0LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoJ01vZC1iJylcbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRTaG9ydGN1dDogKG5hbWU6IHN0cmluZykgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGtleWJvYXJkU2hvcnRjdXQ6IFJhd0NvbW1hbmRzWydrZXlib2FyZFNob3J0Y3V0J10gPSBuYW1lID0+ICh7XG4gIGVkaXRvcixcbiAgdmlldyxcbiAgdHIsXG4gIGRpc3BhdGNoLFxufSkgPT4ge1xuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLylcbiAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKVxuICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgIGtleToga2V5ID09PSAnU3BhY2UnXG4gICAgICA/ICcgJ1xuICAgICAgOiBrZXksXG4gICAgYWx0S2V5OiBrZXlzLmluY2x1ZGVzKCdBbHQnKSxcbiAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgbWV0YUtleToga2V5cy5pbmNsdWRlcygnTWV0YScpLFxuICAgIHNoaWZ0S2V5OiBrZXlzLmluY2x1ZGVzKCdTaGlmdCcpLFxuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgfSlcblxuICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgdmlldy5zb21lUHJvcCgnaGFuZGxlS2V5RG93bicsIGYgPT4gZih2aWV3LCBldmVudCkpXG4gIH0pXG5cbiAgY2FwdHVyZWRUcmFuc2FjdGlvbj8uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICBjb25zdCBuZXdTdGVwID0gc3RlcC5tYXAodHIubWFwcGluZylcblxuICAgIGlmIChuZXdTdGVwICYmIGRpc3BhdGNoKSB7XG4gICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IE5vZGVSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vZ2V0Tm9kZVR5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogTm9kZVR5cGUgfCBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsXG5cbiAgY29uc3Qgbm9kZVJhbmdlczogTm9kZVJhbmdlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG5cbiAgICBub2RlUmFuZ2VzLnB1c2goe1xuICAgICAgbm9kZSxcbiAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb21cbiAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISFtYXRjaGVkTm9kZVJhbmdlcy5sZW5ndGhcbiAgfVxuXG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZE5vZGVSYW5nZXMucmVkdWNlKChzdW0sIG5vZGVSYW5nZSkgPT4gc3VtICsgbm9kZVJhbmdlLnRvIC0gbm9kZVJhbmdlLmZyb20sIDApXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgbGlmdCBhcyBvcmlnaW5hbExpZnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcCBpZiBwb3NzaWJsZSBsaWZ0aW5nIHRoZSBub2RlIG91dCBvZiBpdFxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmxpZnQoJ3BhcmFncmFwaCcpXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMubGlmdCgnaGVhZGluZycsIHsgbGV2ZWw6IDEgfSlcbiAgICAgICAqL1xuICAgICAgbGlmdDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdDogUmF3Q29tbWFuZHNbJ2xpZnQnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbExpZnQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdEVtcHR5QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZSBibG9jay5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpXG4gICAgICAgKi9cbiAgICAgIGxpZnRFbXB0eUJsb2NrOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdEVtcHR5QmxvY2s6IFJhd0NvbW1hbmRzWydsaWZ0RW1wdHlCbG9jayddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50byBhIHdyYXBwaW5nIGxpc3QuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSgnbGlzdEl0ZW0nKVxuICAgICAgICovXG4gICAgICBsaWZ0TGlzdEl0ZW06ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdExpc3RJdGVtOiBSYXdDb21tYW5kc1snbGlmdExpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsTGlmdExpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBuZXdsaW5lSW5Db2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIG5ld2xpbmUgY2hhcmFjdGVyIGluIGNvZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMubmV3bGluZUluQ29kZSgpXG4gICAgICAgKi9cbiAgICAgIG5ld2xpbmVJbkNvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5ld2xpbmVJbkNvZGU6IFJhd0NvbW1hbmRzWyduZXdsaW5lSW5Db2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxOZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIHNjaGVtYSBpdGVtIGJ5IGl0cyBuYW1lLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYSBpdGVtXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIHRoZSBzY2hlbWEgaXRlbSAoYG5vZGVgIG9yIGBtYXJrYCksIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZTogc3RyaW5nLCBzY2hlbWE6IFNjaGVtYSk6ICdub2RlJyB8ICdtYXJrJyB8IG51bGwge1xuICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgcmV0dXJuICdub2RlJ1xuICB9XG5cbiAgaWYgKHNjaGVtYS5tYXJrc1tuYW1lXSkge1xuICAgIHJldHVybiAnbWFyaydcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHBhcmFtIGtleSBLZXkgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wcyhvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BPclByb3BzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBwcm9wcyA9IHR5cGVvZiBwcm9wT3JQcm9wcyA9PT0gJ3N0cmluZydcbiAgICA/IFtwcm9wT3JQcm9wc11cbiAgICA6IHByb3BPclByb3BzXG5cbiAgcmV0dXJuIE9iamVjdFxuICAgIC5rZXlzKG9iailcbiAgICAucmVkdWNlKChuZXdPYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3ApID0+IHtcbiAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPYmpcbiAgICB9LCB7fSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZGVsZXRlUHJvcHMgfSBmcm9tICcuLi91dGlsaXRpZXMvZGVsZXRlUHJvcHMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICByZXNldEF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVzZXRzIHNvbWUgbm9kZSBhdHRyaWJ1dGVzIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlIHRvIHJlc2V0LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnJlc2V0QXR0cmlidXRlcygnaGVhZGluZycsICdsZXZlbCcpXG4gICAgICAgKi9cbiAgICAgIHJlc2V0QXR0cmlidXRlczogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVzZXRBdHRyaWJ1dGVzOiBSYXdDb21tYW5kc1sncmVzZXRBdHRyaWJ1dGVzJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAqL1xuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY3JvbGxJbnRvVmlldzogUmF3Q29tbWFuZHNbJ3Njcm9sbEludG9WaWV3J10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RBbGw6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKVxuICAgICAgICovXG4gICAgICBzZWxlY3RBbGw6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RBbGw6IFJhd0NvbW1hbmRzWydzZWxlY3RBbGwnXSA9ICgpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiB0ci5kb2MuY29udGVudC5zaXplLFxuICB9KVxufVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3ROb2RlQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBiYWNrd2FyZC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKVxuICAgICAgICovXG4gICAgICBzZWxlY3ROb2RlQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVCYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlRm9yd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVGb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCBhIG5vZGUgZm9yd2FyZC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVGb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3ROb2RlRm9yd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVGb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0UGFyZW50Tm9kZSBhcyBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0UGFyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHBhcmVudCBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFBhcmVudE5vZGUoKVxuICAgICAgICovXG4gICAgICBzZWxlY3RQYXJlbnROb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RQYXJlbnROb2RlOiBSYXdDb21tYW5kc1snc2VsZWN0UGFyZW50Tm9kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFRleHRibG9ja0VuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFRleHRibG9ja0VuZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kOiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrRW5kJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja1N0YXJ0KClcbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0OiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrU3RhcnQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0KHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBDb250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVOb2RlRnJvbUNvbnRlbnQgfSBmcm9tICcuL2NyZWF0ZU5vZGVGcm9tQ29udGVudC5qcydcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgUHJvc2VtaXJyb3IgZG9jdW1lbnQgbm9kZSBmcm9tIGNvbnRlbnQuXG4gKiBAcGFyYW0gY29udGVudCBUaGUgSlNPTiBvciBIVE1MIGNvbnRlbnQgdG8gY3JlYXRlIHRoZSBkb2N1bWVudCBmcm9tXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcnJvciBzY2hlbWEgdG8gdXNlIGZvciB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSBwYXJzZU9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHBhcnNlclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgUHJvc2VtaXJyb3IgZG9jdW1lbnQgbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBwYXJzZU9wdGlvbnM6IFBhcnNlT3B0aW9ucyA9IHt9LFxuKTogUHJvc2VNaXJyb3JOb2RlIHtcbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHsgc2xpY2U6IGZhbHNlLCBwYXJzZU9wdGlvbnMgfSkgYXMgUHJvc2VNaXJyb3JOb2RlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQgd2l0aCBuZXcgY29udGVudC5cbiAgICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBuZXcgY29udGVudC5cbiAgICAgICAqIEBwYXJhbSBlbWl0VXBkYXRlIFdoZXRoZXIgdG8gZW1pdCBhbiB1cGRhdGUgZXZlbnQuXG4gICAgICAgKiBAcGFyYW0gcGFyc2VPcHRpb25zIE9wdGlvbnMgZm9yIHBhcnNpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0Q29udGVudCgnPHA+RXhhbXBsZSB0ZXh0PC9wPicpXG4gICAgICAgKi9cbiAgICAgIHNldENvbnRlbnQ6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuZXcgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnQ6IENvbnRlbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gZW1pdCBhbiB1cGRhdGUgZXZlbnQuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBlbWl0VXBkYXRlPzogYm9vbGVhbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9ucyBmb3IgcGFyc2luZyB0aGUgY29udGVudC5cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9ucyxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Q29udGVudDogUmF3Q29tbWFuZHNbJ3NldENvbnRlbnQnXSA9IChjb250ZW50LCBlbWl0VXBkYXRlID0gZmFsc2UsIHBhcnNlT3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgZWRpdG9yLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZG9jIH0gPSB0clxuICBjb25zdCBkb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucylcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBkb2N1bWVudCkuc2V0TWV0YSgncHJldmVudFVwZGF0ZScsICFlbWl0VXBkYXRlKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi9nZXRNYXJrVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgbWFya3M6IE1hcmtbXSA9IFtdXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKVxuICAgIH1cblxuICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBtYXJrcy5maW5kKG1hcmtJdGVtID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBgVHJhbnNmb3JtYCBiYXNlZCBvbiBhbGwgc3RlcHMgb2YgdGhlIHBhc3NlZCB0cmFuc2FjdGlvbnMuXG4gKiBAcGFyYW0gb2xkRG9jIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVGhlIHRyYW5zYWN0aW9ucyB0byBjb21iaW5lXG4gKiBAcmV0dXJucyBBIG5ldyBgVHJhbnNmb3JtYCB3aXRoIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMoXG4gIG9sZERvYzogUHJvc2VNaXJyb3JOb2RlLFxuICB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10sXG4pOiBUcmFuc2Zvcm0ge1xuICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYylcblxuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJhbnNmb3JtXG59XG4iLCAiaW1wb3J0IHsgQ29udGVudE1hdGNoLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBibG9jayB0eXBlIGF0IGEgZ2l2ZW4gbWF0Y2hcbiAqIEBwYXJhbSBtYXRjaCBUaGUgY29udGVudCBtYXRjaCB0byBnZXQgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBmcm9tXG4gKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBibG9jayB0eXBlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoOiBDb250ZW50TWF0Y2gpOiBOb2RlVHlwZSB8IG51bGwge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpXG5cbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBGaW5kIGNoaWxkcmVuIGluc2lkZSBhIFByb3NlbWlycm9yIG5vZGUgdGhhdCBtYXRjaCBhIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSBub2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgcHJlZGljYXRlOiBQcmVkaWNhdGUpOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUsIFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICByYW5nZTogUmFuZ2UsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTogTm9kZVdpdGhQb3NbXSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvczogTm9kZVdpdGhQb3NbXSA9IFtdXG5cbiAgLy8gaWYgKHJhbmdlLmZyb20gPT09IHJhbmdlLnRvKSB7XG4gIC8vICAgY29uc3Qgbm9kZUF0ID0gbm9kZS5ub2RlQXQocmFuZ2UuZnJvbSlcblxuICAvLyAgIGlmIChub2RlQXQpIHtcbiAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgLy8gICAgICAgbm9kZTogbm9kZUF0LFxuICAvLyAgICAgICBwb3M6IHJhbmdlLmZyb20sXG4gIC8vICAgICB9KVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3MsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbm9kZXNXaXRoUG9zXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gYSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJGZyb20sIG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTpcbiAgfCB7XG4gICAgICBwb3M6IG51bWJlclxuICAgICAgc3RhcnQ6IG51bWJlclxuICAgICAgZGVwdGg6IG51bWJlclxuICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKVxuXG4gICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgc3RhcnQ6ICRwb3Muc3RhcnQoaSksXG4gICAgICAgIGRlcHRoOiBpLFxuICAgICAgICBub2RlLFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLmpzJ1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIEEgY29tbWFuZCB0aGF0IGZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxuICogQGV4YW1wbGUgYGBganNcbiAqIGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGU6IFByZWRpY2F0ZSkge1xuICByZXR1cm4gKHNlbGVjdGlvbjogU2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSlcbn1cbiIsICJpbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUTUxGcm9tRnJhZ21lbnQoZnJhZ21lbnQ6IEZyYWdtZW50LCBzY2hlbWE6IFNjaGVtYSk6IHN0cmluZyB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudClcblxuICBjb25zdCB0ZW1wb3JhcnlEb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpXG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpXG5cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcblxuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbi8qKlxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcbiAqIEBwYXJhbSBkb2MgVGhlIEpTT05Db250ZW50IHRvIGdlbmVyYXRlIEhUTUwgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2M6IEpTT05Db250ZW50LCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogc3RyaW5nIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpXG59XG4iLCAiaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcblxuLyoqXG4gKiBHZW5lcmF0ZSBKU09OQ29udGVudCBmcm9tIEhUTUxcbiAqIEBwYXJhbSBodG1sIFRoZSBIVE1MIHRvIGdlbmVyYXRlIEpTT05Db250ZW50IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBKU09OQ29udGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVKU09OKGh0bWw6IHN0cmluZywgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucylcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbClcblxuICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dEJldHdlZW4gfSBmcm9tICcuL2dldFRleHRCZXR3ZWVuLmpzJ1xuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYSBQcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxuICogQHJldHVybnMgVGhlIHRleHQgb2YgdGhlIG5vZGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBjb25zdCB0ZXh0ID0gZ2V0VGV4dChub2RlLCB7IGJsb2NrU2VwYXJhdG9yOiAnXFxuJyB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0KFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbikge1xuICBjb25zdCByYW5nZSA9IHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZSxcbiAgfVxuXG4gIHJldHVybiBnZXRUZXh0QmV0d2Vlbihub2RlLCByYW5nZSwgb3B0aW9ucylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucywgSlNPTkNvbnRlbnQsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcbmltcG9ydCB7IGdldFRleHQgfSBmcm9tICcuL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuXG4vKipcbiAqIEdlbmVyYXRlIHJhdyB0ZXh0IGZyb20gYSBKU09OQ29udGVudFxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgdGV4dCBmcm9tXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9ucyB0byB1c2UgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IGdlbmVyYXRpb24gZi5lLiBibG9ja1NlcGFyYXRvciBvciB0ZXh0U2VyaWFsaXplcnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KFxuICBkb2M6IEpTT05Db250ZW50LFxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpXG5cbiAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcbiAgICBibG9ja1NlcGFyYXRvcixcbiAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgfSlcblxuICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpXG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4geyAuLi5ub2RlLmF0dHJzIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0Tm9kZUF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5cbi8qKlxuICogR2V0IG5vZGUgb3IgbWFyayBhdHRyaWJ1dGVzIGJ5IHR5cGUgb3IgbmFtZSBvbiB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGVcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGVcbiAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBub2RlIG9yIG1hcmsgdHlwZSBvciBuYW1lXG4gKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrIG9yIGFuIGVtcHR5IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTm9kZVR5cGUpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lIGFzIE1hcmtUeXBlKVxuICB9XG5cbiAgcmV0dXJuIHt9XG59XG4iLCAiLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgdmFsdWVzIHdpdGhpbiBhbiBhcnJheS5cbiAqIFN1cHBvcnRzIG51bWJlcnMsIHN0cmluZ3MgYW5kIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzPFQ+KGFycmF5OiBUW10sIGJ5ID0gSlNPTi5zdHJpbmdpZnkpOiBUW10ge1xuICBjb25zdCBzZWVuOiBSZWNvcmQ8YW55LCBhbnk+ID0ge31cblxuICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pXG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlZW4sIGtleSlcbiAgICAgID8gZmFsc2VcbiAgICAgIDogKHNlZW5ba2V5XSA9IHRydWUpXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyByZW1vdmVEdXBsaWNhdGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMuanMnXG5cbmV4cG9ydCB0eXBlIENoYW5nZWRSYW5nZSA9IHtcbiAgb2xkUmFuZ2U6IFJhbmdlLFxuICBuZXdSYW5nZTogUmFuZ2UsXG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHJhbmdlcyBhbmQgcmFuZ2VzIHRoYXQgYXJlXG4gKiBmdWxseSBjYXB0dXJlZCBieSBvdGhlciByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgdW5pcXVlQ2hhbmdlcyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2hhbmdlcylcblxuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICA/IHVuaXF1ZUNoYW5nZXNcbiAgICA6IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChjaGFuZ2UsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuXG4gICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvXG4gICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UuZnJvbVxuICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50b1xuICAgICAgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5nZWQgcmFuZ2VzXG4gKiBiYXNlZCBvbiB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGUgb2YgYWxsIHN0ZXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IENoYW5nZWRSYW5nZVtdIHtcbiAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtXG4gIGNvbnN0IGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdID0gW11cblxuICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByYW5nZXM6IFJhbmdlW10gPSBbXVxuXG4gICAgLy8gVGhpcyBhY2NvdW50cyBmb3Igc3RlcCBjaGFuZ2VzIHdoZXJlIG5vIHJhbmdlIHdhcyBhY3R1YWxseSBhbHRlcmVkXG4gICAgLy8gZS5nLiB3aGVuIHNldHRpbmcgYSBtYXJrLCBub2RlIGF0dHJpYnV0ZSwgZXRjLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdIGFzIFN0ZXAgJiB7XG4gICAgICAgIGZyb20/OiBudW1iZXIsXG4gICAgICAgIHRvPzogbnVtYmVyLFxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcE1hcC5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKVxuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKVxuICAgICAgY29uc3Qgb2xkU3RhcnQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdTdGFydCwgLTEpXG4gICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpXG5cbiAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgIG9sZFJhbmdlOiB7XG4gICAgICAgICAgZnJvbTogb2xkU3RhcnQsXG4gICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmludGVyZmFjZSBEZWJ1Z0pTT05Db250ZW50IGV4dGVuZHMgSlNPTkNvbnRlbnQge1xuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgc3RhcnRPZmZzZXQgPSAwKTogRGVidWdKU09OQ29udGVudCB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZVxuICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMVxuICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXRcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZVxuICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgIGNvbnN0IG91dHB1dDogeyB0eXBlOiBzdHJpbmc7IGF0dHJzPzogUmVjb3JkPHN0cmluZywgYW55PiB9ID0ge1xuICAgICAgdHlwZTogbWFyay50eXBlLm5hbWUsXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0pXG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH1cbiAgY29uc3Qgb3V0cHV0OiBEZWJ1Z0pTT05Db250ZW50ID0ge1xuICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgIG91dHB1dC5hdHRycyA9IGF0dHJzXG4gIH1cblxuICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgb3V0cHV0Lm1hcmtzID0gbWFya3NcbiAgfVxuXG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW11cblxuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgb3V0cHV0LmNvbnRlbnQ/LnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuL2dldE1hcmtSYW5nZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGRvYzogUHJvc2VNaXJyb3JOb2RlKTogTWFya1JhbmdlW10ge1xuICBjb25zdCBtYXJrczogTWFya1JhbmdlW10gPSBbXVxuXG4gIC8vIGdldCBhbGwgaW5jbHVzaXZlIG1hcmtzIG9uIGVtcHR5IHNlbGVjdGlvblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICBkb2NcbiAgICAgIC5yZXNvbHZlKGZyb20pXG4gICAgICAubWFya3MoKVxuICAgICAgLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tIC0gMSlcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKVxuXG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgLi4ucmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZSB8fCBub2RlPy5ub2RlU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgIG1hcmssXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG1hcmtzXG59XG4iLCAiaW1wb3J0IHsgTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVBdFBvc2l0aW9uID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIHBvczogbnVtYmVyLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpXG5cbiAgbGV0IGN1cnJlbnREZXB0aCA9IG1heERlcHRoXG4gIGxldCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSAkcG9zLm5vZGUoY3VycmVudERlcHRoKVxuXG4gICAgaWYgKGN1cnJlbnROb2RlPy50eXBlLm5hbWUgPT09IHR5cGVPck5hbWUpIHtcbiAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbm9kZSwgY3VycmVudERlcHRoXSBhcyBbTm9kZSB8IG51bGwsIG51bWJlcl1cbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBSZXR1cm4gYXR0cmlidXRlcyBvZiBhbiBleHRlbnNpb24gdGhhdCBzaG91bGQgYmUgc3BsaXR0ZWQgYnkga2VlcE9uU3BsaXQgZmxhZ1xuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgQXJyYXkgb2YgZXh0ZW5zaW9uIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgdHlwZSBvZiB0aGUgZXh0ZW5zaW9uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgZXh0ZW5zaW9uXG4gKiBAcmV0dXJucyBUaGUgc3BsaXR0ZWQgYXR0cmlidXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdFxuICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0XG4gICAgfSkpXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXJrQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE1hcmtUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWVcbiAgICAgIH0pXG4gICAgICAuZmluZChtYXJrID0+IG9iamVjdEluY2x1ZGVzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgfVxuXG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IDBcbiAgY29uc3QgbWFya1JhbmdlczogTWFya1JhbmdlW10gPSBbXVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3NcbiAgICBjb25zdCB0byA9ICR0by5wb3NcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG4gICAgICBjb25zdCByYW5nZSA9IHJlbGF0aXZlVG8gLSByZWxhdGl2ZUZyb21cblxuICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2VcblxuICAgICAgbWFya1Jhbmdlcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xuICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hcmtzIHRoYXQgZXhjbHVkZXMgdGhlIHNlYXJjaGVkIG1hcmtcbiAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcbiAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKVxuICAgIH0pXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxuICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4vaXNOb2RlQWN0aXZlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlLmpzJ1xuXG5leHBvcnQgY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIG5vZGVUeXBlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpXG5cbiAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpc3QobmFtZTogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICB9XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpXG5cbiAgaWYgKHR5cGVvZiBncm91cCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVFbXB0eShub2RlOiBQcm9zZU1pcnJvck5vZGUpOiBib29sZWFuIHtcbiAgY29uc3QgZGVmYXVsdENvbnRlbnQgPSBub2RlLnR5cGUuY3JlYXRlQW5kRmlsbCgpPy50b0pTT04oKVxuICBjb25zdCBjb250ZW50ID0gbm9kZS50b0pTT04oKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlU2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvblxufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogRE9NUmVjdCB7XG4gIGNvbnN0IG1pblBvcyA9IDBcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplXG4gIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKVxuICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSlcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKVxuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pXG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdClcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KVxuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdFxuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgY29uc3QgeCA9IGxlZnRcbiAgY29uc3QgeSA9IHRvcFxuICBjb25zdCBkYXRhID0ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbWFyayB3aXRoIG5ldyBhdHRyaWJ1dGVzLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG1hcmsgdHlwZSBvciBuYW1lLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldE1hcmsoJ2JvbGQnLCB7IGxldmVsOiAxIH0pXG4gICAgICAgKi9cbiAgICAgIHNldE1hcms6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuU2V0TWFyayhzdGF0ZTogRWRpdG9yU3RhdGUsIHRyOiBUcmFuc2FjdGlvbiwgbmV3TWFya1R5cGU6IE1hcmtUeXBlKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBsZXQgY3Vyc29yOiBSZXNvbHZlZFBvcyB8IG51bGwgPSBudWxsXG5cbiAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY3Vyc29yID0gc2VsZWN0aW9uLiRjdXJzb3JcbiAgfVxuXG4gIGlmIChjdXJzb3IpIHtcbiAgICBjb25zdCBjdXJyZW50TWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyA/PyBjdXJzb3IubWFya3MoKVxuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgIHJldHVybiAoXG4gICAgICAhIW5ld01hcmtUeXBlLmlzSW5TZXQoY3VycmVudE1hcmtzKVxuICAgICAgfHwgIWN1cnJlbnRNYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSlcbiAgICApXG4gIH1cblxuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgOiBmYWxzZVxuXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBtYXJrIHRoYXQgd2UgY2FuIGVuYWJsZSwgcmV0dXJuIGZhbHNlIHRvIGJ5cGFzcyB0aGUgcmVtYWluaW5nIHNlYXJjaFxuICAgICAgaWYgKHNvbWVOb2RlU3VwcG9ydHNNYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5pc0lubGluZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUgPSAhIW5ld01hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcylcbiAgICAgICAgICB8fCAhbm9kZS5tYXJrcy5zb21lKG90aGVyTWFyayA9PiBvdGhlck1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG5cbiAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlXG4gICAgICB9XG4gICAgICByZXR1cm4gIXNvbWVOb2RlU3VwcG9ydHNNYXJrXG4gICAgfSlcblxuICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFya1xuICB9KVxufVxuZXhwb3J0IGNvbnN0IHNldE1hcms6IFJhd0NvbW1hbmRzWydzZXRNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGUpXG5cbiAgICAgIHRyLmFkZFN0b3JlZE1hcmsoXG4gICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIG1hcmsgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHdlIGhhdmUgdG8gbWVyZ2UgaXRzIGF0dHJpYnV0ZXNcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSlcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWV0YToge1xuICAgICAgLyoqXG4gICAgICAgKiBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLlxuICAgICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBtZXRhZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0TWV0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgKi9cbiAgICAgIHNldE1ldGE6IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE1ldGE6IFJhd0NvbW1hbmRzWydzZXRNZXRhJ10gPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICB0ci5zZXRNZXRhKGtleSwgdmFsdWUpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBzZXRCbG9ja1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldE5vZGUoJ3BhcmFncmFwaCcpXG4gICAgICAgKi9cbiAgICAgIHNldE5vZGU6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGU6IFJhd0NvbW1hbmRzWydzZXROb2RlJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICAvLyBUT0RPOiB1c2UgYSBmYWxsYmFjayBsaWtlIGluc2VydENvbnRlbnQ/XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykge1xuICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgY2hhaW4oKVxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBjYW5TZXRCbG9jayA9IHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSlcblxuICAgICAgICBpZiAoY2FuU2V0QmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC5jb21tYW5kKCh7IHN0YXRlOiB1cGRhdGVkU3RhdGUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHVwZGF0ZWRTdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9KVxuICAgICAgLnJ1bigpXG4gIClcbn1cbiIsICJpbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlU2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBOb2RlU2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIC0gUG9zaXRpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0Tm9kZVNlbGVjdGlvbigxMClcbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZVNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXROb2RlU2VsZWN0aW9uJ10gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSlcblxuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRUZXh0U2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZXh0U2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oMTApXG4gICAgICAgKi9cbiAgICAgIHNldFRleHRTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFRleHRTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXRUZXh0U2VsZWN0aW9uJ10gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvblxuICAgIGNvbnN0IG1pblBvcyA9IFRleHRTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb21cbiAgICBjb25zdCBtYXhQb3MgPSBUZXh0U2VsZWN0aW9uLmF0RW5kKGRvYykudG9cbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpXG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmVzb2x2ZWRGcm9tLCByZXNvbHZlZEVuZClcblxuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IHNpbmtMaXN0SXRlbSBhcyBvcmlnaW5hbFNpbmtMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzaW5rTGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU2luayB0aGUgbGlzdCBpdGVtIGRvd24gaW50byBhbiBpbm5lciBsaXN0LlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0oJ2xpc3RJdGVtJylcbiAgICAgICAqL1xuICAgICAgc2lua0xpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNpbmtMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ3NpbmtMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFNpbmtMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZGVmYXVsdEJsb2NrQXQgfSBmcm9tICcuLi9oZWxwZXJzL2RlZmF1bHRCbG9ja0F0LmpzJ1xuaW1wb3J0IHsgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZTogRWRpdG9yU3RhdGUsIHNwbGl0dGFibGVNYXJrcz86IHN0cmluZ1tdKSB7XG4gIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gIGlmIChtYXJrcykge1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3M/LmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gIH1cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogRm9ya3MgYSBuZXcgbm9kZSBmcm9tIGFuIGV4aXN0aW5nIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gb3B0aW9ucy5rZWVwTWFya3MgS2VlcCBtYXJrcyBmcm9tIHRoZSBwcmV2aW91cyBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNwbGl0QmxvY2soKVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNwbGl0QmxvY2soeyBrZWVwTWFya3M6IHRydWUgfSlcbiAgICAgICAqL1xuICAgICAgc3BsaXRCbG9jazogKG9wdGlvbnM/OiB7IGtlZXBNYXJrcz86IGJvb2xlYW4gfSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BsaXRCbG9jazogUmF3Q29tbWFuZHNbJ3NwbGl0QmxvY2snXSA9ICh7IGtlZXBNYXJrcyA9IHRydWUgfSA9IHt9KSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcylcbiAgICAgIH1cblxuICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PT0gJHRvLnBhcmVudC5jb250ZW50LnNpemVcblxuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmx0ID0gJGZyb20uZGVwdGggPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSlcblxuICAgIGxldCB0eXBlcyA9IGF0RW5kICYmIGRlZmx0XG4gICAgICA/IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICB9LFxuICAgICAgXVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgaWYgKFxuICAgICAgIXR5cGVzXG4gICAgICAgICYmICFjYW5cbiAgICAgICAgJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKVxuICAgICkge1xuICAgICAgY2FuID0gdHJ1ZVxuICAgICAgdHlwZXMgPSBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoY2FuKSB7XG4gICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcylcblxuICAgICAgaWYgKGRlZmx0ICYmICFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9PSBkZWZsdCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKVxuICAgICAgICBjb25zdCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdClcblxuICAgICAgICBpZiAoJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcylcbiAgICB9XG5cbiAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7XG4gIEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVR5cGUsIFNsaWNlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdExpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwbGl0cyBvbmUgbGlzdCBpdGVtIGludG8gdHdvIGxpc3QgaXRlbXMuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0oJ2xpc3RJdGVtJylcbiAgICAgICAqL1xuICAgICAgc3BsaXRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdExpc3RJdGVtOiBSYXdDb21tYW5kc1snc3BsaXRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjb25zdCBub2RlOiBQcm9zZU1pcnJvck5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZVxuXG4gIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpXG5cbiAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG5cbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgaWYgKFxuICAgICAgJGZyb20uZGVwdGggPT09IDJcbiAgICAgICAgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZVxuICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogM1xuXG4gICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpXG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzXG5cbiAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAgICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAgICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICAgICAgKVxuICAgICAgY29uc3QgbmV4dFR5cGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpIHx8IHVuZGVmaW5lZFxuXG4gICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpXG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpXG5cbiAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpXG5cbiAgICAgIGxldCBzZWwgPSAtMVxuXG4gICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICBzZWwgPSBwb3MgKyAxXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGxcblxuICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgIGdyYW5kUGFyZW50LnR5cGUubmFtZSxcbiAgICBncmFuZFBhcmVudC5hdHRycyxcbiAgKVxuICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpXG5cbiAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgID8gW1xuICAgICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICBdXG4gICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV1cblxuICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi4vaGVscGVycy9maW5kUGFyZW50Tm9kZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTGlzdCB9IGZyb20gJy4uL2hlbHBlcnMvaXNMaXN0LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aClcblxuICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUJlZm9yZSA9IHRyLmRvYy5ub2RlQXQoYmVmb3JlKVxuICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVCZWZvcmU/LnR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKVxuXG4gIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGxpc3QucG9zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGpvaW5MaXN0Rm9yd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpXG5cbiAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcilcbiAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVBZnRlcj8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpXG5cbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdHIuam9pbihhZnRlcilcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgbGlzdCB0eXBlcy5cbiAgICAgICAqIEBwYXJhbSBsaXN0VHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBsaXN0LlxuICAgICAgICogQHBhcmFtIGl0ZW1UeXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIGxpc3QgaXRlbS5cbiAgICAgICAqIEBwYXJhbSBrZWVwTWFya3MgS2VlcCBtYXJrcyB3aGVuIHRvZ2dsaW5nLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgQXR0cmlidXRlcyBmb3IgdGhlIG5ldyBsaXN0LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUxpc3QoJ2J1bGxldExpc3QnLCAnbGlzdEl0ZW0nKVxuICAgICAgICovXG4gICAgICB0b2dnbGVMaXN0OiAobGlzdFR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBpdGVtVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGtlZXBNYXJrcz86IGJvb2xlYW4sIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTGlzdDogUmF3Q29tbWFuZHNbJ3RvZ2dsZUxpc3QnXSA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoe1xuICBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLFxufSkgPT4ge1xuICBjb25zdCB7IGV4dGVuc2lvbnMsIHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bylcblxuICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pXG5cbiAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSlcbiAgICB9XG5cbiAgICAvLyBjaGFuZ2UgbGlzdCB0eXBlXG4gICAgaWYgKFxuICAgICAgaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpXG4gICAgICAgICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudClcbiAgICAgICAgJiYgZGlzcGF0Y2hcbiAgICApIHtcbiAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudExpc3QucG9zLCBsaXN0VHlwZSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLnJ1bigpXG4gICAgfVxuICB9XG4gIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcblxuICAgIHJldHVybiBjaGFpbigpXG4gICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICApXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG1hcmsgb24gYW5kIG9mZi5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBtYXJrIHR5cGUgb3IgbmFtZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrLlxuICAgICAgICogQHBhcmFtIG9wdGlvbnMuZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlTWFyaygnYm9sZCcpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU1hcms6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXJrIHR5cGUgb3IgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbWFyay5cbiAgICAgICAgICovXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU1hcms6IFJhd0NvbW1hbmRzWyd0b2dnbGVNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHR5cGUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgfSlcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG5vZGUgd2l0aCBhbm90aGVyIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIHRvZ2dsZVR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZSB0byB0b2dnbGUuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVOb2RlKCdoZWFkaW5nJywgJ3BhcmFncmFwaCcpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU5vZGU6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIHRvZ2dsZVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTm9kZTogUmF3Q29tbWFuZHNbJ3RvZ2dsZU5vZGUnXSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlV3JhcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUsIG9yIHJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcC5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVXcmFwKCdibG9ja3F1b3RlJylcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlV3JhcDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlV3JhcDogUmF3Q29tbWFuZHNbJ3RvZ2dsZVdyYXAnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMud3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZG9JbnB1dFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyBhbiBpbnB1dCBydWxlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKVxuICAgICAgICovXG4gICAgICB1bmRvSW5wdXRSdWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5kb0lucHV0UnVsZTogUmF3Q29tbWFuZHNbJ3VuZG9JbnB1dFJ1bGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXVxuICAgIGxldCB1bmRvYWJsZVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyXG4gICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybVxuXG4gICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZG9hYmxlLnRleHQpIHtcbiAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKClcblxuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0QWxsTWFya3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBtYXJrcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRBbGxNYXJrcygpXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QWxsTWFya3M6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldEFsbE1hcmtzOiBSYXdDb21tYW5kc1sndW5zZXRBbGxNYXJrcyddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5zZXRNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG1hcmsgdHlwZSBvciBuYW1lLlxuICAgICAgICogQHBhcmFtIG9wdGlvbnMuZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRNYXJrKCdib2xkJylcbiAgICAgICAqL1xuICAgICAgdW5zZXRNYXJrOiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFyayB0eXBlIG9yIG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcblxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldE1hcms6IFJhd0NvbW1hbmRzWyd1bnNldE1hcmsnXSA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuICAgIGNvbnN0IGF0dHJzID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKT8uYXR0cnNcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpXG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGZyb20gPSByYW5nZS5mcm9tXG4gICAgICB0byA9IHJhbmdlLnRvXG4gICAgfVxuXG4gICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSlcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgdHlwZSlcbiAgICB9KVxuICB9XG5cbiAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb2YgYSBub2RlIG9yIG1hcmsuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVwZGF0ZUF0dHJpYnV0ZXMoJ21lbnRpb24nLCB7IHVzZXJJZDogXCIyXCIgfSlcbiAgICAgICAqL1xuICAgICAgdXBkYXRlQXR0cmlidXRlczogKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFyay5cbiAgICAgICAgICovXG4gICAgICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUF0dHJpYnV0ZXM6IFJhd0NvbW1hbmRzWyd1cGRhdGVBdHRyaWJ1dGVzJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgbGV0IG5vZGVUeXBlOiBOb2RlVHlwZSB8IG51bGwgPSBudWxsXG4gIGxldCBtYXJrVHlwZTogTWFya1R5cGUgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYSxcbiAgKVxuXG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSBhcyBOb2RlVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSBhcyBNYXJrVHlwZSwgc3RhdGUuc2NoZW1hKVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcblxuICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tLFxuICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IHdyYXBJbiBhcyBvcmlnaW5hbFdyYXBJbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB3cmFwSW46IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgbm9kZXMgaW4gYW5vdGhlciBub2RlLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLndyYXBJbignYmxvY2txdW90ZScpXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbjogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluOiBSYXdDb21tYW5kc1snd3JhcEluJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgd3JhcEluTGlzdCBhcyBvcmlnaW5hbFdyYXBJbkxpc3QgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGEgbm9kZSBpbiBhIGxpc3QuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMud3JhcEluTGlzdCgnYnVsbGV0TGlzdCcpXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbkxpc3Q6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbkxpc3Q6IFJhd0NvbW1hbmRzWyd3cmFwSW5MaXN0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbkxpc3QodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCAqIGFzIGNvbW1hbmRzIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcblxuZXhwb3J0IGNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjb21tYW5kcycsXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1hbmRzLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZWRpdGFibGUnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBGb2N1c0V2ZW50cyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYmx1cicsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZXhwb3J0IGNvbnN0IEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAna2V5bWFwJyxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBoYW5kbGVCYWNrc3BhY2UgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXG5cbiAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCB7IHBvcywgcGFyZW50IH0gPSAkYW5jaG9yXG4gICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayAmJiBwb3MgPiAwID8gdHIuZG9jLnJlc29sdmUocG9zIC0gMSkgOiAkYW5jaG9yXG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZ1xuXG4gICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXRcblxuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAocGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSlcbiAgICAgICAgICA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3NcbiAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFlbXB0eVxuICAgICAgICAgIHx8ICFwYXJlbnQudHlwZS5pc1RleHRibG9ja1xuICAgICAgICAgIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGhcbiAgICAgICAgICB8fCAhaXNBdFN0YXJ0XG4gICAgICAgICAgfHwgKGlzQXRTdGFydCAmJiAkYW5jaG9yLnBhcmVudC50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKSAvLyBwcmV2ZW50IGNsZWFyTm9kZXMgd2hlbiBubyBub2RlcyB0byBjbGVhciwgb3RoZXJ3aXNlIGhpc3Rvcnkgc3RhY2sgaXMgYXBwZW5kZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KSxcblxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxuICAgIF0pXG5cbiAgICBjb25zdCBoYW5kbGVEZWxldGUgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZUN1cnJlbnROb2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luRm9yd2FyZCgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUZvcndhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgIF0pXG5cbiAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ1NoaWZ0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnTW9kLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKSxcbiAgICB9XG5cbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgfVxuXG4gICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICB9XG5cbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXBcbiAgICB9XG5cbiAgICByZXR1cm4gcGNLZXltYXBcbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xlYXJEb2N1bWVudCcpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYylcblxuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24uYXRTdGFydChvbGRTdGF0ZS5kb2MpLmZyb21cbiAgICAgICAgICBjb25zdCBhbGxFbmQgPSBTZWxlY3Rpb24uYXRFbmQob2xkU3RhdGUuZG9jKS50b1xuICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kXG5cbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKDAsIG5ld1N0YXRlLmRvYy5jb250ZW50LnNpemUsICcgJywgJyAnKS5sZW5ndGggPT09IDBcblxuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50clxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpXG5cbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRyXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ3RhYmluZGV4JyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYXR0cmlidXRlczogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSA/IHsgdGFiaW5kZXg6ICcwJyB9IDoge30sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIEZyYWdtZW50LCBOb2RlLCBSZXNvbHZlZFBvcyxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYW5nZSB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBOb2RlUG9zIHtcbiAgcHJpdmF0ZSByZXNvbHZlZFBvczogUmVzb2x2ZWRQb3NcblxuICBwcml2YXRlIGlzQmxvY2s6IGJvb2xlYW5cblxuICBwcml2YXRlIGVkaXRvcjogRWRpdG9yXG5cbiAgcHJpdmF0ZSBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwb3M6IFJlc29sdmVkUG9zLCBlZGl0b3I6IEVkaXRvciwgaXNCbG9jayA9IGZhbHNlLCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGwpIHtcbiAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrXG4gICAgdGhpcy5yZXNvbHZlZFBvcyA9IHBvc1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGVcbiAgfVxuXG4gIHByaXZhdGUgY3VycmVudE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGdldCBub2RlKCk6IE5vZGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMucmVzb2x2ZWRQb3Mubm9kZSgpXG4gIH1cblxuICBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHB1YmxpYyBhY3R1YWxEZXB0aDogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBnZXQgZGVwdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5hY3R1YWxEZXB0aCA/PyB0aGlzLnJlc29sdmVkUG9zLmRlcHRoXG4gIH1cblxuICBnZXQgcG9zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zXG4gIH1cblxuICBnZXQgY29udGVudCgpOiBGcmFnbWVudCB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50XG4gIH1cblxuICBzZXQgY29udGVudChjb250ZW50OiBDb250ZW50KSB7XG4gICAgbGV0IGZyb20gPSB0aGlzLmZyb21cbiAgICBsZXQgdG8gPSB0aGlzLnRvXG5cbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZnJvbSA9IHRoaXMuZnJvbSArIDFcbiAgICAgIHRvID0gdGhpcy50byAtIDFcbiAgICB9XG5cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tLCB0byB9LCBjb250ZW50KVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5hdHRyc1xuICB9XG5cbiAgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudFxuICB9XG5cbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplXG4gIH1cblxuICBnZXQgZnJvbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpXG4gIH1cblxuICBnZXQgcmFuZ2UoKTogUmFuZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICB0bzogdGhpcy50byxcbiAgICB9XG4gIH1cblxuICBnZXQgdG8oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5lbmQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCkgKyAodGhpcy5ub2RlLmlzVGV4dCA/IDAgOiAxKVxuICB9XG5cbiAgZ2V0IHBhcmVudCgpOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuZGVwdGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50UG9zID0gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoIC0gMSlcbiAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZShwYXJlbnRQb3MpXG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpXG4gIH1cblxuICBnZXQgYmVmb3JlKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gKHRoaXMuaXNCbG9jayA/IDEgOiAyKSlcblxuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAzKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcilcbiAgfVxuXG4gIGdldCBhZnRlcigpOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAodGhpcy5pc0Jsb2NrID8gMiA6IDEpKVxuXG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAzKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcilcbiAgfVxuXG4gIGdldCBjaGlsZHJlbigpOiBOb2RlUG9zW10ge1xuICAgIGNvbnN0IGNoaWxkcmVuOiBOb2RlUG9zW10gPSBbXVxuXG4gICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrXG5cbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgMVxuICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGFyZ2V0UG9zKVxuXG4gICAgICBpZiAoIWlzQmxvY2sgJiYgJHBvcy5kZXB0aCA8PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZE5vZGVQb3MgPSBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKVxuXG4gICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICAgICAgfVxuXG4gICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxuXG4gIGdldCBmaXJzdENoaWxkKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsXG4gIH1cblxuICBnZXQgbGFzdENoaWxkKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cblxuICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsXG4gIH1cblxuICBjbG9zZXN0KHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBsZXQgbm9kZTogTm9kZVBvcyB8IG51bGwgPSBudWxsXG4gICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnRcblxuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRyc1xuICAgICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylcblxuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyS2V5cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF0dHJLZXlzW2luZGV4XVxuXG4gICAgICAgICAgICBpZiAobm9kZUF0dHJpYnV0ZXNba2V5XSAhPT0gYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGxcbiAgfVxuXG4gIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9LCBmaXJzdEl0ZW1Pbmx5ID0gZmFsc2UpOiBOb2RlUG9zW10ge1xuICAgIGxldCBub2RlczogTm9kZVBvc1tdID0gW11cblxuICAgIGlmICghdGhpcy5jaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvciBhbmQgYXR0cmlidXRlc1xuICAgICAqIElmIGZpcnN0SXRlbU9ubHkgaXMgdHJ1ZSwgaXQgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGl0ZW0gZm91bmRcbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGRQb3MgPT4ge1xuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgZG9udCBuZWVkIHRvIGtlZXAgZ29pbmdcbiAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZFBvcy5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KGtleSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IGNoaWxkUG9zLm5vZGUuYXR0cnNba2V5XSlcblxuICAgICAgICBpZiAoZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGRQb3MpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgY2FuIHN0b3AgaGVyZSBhbmQgc2tpcCB0aGUgcmVjdXJzaW9uXG4gICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBmaXJzdEl0ZW1Pbmx5KSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgIGNvbnN0IG9sZFNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuXG4gICAgdGhpcy5lZGl0b3IuY2hhaW4oKS5zZXRUZXh0U2VsZWN0aW9uKHRoaXMuZnJvbSkudXBkYXRlQXR0cmlidXRlcyh0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRUZXh0U2VsZWN0aW9uKG9sZFNlbGVjdGlvbi5mcm9tKVxuICAgICAgLnJ1bigpXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDFweCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5dIHtcbiAgb3BhY2l0eTogMFxufWBcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGU6IHN0cmluZywgbm9uY2U/OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IEhUTUxTdHlsZUVsZW1lbnQge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9ICg8SFRNTFN0eWxlRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9XWApKVxuXG4gIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZ1xuICB9XG5cbiAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpXG4gIH1cblxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9YCwgJycpXG4gIHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcblxuICByZXR1cm4gc3R5bGVOb2RlXG59XG4iLCAiaW1wb3J0IHtcbiAgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQge1xuICBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXksIFRyYW5zYWN0aW9uLFxufSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9FdmVudEVtaXR0ZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi9FeHRlbnNpb25NYW5hZ2VyLmpzJ1xuaW1wb3J0IHtcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIsIENvbW1hbmRzLCBFZGl0YWJsZSwgRm9jdXNFdmVudHMsIEtleW1hcCwgVGFiaW5kZXgsXG59IGZyb20gJy4vZXh0ZW5zaW9ucy9pbmRleC5qcydcbmltcG9ydCB7IGNyZWF0ZURvY3VtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0SFRNTEZyb21GcmFnbWVudCB9IGZyb20gJy4vaGVscGVycy9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dCB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuaW1wb3J0IHsgaXNBY3RpdmUgfSBmcm9tICcuL2hlbHBlcnMvaXNBY3RpdmUuanMnXG5pbXBvcnQgeyBpc05vZGVFbXB0eSB9IGZyb20gJy4vaGVscGVycy9pc05vZGVFbXB0eS5qcydcbmltcG9ydCB7IHJlc29sdmVGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLmpzJ1xuaW1wb3J0IHsgTm9kZVBvcyB9IGZyb20gJy4vTm9kZVBvcy5qcydcbmltcG9ydCB7IHN0eWxlIH0gZnJvbSAnLi9zdHlsZS5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEVkaXRvckV2ZW50cyxcbiAgRWRpdG9yT3B0aW9ucyxcbiAgSlNPTkNvbnRlbnQsXG4gIFNpbmdsZUNvbW1hbmRzLFxuICBUZXh0U2VyaWFsaXplcixcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNyZWF0ZVN0eWxlVGFnIH0gZnJvbSAnLi91dGlsaXRpZXMvY3JlYXRlU3R5bGVUYWcuanMnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNGdW5jdGlvbi5qcydcblxuZXhwb3J0ICogYXMgZXh0ZW5zaW9ucyBmcm9tICcuL2V4dGVuc2lvbnMvaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSFRNTEVsZW1lbnQge1xuICBlZGl0b3I/OiBFZGl0b3Jcbn1cblxuZXhwb3J0IGNsYXNzIEVkaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlcjxFZGl0b3JFdmVudHM+IHtcbiAgcHJpdmF0ZSBjb21tYW5kTWFuYWdlciE6IENvbW1hbmRNYW5hZ2VyXG5cbiAgcHVibGljIGV4dGVuc2lvbk1hbmFnZXIhOiBFeHRlbnNpb25NYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjc3MhOiBIVE1MU3R5bGVFbGVtZW50XG5cbiAgcHVibGljIHNjaGVtYSE6IFNjaGVtYVxuXG4gIHB1YmxpYyB2aWV3ITogRWRpdG9yVmlld1xuXG4gIHB1YmxpYyBpc0ZvY3VzZWQgPSBmYWxzZVxuXG4gIHB1YmxpYyBleHRlbnNpb25TdG9yYWdlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cblxuICBwdWJsaWMgb3B0aW9uczogRWRpdG9yT3B0aW9ucyA9IHtcbiAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBjb250ZW50OiAnJyxcbiAgICBpbmplY3RDU1M6IHRydWUsXG4gICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcbiAgICBleHRlbnNpb25zOiBbXSxcbiAgICBhdXRvZm9jdXM6IGZhbHNlLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgIGVkaXRvclByb3BzOiB7fSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIGNvcmVFeHRlbnNpb25PcHRpb25zOiB7fSxcbiAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXG4gICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25DcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICBvbkZvY3VzOiAoKSA9PiBudWxsLFxuICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpXG4gICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKVxuICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB0aGlzLmNyZWF0ZVZpZXcoKVxuICAgIHRoaXMuaW5qZWN0Q1NTKClcbiAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpXG4gICAgdGhpcy5vbigndXBkYXRlJywgdGhpcy5vcHRpb25zLm9uVXBkYXRlKVxuICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSlcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKVxuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vcHRpb25zLm9uRm9jdXMpXG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpXG4gICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpXG5cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKVxuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KVxuICAgIH0sIDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3JhZ2UoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBwdWJsaWMgY2hhaW4oKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgKi9cbiAgcHVibGljIGNhbigpOiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHByaXZhdGUgaW5qZWN0Q1NTKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIGRvY3VtZW50KSB7XG4gICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzZXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8RWRpdG9yT3B0aW9ucz4gPSB7fSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcylcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbiwgZW1pdFVwZGF0ZSA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KVxuXG4gICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJQbHVnaW4oXG4gICAgcGx1Z2luOiBQbHVnaW4sXG4gICAgaGFuZGxlUGx1Z2lucz86IChuZXdQbHVnaW46IFBsdWdpbiwgcGx1Z2luczogUGx1Z2luW10pID0+IFBsdWdpbltdLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5IFRoZSBwbHVnaW5zIG5hbWVcbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleTogc3RyaW5nIHwgUGx1Z2luS2V5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2luczogdGhpcy5zdGF0ZS5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSksXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk6IHZvaWQge1xuXG4gICAgY29uc3QgY29yZUV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPyBbXG4gICAgICBFZGl0YWJsZSxcbiAgICAgIENsaXBib2FyZFRleHRTZXJpYWxpemVyLmNvbmZpZ3VyZSh7XG4gICAgICAgIGJsb2NrU2VwYXJhdG9yOiB0aGlzLm9wdGlvbnMuY29yZUV4dGVuc2lvbk9wdGlvbnM/LmNsaXBib2FyZFRleHRTZXJpYWxpemVyPy5ibG9ja1NlcGFyYXRvcixcbiAgICAgIH0pLFxuICAgICAgQ29tbWFuZHMsXG4gICAgICBGb2N1c0V2ZW50cyxcbiAgICAgIEtleW1hcCxcbiAgICAgIFRhYmluZGV4LFxuICAgIF0gOiBbXVxuICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24/LnR5cGUpXG4gICAgfSlcblxuICAgIHRoaXMuZXh0ZW5zaW9uTWFuYWdlciA9IG5ldyBFeHRlbnNpb25NYW5hZ2VyKGFsbEV4dGVuc2lvbnMsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk6IHZvaWQge1xuICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlU2NoZW1hKCk6IHZvaWQge1xuICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVWaWV3KCk6IHZvaWQge1xuICAgIGNvbnN0IGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpXG5cbiAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgZG9jLFxuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gYGVkaXRvci52aWV3YCBpcyBub3QgeWV0IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuXG4gICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUobmV3U3RhdGUpXG5cbiAgICB0aGlzLmNyZWF0ZU5vZGVWaWV3cygpXG4gICAgdGhpcy5wcmVwZW5kQ2xhc3MoKVxuXG4gICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAvLyBTbyB3ZeKAmWxsIGhhdmUgYWNjZXNzIHRvIGl0IGZvciB0ZXN0cy5cbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG5cbiAgICBkb20uZWRpdG9yID0gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTm9kZVZpZXdzKCk6IHZvaWQge1xuICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3MsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBwcmVwZW5kQ2xhc3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YFxuICB9XG5cbiAgcHVibGljIGlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gIHByaXZhdGUgY2FwdHVyZWRUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb24gfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBjYXB0dXJlVHJhbnNhY3Rpb24oZm46IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gdHJ1ZVxuICAgIGZuKClcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb25cblxuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGxcblxuICAgIHJldHVybiB0clxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwYXRjaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIC8vIGlmIHRoZSBlZGl0b3IgLyB0aGUgdmlldyBvZiB0aGUgZWRpdG9yIHdhcyBkZXN0cm95ZWRcbiAgICAvLyB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIG5vdCBiZSBkaXNwYXRjaGVkIGFzIHRoZXJlIGlzIG5vIHZpZXcgYW55bW9yZS5cbiAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uPy5zdGVwKHN0ZXApKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pXG4gICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG5cbiAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnZm9jdXMnKVxuICAgIGNvbnN0IGJsdXIgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdibHVyJylcblxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lbWl0KCdmb2N1cycsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYmx1cikge1xuICAgICAgdGhpcy5lbWl0KCdibHVyJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxuICAgKi9cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyayBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBBdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmtcbiAgICovXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7fSk6IGJvb2xlYW5cbiAgcHVibGljIGlzQWN0aXZlKGF0dHJpYnV0ZXM6IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUobmFtZU9yQXR0cmlidXRlczogc3RyaW5nLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQ/OiB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbFxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBpc0FjdGl2ZSh0aGlzLnN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyBnZXRKU09OKCk6IEpTT05Db250ZW50IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAqL1xuICBwdWJsaWMgZ2V0SFRNTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQsIHRoaXMuc2NoZW1hKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIHB1YmxpYyBnZXRUZXh0KG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhcmFjdGVyQ291bnQoKTogbnVtYmVyIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW3RpcHRhcCB3YXJuXTogXCJlZGl0b3IuZ2V0Q2hhcmFjdGVyQ291bnQoKVwiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJlZGl0b3Iuc3RvcmFnZS5jaGFyYWN0ZXJDb3VudC5jaGFyYWN0ZXJzKClcIiBpbnN0ZWFkLicsXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKVxuXG4gICAgaWYgKHRoaXMudmlldykge1xuICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0Rlc3Ryb3llZCgpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICF0aGlzLnZpZXc/LmRvY1ZpZXdcbiAgfVxuXG4gIHB1YmxpYyAkbm9kZShzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4kZG9jPy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB8fCBudWxsXG4gIH1cblxuICBwdWJsaWMgJG5vZGVzKHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogTm9kZVBvc1tdIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuJGRvYz8ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykgfHwgbnVsbFxuICB9XG5cbiAgcHVibGljICRwb3MocG9zOiBudW1iZXIpIHtcbiAgICBjb25zdCAkcG9zID0gdGhpcy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpXG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcylcbiAgfVxuXG4gIGdldCAkZG9jKCkge1xuICAgIHJldHVybiB0aGlzLiRwb3MoMClcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI2lucHV0LXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTWFya1R5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucy8jaW5wdXQtcnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIC8qKlxuICAgKiBUaGUgcmVnZXggdG8gbWF0Y2guXG4gICAqL1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcblxuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSB0byBhZGQuXG4gICAqL1xuICB0eXBlOiBOb2RlVHlwZVxuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIG5vZGVcbiAgICogY2FuIGFsc28gYmUgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICBjb25zdCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGxldCBlbmQgPSByYW5nZS50b1xuXG4gICAgICBjb25zdCBuZXdOb2RlID0gY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcbiAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldFxuXG4gICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgbWF0Y2hTdGFydCA9IGVuZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IG1hdGNoU3RhcnQgKyBtYXRjaFsxXS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCBsYXN0IHR5cGVkIGNoYXJhY3RlclxuICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdXG5cbiAgICAgICAgdHIuaW5zZXJ0VGV4dChsYXN0Q2hhciwgc3RhcnQgKyBtYXRjaFswXS5sZW5ndGggLSAxKVxuXG4gICAgICAgIC8vIGluc2VydCBub2RlIGZyb20gaW5wdXQgcnVsZVxuICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXRjaFN0YXJ0LCBlbmQsIG5ld05vZGUpXG4gICAgICB9IGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgIHRyLmluc2VydChzdGFydCAtIDEsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSkuZGVsZXRlKFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI2lucHV0LXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cblxuICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgc3RhdGUudHJcbiAgICAgICAgLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNpbnB1dC1ydWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dElucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGNhbkpvaW4sIGZpbmRXcmFwcGluZyB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNpbnB1dC1ydWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbiAgdHlwZTogTm9kZVR5cGUsXG4gIGtlZXBNYXJrcz86IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzPzogYm9vbGVhbixcbiAgZWRpdG9yPzogRWRpdG9yXG4gIGdldEF0dHJpYnV0ZXM/OlxuICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gIHwgZmFsc2VcbiAgfCBudWxsXG4gICxcbiAgam9pblByZWRpY2F0ZT86IChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBub2RlOiBQcm9zZU1pcnJvck5vZGUpID0+IGJvb2xlYW4sXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoe1xuICAgICAgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cbiAgICAgIGNvbnN0IHRyID0gc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSlcbiAgICAgIGNvbnN0IGJsb2NrUmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpXG4gICAgICBjb25zdCB3cmFwcGluZyA9IGJsb2NrUmFuZ2UgJiYgZmluZFdyYXBwaW5nKGJsb2NrUmFuZ2UsIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAoIXdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHRyLndyYXAoYmxvY2tSYW5nZSwgd3JhcHBpbmcpXG5cbiAgICAgIGlmIChjb25maWcua2VlcE1hcmtzICYmIGNvbmZpZy5lZGl0b3IpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAvKiogSWYgdGhlIG5vZGVUeXBlIGlzIGBidWxsZXRMaXN0YCBvciBgb3JkZXJlZExpc3RgIHNldCB0aGUgYG5vZGVUeXBlYCBhcyBgbGlzdEl0ZW1gICovXG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0J1xuXG4gICAgICAgIGNoYWluKCkudXBkYXRlQXR0cmlidXRlcyhub2RlVHlwZSwgYXR0cmlidXRlcykucnVuKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmVcblxuICAgICAgaWYgKFxuICAgICAgICBiZWZvcmVcbiAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXG4gICAgICAgICYmIGNhbkpvaW4odHIuZG9jLCByYW5nZS5mcm9tIC0gMSlcbiAgICAgICAgJiYgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSlcbiAgICAgICkge1xuICAgICAgICB0ci5qb2luKHJhbmdlLmZyb20gLSAxKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHtcbiAgRE9NT3V0cHV0U3BlYywgTWFyayBhcyBQcm9zZU1pcnJvck1hcmssIE1hcmtTcGVjLCBNYXJrVHlwZSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgTWFya0NvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNYXJrQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHRlbnNpb24gbmFtZSAtIHRoaXMgbXVzdCBiZSB1bmlxdWUuXG4gICAgICogSXQgd2lsbCBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSAnbXlFeHRlbnNpb24nXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpb3JpdHkgb2YgeW91ciBleHRlbnNpb24uIFRoZSBoaWdoZXIsIHRoZSBsYXRlciBpdCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIGFuZCB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGV4dGVuc2lvbnMgd2l0aCBhIGxvd2VyIHByaW9yaXR5LlxuICAgICAqIEBkZWZhdWx0IDEwMDBcbiAgICAgKiBAZXhhbXBsZSAxMDAxXG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgZXh0ZW5zaW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgKiAgIG15T3B0aW9uOiAnZm9vJyxcbiAgICAgKiAgIG15T3RoZXJPcHRpb246IDEwLFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIG9wdGlvbnMgdG8gdGhpcyBleHRlbnNpb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNzZXR0aW5nc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkT3B0aW9ucygpIHtcbiAgICAgKiAgcmV0dXJuIHtcbiAgICAgKiAgICBteU9wdGlvbjogJ2ZvbycsXG4gICAgICogICAgbXlPdGhlck9wdGlvbjogMTAsXG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzdG9yYWdlIHRoaXMgZXh0ZW5zaW9uIGNhbiBzYXZlIGRhdGEgdG8uXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjc3RvcmFnZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogZGVmYXVsdFN0b3JhZ2U6IHtcbiAgICAgKiAgIHByZWZldGNoZWRVc2VyczogW10sXG4gICAgICogICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBnbG9iYWxBdHRyaWJ1dGVzIHRvIHNwZWNpZmljIG5vZGVzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2dsb2JhbC1hdHRyaWJ1dGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAge1xuICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgZm9sbG93aW5nIGV4dGVuc2lvbnNcbiAgICAgKiAgICAgICB0eXBlczogW1xuICAgICAqICAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAqICAgICAgICAgJ3BhcmFncmFwaCcsXG4gICAgICogICAgICAgXSxcbiAgICAgKiAgICAgICAvLyDigKYgd2l0aCB0aG9zZSBhdHRyaWJ1dGVzXG4gICAgICogICAgICAgYXR0cmlidXRlczoge1xuICAgICAqICAgICAgICAgdGV4dEFsaWduOiB7XG4gICAgICogICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICAgKiAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiAoe1xuICAgICAqICAgICAgICAgICAgIHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gLFxuICAgICAqICAgICAgICAgICB9KSxcbiAgICAgKiAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduIHx8ICdsZWZ0JyxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIF1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjb21tYW5kcyB0byB0aGUgZWRpdG9yXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMja2V5Ym9hcmQtc2hvcnRjdXRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRDb21tYW5kcygpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIG15Q29tbWFuZDogKCkgPT4gKHsgY2hhaW4gfSkgPT4gY2hhaW4oKS5zZXRNYXJrKCd0eXBlJywgJ2ZvbycpLnJ1bigpLFxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZWdpc3RlcnMga2V5Ym9hcmQgc2hvcnRjdXRzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2tleWJvYXJkLXNob3J0Y3V0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICogICByZXR1cm4ge1xuICAgICAqICAgICAnTW9kLWwnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KCksXG4gICAgICogICB9XG4gICAgICogfSxcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBpbnB1dCBydWxlcyB0byB0aGUgZWRpdG9yLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2lucHV0LXJ1bGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICogICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgKiAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICogICAgIH0pLFxuICAgICAqICAgXVxuICAgICAqIH0sXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgcGFzdGUgcnVsZXMgdG8gdGhlIGVkaXRvci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNwYXN0ZS1ydWxlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAqICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICogICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAqICAgICB9KSxcbiAgICAgKiAgIF1cbiAgICAgKiB9LFxuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIFByb3NlbWlycm9yIHBsdWdpbnMgdG8gdGhlIGVkaXRvclxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3Byb3NlbWlycm9yLXBsdWdpbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIGN1c3RvbVBsdWdpbigpLFxuICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXVxuICAgIH0pID0+IFBsdWdpbltdXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWRkaXRpb25hbCBleHRlbnNpb25zIHRvIHRoZSBlZGl0b3IuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqIGJ1aWxkaW5nIGV4dGVuc2lvbiBraXRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkRXh0ZW5zaW9ucygpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIEJ1bGxldExpc3QsXG4gICAgICogICAgIE9yZGVyZWRMaXN0LFxuICAgICAqICAgICBMaXN0SXRlbVxuICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXh0ZW5kcyB0aGUgc2NoZW1hIG9mIHRoZSBub2RlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXh0ZW5kTm9kZVNjaGVtYSgpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXh0ZW5kcyB0aGUgc2NoZW1hIG9mIHRoZSBtYXJrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZXh0ZW5kTWFya1NjaGVtYSgpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgbWFyayBhZnRlciBzcGxpdCBub2RlXG4gICAgICovXG4gICAga2VlcE9uU3BsaXQ/OiBib29sZWFuIHwgKCgpID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpdmVcbiAgICAgKi9cbiAgICBpbmNsdXNpdmU/OlxuICAgICAgfCBNYXJrU3BlY1snaW5jbHVzaXZlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5jbHVzaXZlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2luY2x1c2l2ZSddKVxuXG4gICAgLyoqXG4gICAgICogRXhjbHVkZXNcbiAgICAgKi9cbiAgICBleGNsdWRlcz86XG4gICAgICB8IE1hcmtTcGVjWydleGNsdWRlcyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4Y2x1ZGVzJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2V4Y2x1ZGVzJ10pXG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGlzIE1hcmsgYXMgZXhpdGFibGVcbiAgICAgKi9cbiAgICBleGl0YWJsZT86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBNYXJrU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogU3Bhbm5pbmdcbiAgICAgKi9cbiAgICBzcGFubmluZz86XG4gICAgICB8IE1hcmtTcGVjWydzcGFubmluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NwYW5uaW5nJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ3NwYW5uaW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb2RlXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBIVE1MXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBNYXJrU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIEhUTUxcbiAgICAgKi9cbiAgICByZW5kZXJIVE1MPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJIVE1MJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG1hcms6IFByb3NlTWlycm9yTWFya1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEF0dHJpYnV0ZXMnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gQXR0cmlidXRlcyB8IHt9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgTWFyayBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBjdXN0b20gbWFyayBleHRlbnNpb25zLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMjY3JlYXRlLWEtbmV3LWV4dGVuc2lvblxuICovXG5leHBvcnQgY2xhc3MgTWFyazxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbWFyaydcblxuICBuYW1lID0gJ21hcmsnXG5cbiAgcGFyZW50OiBNYXJrIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE1hcmtDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgc3RhdGljIGhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcmsgfTogeyBlZGl0b3I6IEVkaXRvcjsgbWFyazogTWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlXG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb21cbiAgICBjb25zdCBpc0F0RW5kID0gY3VycmVudFBvcy5wb3MgPT09IGN1cnJlbnRQb3MuZW5kKClcblxuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKClcbiAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKHJlbW92ZU1hcmspIHtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKVxuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKVxuXG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlU3BlYywgTm9kZVR5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIE5vZGVWaWV3UmVuZGVyZXIsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVuc2lvbiBuYW1lIC0gdGhpcyBtdXN0IGJlIHVuaXF1ZS5cbiAgICAgKiBJdCB3aWxsIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlICdteUV4dGVuc2lvbidcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmlvcml0eSBvZiB5b3VyIGV4dGVuc2lvbi4gVGhlIGhpZ2hlciwgdGhlIGxhdGVyIGl0IHdpbGwgYmUgY2FsbGVkXG4gICAgICogYW5kIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgb3RoZXIgZXh0ZW5zaW9ucyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkuXG4gICAgICogQGRlZmF1bHQgMTAwMFxuICAgICAqIEBleGFtcGxlIDEwMDFcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBleHRlbnNpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkZWZhdWx0T3B0aW9uczoge1xuICAgICAqICAgbXlPcHRpb246ICdmb28nLFxuICAgICAqICAgbXlPdGhlck9wdGlvbjogMTAsXG4gICAgICogfVxuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgb3B0aW9ucyB0byB0aGlzIGV4dGVuc2lvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3NldHRpbmdzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRPcHRpb25zKCkge1xuICAgICAqICByZXR1cm4ge1xuICAgICAqICAgIG15T3B0aW9uOiAnZm9vJyxcbiAgICAgKiAgICBteU90aGVyT3B0aW9uOiAxMCxcbiAgICAgKiB9XG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE9wdGlvbnMnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHN0b3JhZ2UgdGhpcyBleHRlbnNpb24gY2FuIHNhdmUgZGF0YSB0by5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNzdG9yYWdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkZWZhdWx0U3RvcmFnZToge1xuICAgICAqICAgcHJlZmV0Y2hlZFVzZXJzOiBbXSxcbiAgICAgKiAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGdsb2JhbEF0dHJpYnV0ZXMgdG8gc3BlY2lmaWMgbm9kZXMuXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjZ2xvYmFsLWF0dHJpYnV0ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgICogICByZXR1cm4gW1xuICAgICAqICAgICB7XG4gICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBmb2xsb3dpbmcgZXh0ZW5zaW9uc1xuICAgICAqICAgICAgIHR5cGVzOiBbXG4gICAgICogICAgICAgICAnaGVhZGluZycsXG4gICAgICogICAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgKiAgICAgICBdLFxuICAgICAqICAgICAgIC8vIOKApiB3aXRoIHRob3NlIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICogICAgICAgICB0ZXh0QWxpZ246IHtcbiAgICAgKiAgICAgICAgICAgZGVmYXVsdDogJ2xlZnQnLFxuICAgICAqICAgICAgICAgICByZW5kZXJIVE1MOiBhdHRyaWJ1dGVzID0+ICh7XG4gICAgICogICAgICAgICAgICAgc3R5bGU6IGB0ZXh0LWFsaWduOiAke2F0dHJpYnV0ZXMudGV4dEFsaWdufWAsXG4gICAgICogICAgICAgICAgIH0pLFxuICAgICAqICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gfHwgJ2xlZnQnLFxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICB9LFxuICAgICAqICAgXVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNvbW1hbmRzIHRvIHRoZSBlZGl0b3JcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucyNrZXlib2FyZC1zaG9ydGN1dHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZENvbW1hbmRzKCkge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgbXlDb21tYW5kOiAoKSA9PiAoeyBjaGFpbiB9KSA9PiBjaGFpbigpLnNldE1hcmsoJ3R5cGUnLCAnZm9vJykucnVuKCksXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlZ2lzdGVycyBrZXlib2FyZCBzaG9ydGN1dHMuXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMja2V5Ym9hcmQtc2hvcnRjdXRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgICdNb2QtbCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJ1bGxldExpc3QoKSxcbiAgICAgKiAgIH1cbiAgICAgKiB9LFxuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGlucHV0IHJ1bGVzIHRvIHRoZSBlZGl0b3IuXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjaW5wdXQtcnVsZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICogICByZXR1cm4gW1xuICAgICAqICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgKiAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAqICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgKiAgICAgfSksXG4gICAgICogICBdXG4gICAgICogfSxcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBwYXN0ZSBydWxlcyB0byB0aGUgZWRpdG9yLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3Bhc3RlLXJ1bGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICogICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgKiAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICogICAgIH0pLFxuICAgICAqICAgXVxuICAgICAqIH0sXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgUHJvc2VtaXJyb3IgcGx1Z2lucyB0byB0aGUgZWRpdG9yXG4gICAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjcHJvc2VtaXJyb3ItcGx1Z2luc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAgY3VzdG9tUGx1Z2luKCksXG4gICAgICogICBdXG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBhZGRpdGlvbmFsIGV4dGVuc2lvbnMgdG8gdGhlIGVkaXRvci4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAgICogYnVpbGRpbmcgZXh0ZW5zaW9uIGtpdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBhZGRFeHRlbnNpb25zKCkge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAgQnVsbGV0TGlzdCxcbiAgICAgKiAgICAgT3JkZXJlZExpc3QsXG4gICAgICogICAgIExpc3RJdGVtXG4gICAgICogICBdXG4gICAgICogfVxuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleHRlbmRzIHRoZSBzY2hlbWEgb2YgdGhlIG5vZGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBleHRlbmROb2RlU2NoZW1hKCkge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAqICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleHRlbmRzIHRoZSBzY2hlbWEgb2YgdGhlIG1hcmsuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBleHRlbmRNYXJrU2NoZW1hKCkge1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAqICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICovXG4gICAgb25CZWZvcmVDcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CZWZvcmVDcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIG9uQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uU2VsZWN0aW9uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblRyYW5zYWN0aW9uPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmx1ciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9uRGVzdHJveT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkRlc3Ryb3knXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBOb2RlIFZpZXdcbiAgICAgKi9cbiAgICBhZGROb2RlVmlldz86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGROb2RlVmlldyddXG4gICAgICAgIH0pID0+IE5vZGVWaWV3UmVuZGVyZXIpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgdGhpcyBub2RlIHNob3VsZCBiZSBhIHRvcCBsZXZlbCBub2RlIChkb2MpXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovXG4gICAgdG9wTm9kZT86IGJvb2xlYW5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoaXMgbm9kZSwgYXMgZGVzY3JpYmVkIGluIHRoZSBbc2NoZW1hXG4gICAgICogZ3VpZGVdKC9kb2NzL2d1aWRlLyNzY2hlbWEuY29udGVudF9leHByZXNzaW9ucykuIFdoZW4gbm90IGdpdmVuLFxuICAgICAqIHRoZSBub2RlIGRvZXMgbm90IGFsbG93IGFueSBjb250ZW50LlxuICAgICAqXG4gICAgICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgaXQgb24gdGhlIFByb3NlbWlycm9yIGRvY3VtZW50YXRpb24gaGVyZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jc2NoZW1hLmNvbnRlbnRfZXhwcmVzc2lvbnNcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAZXhhbXBsZSBjb250ZW50OiAnYmxvY2srJ1xuICAgICAqIEBleGFtcGxlIGNvbnRlbnQ6ICdoZWFkbGluZSBwYXJhZ3JhcGggYmxvY2sqJ1xuICAgICAqL1xuICAgIGNvbnRlbnQ/OlxuICAgICAgfCBOb2RlU3BlY1snY29udGVudCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvbnRlbnQnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snY29udGVudCddKVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcmtzIHRoYXQgYXJlIGFsbG93ZWQgaW5zaWRlIG9mIHRoaXMgbm9kZS4gTWF5IGJlIGFcbiAgICAgKiBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHJlZmVycmluZyB0byBtYXJrIG5hbWVzIG9yIGdyb3VwcywgYFwiX1wiYFxuICAgICAqIHRvIGV4cGxpY2l0bHkgYWxsb3cgYWxsIG1hcmtzLCBvciBgXCJcImAgdG8gZGlzYWxsb3cgbWFya3MuIFdoZW5cbiAgICAgKiBub3QgZ2l2ZW4sIG5vZGVzIHdpdGggaW5saW5lIGNvbnRlbnQgZGVmYXVsdCB0byBhbGxvd2luZyBhbGxcbiAgICAgKiBtYXJrcywgb3RoZXIgbm9kZXMgZGVmYXVsdCB0byBub3QgYWxsb3dpbmcgbWFya3MuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBtYXJrczogJ3N0cm9uZyBlbSdcbiAgICAgKi9cbiAgICBtYXJrcz86XG4gICAgICB8IE5vZGVTcGVjWydtYXJrcyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ21hcmtzJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ21hcmtzJ10pXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3JvdXAgb3Igc3BhY2Utc2VwYXJhdGVkIGdyb3VwcyB0byB3aGljaCB0aGlzIG5vZGUgYmVsb25ncyxcbiAgICAgKiB3aGljaCBjYW4gYmUgcmVmZXJyZWQgdG8gaW4gdGhlIGNvbnRlbnQgZXhwcmVzc2lvbnMgZm9yIHRoZVxuICAgICAqIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgVGlwdGFwIHVzZXMgdGhlIGdyb3VwcyAnYmxvY2snIGFuZCAnaW5saW5lJyBmb3Igbm9kZXMuIFlvdVxuICAgICAqIGNhbiBhbHNvIHVzZSBjdXN0b20gZ3JvdXBzIGlmIHlvdSB3YW50IHRvIGdyb3VwIHNwZWNpZmljIG5vZGVzIHRvZ2V0aGVyXG4gICAgICogYW5kIGhhbmRsZSB0aGVtIGluIHlvdXIgc2NoZW1hLlxuICAgICAqIEBleGFtcGxlIGdyb3VwOiAnYmxvY2snXG4gICAgICogQGV4YW1wbGUgZ3JvdXA6ICdpbmxpbmUnXG4gICAgICogQGV4YW1wbGUgZ3JvdXA6ICdjdXN0b21CbG9jaycgLy8gdGhpcyB1c2VzIGEgY3VzdG9tIGdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBOb2RlU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIHNldCB0byB0cnVlIGZvciBpbmxpbmUgbm9kZXMuIChJbXBsaWVkIGZvciB0ZXh0IG5vZGVzLilcbiAgICAgKi9cbiAgICBpbmxpbmU/OlxuICAgICAgfCBOb2RlU3BlY1snaW5saW5lJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5saW5lJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2lubGluZSddKVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHNldCB0byB0cnVlIHRvIGluZGljYXRlIHRoYXQsIHRob3VnaCB0aGlzIGlzbid0IGEgW2xlYWZcbiAgICAgKiBub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuaXNMZWFmKSwgaXQgZG9lc24ndCBoYXZlIGRpcmVjdGx5IGVkaXRhYmxlXG4gICAgICogY29udGVudCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgdW5pdCBpbiB0aGUgdmlldy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGF0b206IHRydWVcbiAgICAgKi9cbiAgICBhdG9tPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2F0b20nXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhdG9tJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2F0b20nXSlcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoZXRoZXIgbm9kZXMgb2YgdGhpcyB0eXBlIGNhbiBiZSBzZWxlY3RlZCBhcyBhIFtub2RlXG4gICAgICogc2VsZWN0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuTm9kZVNlbGVjdGlvbikuIERlZmF1bHRzIHRvIHRydWUgZm9yIG5vbi10ZXh0XG4gICAgICogbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQGV4YW1wbGUgc2VsZWN0YWJsZTogZmFsc2VcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3NlbGVjdGFibGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzZWxlY3RhYmxlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3NlbGVjdGFibGUnXSlcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGJlIGRyYWdnZWQgd2l0aG91dFxuICAgICAqIGJlaW5nIHNlbGVjdGVkLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0OiBmYWxzZVxuICAgICAqIEBleGFtcGxlOiBkcmFnZ2FibGU6IHRydWVcbiAgICAgKi9cbiAgICBkcmFnZ2FibGU/OlxuICAgICAgfCBOb2RlU3BlY1snZHJhZ2dhYmxlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZHJhZ2dhYmxlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2RyYWdnYWJsZSddKVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIG5vZGUgY29udGFpbnMgY29kZSwgd2hpY2hcbiAgICAgKiBjYXVzZXMgc29tZSBjb21tYW5kcyB0byBiZWhhdmUgZGlmZmVyZW50bHkuXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IE5vZGVTcGVjWydjb2RlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydjb2RlJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3YXkgd2hpdGVzcGFjZSBpbiB0aGlzIGEgbm9kZSBpcyBwYXJzZWQuIFRoZSBkZWZhdWx0IGlzXG4gICAgICogYFwibm9ybWFsXCJgLCB3aGljaCBjYXVzZXMgdGhlIFtET00gcGFyc2VyXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyKSB0b1xuICAgICAqIGNvbGxhcHNlIHdoaXRlc3BhY2UgaW4gbm9ybWFsIG1vZGUsIGFuZCBub3JtYWxpemUgaXQgKHJlcGxhY2luZ1xuICAgICAqIG5ld2xpbmVzIGFuZCBzdWNoIHdpdGggc3BhY2VzKSBvdGhlcndpc2UuIGBcInByZVwiYCBjYXVzZXMgdGhlXG4gICAgICogcGFyc2VyIHRvIHByZXNlcnZlIHNwYWNlcyBpbnNpZGUgdGhlIG5vZGUuIFdoZW4gdGhpcyBvcHRpb24gaXNuJ3RcbiAgICAgKiBnaXZlbiwgYnV0IFtgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBpcyB0cnVlLCBgd2hpdGVzcGFjZWBcbiAgICAgKiB3aWxsIGRlZmF1bHQgdG8gYFwicHJlXCJgLiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gZG9lc24ndCBpbmZsdWVuY2VcbiAgICAgKiB0aGUgd2F5IHRoZSBub2RlIGlzIHJlbmRlcmVk4oCUdGhhdCBzaG91bGQgYmUgaGFuZGxlZCBieSBgdG9ET01gXG4gICAgICogYW5kL29yIHN0eWxpbmcuXG4gICAgICovXG4gICAgd2hpdGVzcGFjZT86XG4gICAgICB8IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnd2hpdGVzcGFjZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ10pXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGVuYWJsZWQsIGVuYWJsZXMgYm90aFxuICAgICAqIFtgZGVmaW5pbmdBc0NvbnRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdBc0NvbnRleHQpIGFuZFxuICAgICAqIFtgZGVmaW5pbmdGb3JDb250ZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBleGFtcGxlIGlzb2xhdGluZzogdHJ1ZVxuICAgICAqL1xuICAgIGRlZmluaW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RlZmluaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZGVmaW5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZGVmaW5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZW5hYmxlZCAoZGVmYXVsdCBpcyBmYWxzZSksIHRoZSBzaWRlcyBvZiBub2RlcyBvZiB0aGlzIHR5cGVcbiAgICAgKiBjb3VudCBhcyBib3VuZGFyaWVzIHRoYXQgcmVndWxhciBlZGl0aW5nIG9wZXJhdGlvbnMsIGxpa2VcbiAgICAgKiBiYWNrc3BhY2luZyBvciBsaWZ0aW5nLCB3b24ndCBjcm9zcy4gQW4gZXhhbXBsZSBvZiBhIG5vZGUgdGhhdFxuICAgICAqIHNob3VsZCBwcm9iYWJseSBoYXZlIHRoaXMgZW5hYmxlZCBpcyBhIHRhYmxlIGNlbGwuXG4gICAgICovXG4gICAgaXNvbGF0aW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lzb2xhdGluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lzb2xhdGluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpc29sYXRpbmcnXSlcblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZXMgRE9NIHBhcnNlciBpbmZvcm1hdGlvbiB3aXRoIHRoaXMgbm9kZSwgd2hpY2ggY2FuIGJlXG4gICAgICogdXNlZCBieSBbYERPTVBhcnNlci5mcm9tU2NoZW1hYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlcl5mcm9tU2NoZW1hKSB0b1xuICAgICAqIGF1dG9tYXRpY2FsbHkgZGVyaXZlIGEgcGFyc2VyLiBUaGUgYG5vZGVgIGZpZWxkIGluIHRoZSBydWxlcyBpc1xuICAgICAqIGltcGxpZWQgKHRoZSBuYW1lIG9mIHRoaXMgbm9kZSB3aWxsIGJlIGZpbGxlZCBpbiBhdXRvbWF0aWNhbGx5KS5cbiAgICAgKiBJZiB5b3Ugc3VwcGx5IHlvdXIgb3duIHBhcnNlciwgeW91IGRvIG5vdCBuZWVkIHRvIGFsc28gc3BlY2lmeVxuICAgICAqIHBhcnNpbmcgcnVsZXMgaW4geW91ciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBwYXJzZUhUTUw6IFt7IHRhZzogJ2RpdicsIGF0dHJzOiB7ICdkYXRhLWlkJzogJ215LWJsb2NrJyB9IH1dXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBOb2RlU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogQSBkZXNjcmlwdGlvbiBvZiBhIERPTSBzdHJ1Y3R1cmUuIENhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIHdoaWNoIGlzXG4gICAgICogaW50ZXJwcmV0ZWQgYXMgYSB0ZXh0IG5vZGUsIGEgRE9NIG5vZGUsIHdoaWNoIGlzIGludGVycHJldGVkIGFzXG4gICAgICogaXRzZWxmLCBhIGB7ZG9tLCBjb250ZW50RE9NfWAgb2JqZWN0LCBvciBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEFuIGFycmF5IGRlc2NyaWJlcyBhIERPTSBlbGVtZW50LiBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgICogc2hvdWxkIGJlIGEgc3RyaW5n4oCUdGhlIG5hbWUgb2YgdGhlIERPTSBlbGVtZW50LCBvcHRpb25hbGx5IHByZWZpeGVkXG4gICAgICogYnkgYSBuYW1lc3BhY2UgVVJMIGFuZCBhIHNwYWNlLiBJZiB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgcGxhaW5cbiAgICAgKiBvYmplY3QsIGl0IGlzIGludGVycHJldGVkIGFzIGEgc2V0IG9mIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIEFueSBlbGVtZW50cyBhZnRlciB0aGF0IChpbmNsdWRpbmcgdGhlIDJuZCBpZiBpdCdzIG5vdCBhbiBhdHRyaWJ1dGVcbiAgICAgKiBvYmplY3QpIGFyZSBpbnRlcnByZXRlZCBhcyBjaGlsZHJlbiBvZiB0aGUgRE9NIGVsZW1lbnRzLCBhbmQgbXVzdFxuICAgICAqIGVpdGhlciBiZSB2YWxpZCBgRE9NT3V0cHV0U3BlY2AgdmFsdWVzLCBvciB0aGUgbnVtYmVyIHplcm8uXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIHplcm8gKHByb25vdW5jZWQg4oCcaG9sZeKAnSkgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgcGxhY2VcbiAgICAgKiB3aGVyZSBhIG5vZGUncyBjaGlsZCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIGl0IG9jY3VycyBpbiBhblxuICAgICAqIG91dHB1dCBzcGVjLCBpdCBzaG91bGQgYmUgdGhlIG9ubHkgY2hpbGQgZWxlbWVudCBpbiBpdHMgcGFyZW50XG4gICAgICogbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHRvRE9NOiBbJ2RpdltkYXRhLWlkPVwibXktYmxvY2tcIl0nLCB7IGNsYXNzOiAnbXktYmxvY2snIH0sIDBdXG4gICAgICovXG4gICAgcmVuZGVySFRNTD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVySFRNTCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBET01PdXRwdXRTcGVjKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJzIHRoZSBub2RlIGFzIHRleHRcbiAgICAgKiBAZXhhbXBsZSByZW5kZXJUZXh0OiAoKSA9PiAnZm9vXG4gICAgICovXG4gICAgcmVuZGVyVGV4dD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVyVGV4dCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIHBvczogbnVtYmVyXG4gICAgICAgICAgICBwYXJlbnQ6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gc3RyaW5nKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYXR0cmlidXRlcyB0byB0aGUgbm9kZVxuICAgICAqIEBleGFtcGxlIGFkZEF0dHJpYnV0ZXM6ICgpID0+ICh7IGNsYXNzOiAnZm9vJyB9KVxuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBOb2RlIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBub2RlIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdub2RlJ1xuXG4gIG5hbWUgPSAnbm9kZSdcblxuICBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogTm9kZUNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE5vZGU8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGU8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBOb2RlVmlldyBhcyBQcm9zZU1pcnJvck5vZGVWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBFZGl0b3IgYXMgQ29yZUVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IERlY29yYXRpb25XaXRoVHlwZSwgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsIE5vZGVWaWV3UmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0FuZHJvaWQgfSBmcm9tICcuL3V0aWxpdGllcy9pc0FuZHJvaWQuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG4vKipcbiAqIE5vZGUgdmlld3MgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSByZW5kZXJlZCBET00gc3RydWN0dXJlIG9mIGEgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL25vZGUtdmlld3NcbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGVWaWV3PFxuICBDb21wb25lbnQsXG4gIE5vZGVFZGl0b3IgZXh0ZW5kcyBDb3JlRWRpdG9yID0gQ29yZUVkaXRvcixcbiAgT3B0aW9ucyBleHRlbmRzIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zID0gTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsXG4+IGltcGxlbWVudHMgUHJvc2VNaXJyb3JOb2RlVmlldyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50XG5cbiAgZWRpdG9yOiBOb2RlRWRpdG9yXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIGV4dGVuc2lvbjogTm9kZVxuXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuXG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuXG4gIGdldFBvczogYW55XG5cbiAgaXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQsIHByb3BzOiBOb2RlVmlld1JlbmRlcmVyUHJvcHMsIG9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnRcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvciBhcyBOb2RlRWRpdG9yXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0gYXMgT3B0aW9uc1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gcHJvcHMuZXh0ZW5zaW9uXG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZVxuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucyBhcyBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zXG4gICAgdGhpcy5tb3VudCgpXG4gIH1cblxuICBtb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGdldCBkb20oKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgZ2V0IGNvbnRlbnRET00oKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQ6IERyYWdFdmVudCkge1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIC8vIGBjbG9zZXN0YCBpcyBub3QgYXZhaWxhYmxlIGZvciB0ZXh0IG5vZGVzIHNvIHdlIG1heSBoYXZlIHRvIHVzZSBpdHMgcGFyZW50XG4gICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyB0YXJnZXQucGFyZW50RWxlbWVudD8uY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG5cbiAgICBpZiAoIXRoaXMuZG9tIHx8IHRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHggPSAwXG4gICAgbGV0IHkgPSAwXG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFggPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFhcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5vZmZzZXRZID8/IChldmVudCBhcyBhbnkpLm5hdGl2ZUV2ZW50Py5vZmZzZXRZXG5cbiAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WFxuICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZXG4gICAgfVxuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyPy5zZXREcmFnSW1hZ2UodGhpcy5kb20sIHgsIHkpXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHRlbGwgUHJvc2VNaXJyb3IgdGhhdCB3ZSB3YW50IHRvIG1vdmUgdGhlIHdob2xlIG5vZGVcbiAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHRoaXMuZ2V0UG9zKCkpXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG5cbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuICB9XG5cbiAgc3RvcEV2ZW50KGV2ZW50OiBFdmVudCkge1xuICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnN0b3BFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpXG5cbiAgICAvLyBhbnkgZXZlbnQgZnJvbSBjaGlsZCBub2RlcyBzaG91bGQgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJylcbiAgICBjb25zdCBpc0Ryb3BFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdkcm9wJ1xuICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlXG5cbiAgICAvLyBhbnkgaW5wdXQgZXZlbnQgd2l0aGluIG5vZGUgdmlld3Mgc2hvdWxkIGJlIGlnbm9yZWQgYnkgUHJvc2VNaXJyb3JcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGVcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpXG4gICAgY29uc3QgaXNDb3B5RXZlbnQgPSBldmVudC50eXBlID09PSAnY29weSdcbiAgICBjb25zdCBpc1Bhc3RlRXZlbnQgPSBldmVudC50eXBlID09PSAncGFzdGUnXG4gICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnXG4gICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bidcblxuICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xuICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAvLyB0aGlzIGZpeCBwcmV2ZW50cyB0aGF0XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRWRpdGFibGUgJiYgIWlzRHJhZ2dpbmcgJiYgaXNDbGlja0V2ZW50KSB7XG4gICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG4gICAgICBjb25zdCBpc1ZhbGlkRHJhZ0hhbmRsZSA9IGRyYWdIYW5kbGUgJiYgKHRoaXMuZG9tID09PSBkcmFnSGFuZGxlIHx8IHRoaXMuZG9tLmNvbnRhaW5zKGRyYWdIYW5kbGUpKVxuXG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2RyYWdlbmQnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Ryb3AnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ21vdXNldXAnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgaGFuZGxlZCBieSBwcm9zZW1pcnJvclxuICAgIGlmIChcbiAgICAgIGlzRHJhZ2dpbmdcbiAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbjogTXV0YXRpb25SZWNvcmQgfCB7IHR5cGU6ICdzZWxlY3Rpb24nOyB0YXJnZXQ6IEVsZW1lbnQgfSkge1xuICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMuY29udGVudERPTSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pXG4gICAgfVxuXG4gICAgLy8gYSBsZWFmL2F0b20gbm9kZSBpcyBsaWtlIGEgYmxhY2sgYm94IGZvciBQcm9zZU1pcnJvclxuICAgIC8vIGFuZCBzaG91bGQgYmUgZnVsbHkgaGFuZGxlZCBieSB0aGUgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBzZWxlY3Rpb25zXG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdzZWxlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAvLyB0aGlzIGlzIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2Fu4oCZdCBwcmV2ZW50RGlzcGF0Y2ggb24gZW50ZXJcbiAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjUzNFxuICAgIGlmIChcbiAgICAgIHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZFxuICAgICkge1xuICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyksXG4gICAgICBdIGFzIEhUTUxFbGVtZW50W11cblxuICAgICAgLy8gd2XigJlsbCBjaGVjayBpZiBldmVyeSBjaGFuZ2VkIG5vZGUgaXMgY29udGVudEVkaXRhYmxlXG4gICAgICAvLyB0byBtYWtlIHN1cmUgaXTigJlzIHByb2JhYmx5IG11dGF0ZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkobm9kZSA9PiBub2RlLmlzQ29udGVudEVkaXRhYmxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSB3aWxsIGFsbG93IG11dGF0aW9uIGNvbnRlbnRET00gd2l0aCBhdHRyaWJ1dGVzXG4gICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBjaGFuZ2VzIHdpdGhpbiBjb250ZW50RE9NXG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzOiB7fSkge1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKVxuXG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIGRlbGV0ZU5vZGUoKTogdm9pZCB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0UG9zKClcbiAgICBjb25zdCB0byA9IGZyb20gKyB0aGlzLm5vZGUubm9kZVNpemVcblxuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSlcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL2N1c3RvbS1leHRlbnNpb25zLyNwYXN0ZS1ydWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQsXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSk6IHZhbHVlIGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2luZGV4LmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMvI3Bhc3RlLXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlUGFzdGVSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyKHtcbiAgICAgIG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsXG4gICAgfSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgIGNoYWluKCkuZGVsZXRlUmFuZ2UocmFuZ2UpLmluc2VydENvbnRlbnRBdChyYW5nZS5mcm9tLCB7XG4gICAgICAgICAgdHlwZTogY29uZmlnLnR5cGUubmFtZSxcbiAgICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9jdXN0b20tZXh0ZW5zaW9ucy8jcGFzdGUtcnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbiAgcmVwbGFjZTogc3RyaW5nLFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2VcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcblxuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKVxuICAgICAgICBzdGFydCArPSBvZmZzZXRcblxuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZFxuXG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0XG4gICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja2VyUmVzdWx0IHtcbiAgcG9zaXRpb246IG51bWJlclxuICBkZWxldGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBUcmFja2VyIHtcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG5cbiAgY3VycmVudFN0ZXA6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aFxuICB9XG5cbiAgbWFwKHBvc2l0aW9uOiBudW1iZXIpOiBUcmFja2VyUmVzdWx0IHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG5cbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pXG5cbiAgICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBSZXN1bHQucG9zXG4gICAgICB9LCBwb3NpdGlvbilcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkLFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgbm9kZSB3aGljaCByZXByZXNlbnRzIHRoZSB0b3AgbGV2ZWwgbm9kZSBvZiB0aGUgZWRpdG9yLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2RvY3VtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogJ2RvYycsXG4gIHRvcE5vZGU6IHRydWUsXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG4vKipcbkNyZWF0ZSBhIHBsdWdpbiB0aGF0LCB3aGVuIGFkZGVkIHRvIGEgUHJvc2VNaXJyb3IgaW5zdGFuY2UsXG5jYXVzZXMgYSBkZWNvcmF0aW9uIHRvIHNob3cgdXAgYXQgdGhlIGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmdcbmlzIGRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuXG5Ob2RlcyBtYXkgYWRkIGEgYGRpc2FibGVEcm9wQ3Vyc29yYCBwcm9wZXJ0eSB0byB0aGVpciBzcGVjIHRvXG5jb250cm9sIHRoZSBzaG93aW5nIG9mIGEgZHJvcCBjdXJzb3IgaW5zaWRlIHRoZW0uIFRoaXMgbWF5IGJlIGFcbmJvb2xlYW4gb3IgYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHZpZXcgYW5kIGFcbnBvc2l0aW9uLCBhbmQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXcoZWRpdG9yVmlldykgeyByZXR1cm4gbmV3IERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpOyB9XG4gICAgfSk7XG59XG5jbGFzcyBEcm9wQ3Vyc29yVmlldyB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yVmlldywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMud2lkdGggPSAoX2EgPSBvcHRpb25zLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvciA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5jb2xvciB8fCBcImJsYWNrXCIpO1xuICAgICAgICB0aGlzLmNsYXNzID0gb3B0aW9ucy5jbGFzcztcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VuZFwiLCBcImRyb3BcIiwgXCJkcmFnbGVhdmVcIl0ubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSAoZSkgPT4geyB0aGlzW25hbWVdKGUpOyB9O1xuICAgICAgICAgICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIGhhbmRsZXIgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaCgoeyBuYW1lLCBoYW5kbGVyIH0pID0+IHRoaXMuZWRpdG9yVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSk7XG4gICAgfVxuICAgIHVwZGF0ZShlZGl0b3JWaWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zICE9IG51bGwgJiYgcHJldlN0YXRlLmRvYyAhPSBlZGl0b3JWaWV3LnN0YXRlLmRvYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVPdmVybGF5KCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0aGlzLmN1cnNvclBvcyk7XG4gICAgICAgIGxldCBpc0Jsb2NrID0gISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQsIHJlY3Q7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSB8fCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MgLSAoYmVmb3JlID8gYmVmb3JlLm5vZGVTaXplIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodG9wICsgdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBub2RlUmVjdC5sZWZ0LCByaWdodDogbm9kZVJlY3QucmlnaHQsIHRvcDogdG9wIC0gdGhpcy53aWR0aCAvIDIsIGJvdHRvbTogdG9wICsgdGhpcy53aWR0aCAvIDIgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5lZGl0b3JWaWV3LmNvb3Jkc0F0UG9zKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gdGhpcy53aWR0aCAvIDIsIHJpZ2h0OiBjb29yZHMubGVmdCArIHRoaXMud2lkdGggLyAyLCB0b3A6IGNvb3Jkcy50b3AsIGJvdHRvbTogY29vcmRzLmJvdHRvbSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVkaXRvclZpZXcuZG9tLm9mZnNldFBhcmVudDtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIiwgaXNCbG9jayk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1pbmxpbmVcIiwgIWlzQmxvY2spO1xuICAgICAgICBsZXQgcGFyZW50TGVmdCwgcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IC1wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IHJlY3QubGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcGFyZW50VG9wID0gcmVjdC50b3AgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gKHJlY3QubGVmdCAtIHBhcmVudExlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gKHJlY3QudG9wIC0gcGFyZW50VG9wKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApICsgXCJweFwiO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbW92YWwodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldEN1cnNvcihudWxsKSwgdGltZW91dCk7XG4gICAgfVxuICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3JWaWV3LmVkaXRhYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5lZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICBsZXQgbm9kZSA9IHBvcyAmJiBwb3MuaW5zaWRlID49IDAgJiYgdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgIGxldCBkaXNhYmxlRHJvcEN1cnNvciA9IG5vZGUgJiYgbm9kZS50eXBlLnNwZWMuZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IHR5cGVvZiBkaXNhYmxlRHJvcEN1cnNvciA9PSBcImZ1bmN0aW9uXCIgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcywgZXZlbnQpIDogZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGlmIChwb3MgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcG9zLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gZHJvcFBvaW50KHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MsIHRhcmdldCwgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMuZWRpdG9yVmlldy5kb20gfHwgIXRoaXMuZWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRyb3BDdXJzb3IgfTtcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERyb3BjdXJzb3JPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgZHJvcCBjdXJzb3JcbiAgICogQGRlZmF1bHQgJ2N1cnJlbnRDb2xvcidcbiAgICogQGV4YW1wbGUgJ3JlZCdcbiAgICovXG4gIGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgZHJvcCBjdXJzb3JcbiAgICogQGRlZmF1bHQgMVxuICAgKiBAZXhhbXBsZSAyXG4gICovXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBvZiB0aGUgZHJvcCBjdXJzb3JcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBleGFtcGxlICdkcm9wLWN1cnNvcidcbiAgKi9cbiAgY2xhc3M6IHN0cmluZyB8IHVuZGVmaW5lZCxcbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGFkZCBhIGRyb3AgY3Vyc29yIHRvIHlvdXIgZWRpdG9yLlxuICogQSBkcm9wIGN1cnNvciBpcyBhIGxpbmUgdGhhdCBhcHBlYXJzIHdoZW4geW91IGRyYWcgYW5kIGRyb3AgY29udGVudFxuICogaW5iZXR3ZWVuIG5vZGVzLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvZHJvcGN1cnNvclxuICovXG5leHBvcnQgY29uc3QgRHJvcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGU8RHJvcGN1cnNvck9wdGlvbnM+KHtcbiAgbmFtZTogJ2Ryb3BDdXJzb3InLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBkcm9wQ3Vyc29yKHRoaXMub3B0aW9ucyksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcblxuLyoqXG5HYXAgY3Vyc29yIHNlbGVjdGlvbnMgYXJlIHJlcHJlc2VudGVkIHVzaW5nIHRoaXMgY2xhc3MuIEl0c1xuYCRhbmNob3JgIGFuZCBgJGhlYWRgIHByb3BlcnRpZXMgYm90aCBwb2ludCBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuKi9cbmNsYXNzIEdhcEN1cnNvciBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZ2FwIGN1cnNvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgc3VwZXIoJHBvcywgJHBvcyk7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHsgcmV0dXJuIFNsaWNlLmVtcHR5OyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgR2FwQ3Vyc29yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZ2FwY3Vyc29yXCIsIHBvczogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBDdXJzb3IoZG9jLnJlc29sdmUoanNvbi5wb3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBHYXBCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyB2YWxpZCgkcG9zKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC5pc1RleHRibG9jayB8fCAhY2xvc2VkQmVmb3JlKCRwb3MpIHx8ICFjbG9zZWRBZnRlcigkcG9zKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gcGFyZW50LnR5cGUuc3BlYy5hbGxvd0dhcEN1cnNvcjtcbiAgICAgICAgaWYgKG92ZXJyaWRlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICAgIGxldCBkZWZsdCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkcG9zLmluZGV4KCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmRHYXBDdXJzb3JGcm9tKCRwb3MsIGRpciwgbXVzdE1vdmUgPSBmYWxzZSkge1xuICAgICAgICBzZWFyY2g6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghbXVzdE1vdmUgJiYgR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zO1xuICAgICAgICAgICAgbGV0IHBvcyA9ICRwb3MucG9zLCBuZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFNjYW4gdXAgZnJvbSB0aGlzIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgPCBwYXJlbnQuY2hpbGRDb3VudCA6ICRwb3MuaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwYXJlbnQuY2hpbGQoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA6ICRwb3MuaW5kZXgoZCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuZCB0aGVuIGRvd24gaW50byB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gaW5zaWRlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkdhcEN1cnNvci5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuR2FwQ3Vyc29yLmZpbmRGcm9tID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tO1xuU2VsZWN0aW9uLmpzb25JRChcImdhcGN1cnNvclwiLCBHYXBDdXJzb3IpO1xuY2xhc3MgR2FwQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKHBvcykge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIC8vIEF0IHRoZSBzdGFydCBvZiB0aGlzIHBhcmVudCwgbG9vayBhdCBuZXh0IG9uZVxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHRoZSBub2RlIGJlZm9yZSAob3IgaXRzIGZpcnN0IGFuY2VzdG9yKSBpcyBjbG9zZWRcbiAgICAgICAgZm9yIChsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBiZWZvcmUuaXNBdG9tIHx8IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSBwYXJlbnQuY2hpbGQoaW5kZXgpOzsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCkgfHwgYWZ0ZXIuaXNBdG9tIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQ3JlYXRlIGEgZ2FwIGN1cnNvciBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGNhcHR1cmUgY2xpY2tzXG5uZWFyIGFuZCBhcnJvdy1rZXktbW90aW9uIHBhc3QgcGxhY2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIG5vcm1hbGx5XG5zZWxlY3RhYmxlIHBvc2l0aW9uIG5lYXJieSwgYW5kIGNyZWF0ZSBhIGdhcCBjdXJzb3Igc2VsZWN0aW9uIGZvclxudGhlbS4gVGhlIGN1cnNvciBpcyBkcmF3biBhcyBhbiBlbGVtZW50IHdpdGggY2xhc3NcbmBQcm9zZU1pcnJvci1nYXBjdXJzb3JgLiBZb3UgY2FuIGVpdGhlciBpbmNsdWRlXG5gc3R5bGUvZ2FwY3Vyc29yLmNzc2AgZnJvbSB0aGUgcGFja2FnZSdzIGRpcmVjdG9yeSBvciBhZGQgeW91ciBvd25cbnN0eWxlcyB0byBtYWtlIGl0IHZpc2libGUuXG4qL1xuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbihfdmlldywgJGFuY2hvciwgJGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7IGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dCB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gICAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gICAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gICAgXCJBcnJvd1VwXCI6IGFycm93KFwidmVydFwiLCAtMSksXG4gICAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyAoZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiKSA6IChkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCAkc3RhcnQgPSBkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSwgbXVzdE1vdmUgPSBzZWwuZW1wdHk7XG4gICAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSB8fCAkc3RhcnQuZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgICAgIGlmICghJGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkZm91bmQpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3LmVkaXRhYmxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2xpY2tQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRoaXMgaXMgYSBoYWNrIHRoYXQsIHdoZW4gYSBjb21wb3NpdGlvbiBzdGFydHMgd2hpbGUgYSBnYXAgY3Vyc29yXG4vLyBpcyBhY3RpdmUsIHF1aWNrbHkgY3JlYXRlcyBhbiBpbmxpbmUgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvXG4vLyBoYXBwZW4gaW4sIHRvIGF2b2lkIGl0IGJlaW5nIGFib3J0ZWQgYnkgdGhlIERPTSBzZWxlY3Rpb24gYmVpbmdcbi8vIG1vdmVkIGludG8gYSB2YWxpZCBwb3NpdGlvbi5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSAhPSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiIHx8ICEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICAgIGlmICghaW5zZXJ0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZyYWcgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBmcmFnID0gRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgU2xpY2UoZnJhZywgMCwgMCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSkpKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gICAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHsga2V5OiBcImdhcGN1cnNvclwiIH0pXSk7XG59XG5cbmV4cG9ydCB7IEdhcEN1cnNvciwgZ2FwQ3Vyc29yIH07XG4iLCAiaW1wb3J0IHtcbiAgY2FsbE9yUmV0dXJuLFxuICBFeHRlbnNpb24sXG4gIGdldEV4dGVuc2lvbkZpZWxkLFxuICBQYXJlbnRDb25maWcsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZ2FwY3Vyc29yJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+IHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBnYXAgY3Vyc29yIGlzIGFsbG93ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uIE11c3QgcmV0dXJuIGB0cnVlYCBvciBgZmFsc2VgLlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBhbGxvd0dhcEN1cnNvcj86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgbnVsbFxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBvcHRpb25zOiBPcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnM+PlsnYWxsb3dHYXBDdXJzb3InXSxcbiAgICAgIH0pID0+IGJvb2xlYW4gfCBudWxsKSxcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZ2FwIGN1cnNvciB0byB5b3VyIGVkaXRvci5cbiAqIEEgZ2FwIGN1cnNvciBpcyBhIGN1cnNvciB0aGF0IGFwcGVhcnMgd2hlbiB5b3UgY2xpY2sgb24gYSBwbGFjZVxuICogd2hlcmUgbm8gY29udGVudCBpcyBwcmVzZW50LCBmb3IgZXhhbXBsZSBpbmJldHdlZW4gbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9nYXBjdXJzb3JcbiAqL1xuZXhwb3J0IGNvbnN0IEdhcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZ2FwQ3Vyc29yJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGdhcEN1cnNvcigpLFxuICAgIF1cbiAgfSxcblxuICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFsbG93R2FwQ3Vyc29yOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWxsb3dHYXBDdXJzb3InLCBjb250ZXh0KSkgPz8gbnVsbCxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBIYXJkQnJlYWtPcHRpb25zIHtcbiAgLyoqXG4gICAqIENvbnRyb2xzIGlmIG1hcmtzIHNob3VsZCBiZSBrZXB0IGFmdGVyIGJlaW5nIHNwbGl0IGJ5IGEgaGFyZCBicmVhay5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAga2VlcE1hcmtzOiBib29sZWFuLFxuXG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBoYXJkIGJyZWFrIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGFyZEJyZWFrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIGhhcmQgYnJlYWtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKVxuICAgICAgICovXG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBpbnNlcnQgaGFyZCBicmVha3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hhcmQtYnJlYWtcbiAqL1xuZXhwb3J0IGNvbnN0IEhhcmRCcmVhayA9IE5vZGUuY3JlYXRlPEhhcmRCcmVha09wdGlvbnM+KHtcbiAgbmFtZTogJ2hhcmRCcmVhaycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VlcE1hcmtzOiB0cnVlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBpbmxpbmU6IHRydWUsXG5cbiAgZ3JvdXA6ICdpbmxpbmUnLFxuXG4gIHNlbGVjdGFibGU6IGZhbHNlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdicicgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydicicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV1cbiAgfSxcblxuICByZW5kZXJUZXh0KCkge1xuICAgIHJldHVybiAnXFxuJ1xuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+ICh7XG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmZpcnN0KFtcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3NcbiAgICAgICAgICAgICAgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxuICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgICAnU2hpZnQtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgInZhciBHT09EX0xFQUZfU0laRSA9IDIwMDtcblxuLy8gOjogY2xhc3M8VD4gQSByb3BlIHNlcXVlbmNlIGlzIGEgcGVyc2lzdGVudCBzZXF1ZW5jZSBkYXRhIHN0cnVjdHVyZVxuLy8gdGhhdCBzdXBwb3J0cyBhcHBlbmRpbmcsIHByZXBlbmRpbmcsIGFuZCBzbGljaW5nIHdpdGhvdXQgZG9pbmcgYVxuLy8gZnVsbCBjb3B5LiBJdCBpcyByZXByZXNlbnRlZCBhcyBhIG1vc3RseS1iYWxhbmNlZCB0cmVlLlxudmFyIFJvcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIFJvcGVTZXF1ZW5jZSAoKSB7fTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgb3RoZXIgPSBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcik7XG5cbiAgcmV0dXJuICghdGhpcy5sZW5ndGggJiYgb3RoZXIpIHx8XG4gICAgKG90aGVyLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIHRoaXMubGVhZkFwcGVuZChvdGhlcikpIHx8XG4gICAgKHRoaXMubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgb3RoZXIubGVhZlByZXBlbmQodGhpcykpIHx8XG4gICAgdGhpcy5hcHBlbmRJbm5lcihvdGhlcilcbn07XG5cbi8vIDo6ICh1bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIFByZXBlbmQgYW4gYXJyYXkgb3Igb3RoZXIgcm9wZSB0byB0aGlzIG9uZSwgcmV0dXJuaW5nIGEgbmV3IHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcikuYXBwZW5kKHRoaXMpXG59O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxufTtcblxuLy8gOjogKD9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwZXNlbnRpbmcgYSBzdWItc2VxdWVuY2Ugb2YgdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA+PSB0bykgeyByZXR1cm4gUm9wZVNlcXVlbmNlLmVtcHR5IH1cbiAgcmV0dXJuIHRoaXMuc2xpY2VJbm5lcihNYXRoLm1heCgwLCBmcm9tKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSlcbn07XG5cbi8vIDo6IChudW1iZXIpIFx1MjE5MiBUXG4vLyBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgcmV0dXJuIHRoaXMuZ2V0SW5uZXIoaSlcbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyID9ib29sLCA/bnVtYmVyLCA/bnVtYmVyKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHRoZSBnaXZlblxuLy8gaW5kaWNlcy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGxvb3Bpbmcgb3ZlciB0aGVcbi8vIGluZGljZXMgYW5kIGNhbGxpbmcgYGdldGAsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIHRvIGRlc2NlbmQgdGhlXG4vLyB0cmVlIGZvciBldmVyeSBlbGVtZW50LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPD0gdG8pXG4gICAgeyB0aGlzLmZvckVhY2hJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyIFUsID9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBbVV1cbi8vIE1hcCB0aGUgZ2l2ZW4gZnVuY3Rpb25zIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3BlLCBwcm9kdWNpbmdcbi8vIGEgZmxhdCBhcnJheS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWx0LCBpKSB7IHJldHVybiByZXN1bHQucHVzaChmKGVsdCwgaSkpOyB9LCBmcm9tLCB0byk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6ICg/dW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSBcdTIxOTIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVybiB0aGUgcm9wZVxuLy8gaXRzZWxmIGlmIGEgcm9wZSB3YXMgZ2l2ZW4uXG5Sb3BlU2VxdWVuY2UuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlcykge1xuICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUm9wZVNlcXVlbmNlKSB7IHJldHVybiB2YWx1ZXMgfVxuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPyBuZXcgTGVhZih2YWx1ZXMpIDogUm9wZVNlcXVlbmNlLmVtcHR5XG59O1xuXG52YXIgTGVhZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBMZWFmKHZhbHVlcykge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBMZWFmLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBMZWFmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlYWY7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+PSB0bzsgaS0tKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLmNvbmNhdChvdGhlci5mbGF0dGVuKCkpKSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZihvdGhlci5mbGF0dGVuKCkuY29uY2F0KHRoaXMudmFsdWVzKSkgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGVhZi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMZWFmO1xufShSb3BlU2VxdWVuY2UpKTtcblxuLy8gOjogUm9wZVNlcXVlbmNlXG4vLyBUaGUgZW1wdHkgcm9wZSBzZXF1ZW5jZS5cblJvcGVTZXF1ZW5jZS5lbXB0eSA9IG5ldyBMZWFmKFtdKTtcblxudmFyIEFwcGVuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBBcHBlbmQobGVmdCwgcmlnaHQpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoO1xuICAgIHRoaXMuZGVwdGggPSBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCkgKyAxO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBBcHBlbmQuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBBcHBlbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgQXBwZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFwcGVuZDtcblxuICBBcHBlbmQucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmZsYXR0ZW4oKS5jb25jYXQodGhpcy5yaWdodC5mbGF0dGVuKCkpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlZnQubGVuZ3RoID8gdGhpcy5sZWZ0LmdldChpKSA6IHRoaXMucmlnaHQuZ2V0KGkgLSB0aGlzLmxlZnQubGVuZ3RoKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgTWF0aC5taW4odG8sIGxlZnRMZW4pLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW5uZXIoZiwgTWF0aC5tYXgoZnJvbSAtIGxlZnRMZW4sIDApLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSAtIGxlZnRMZW4sIE1hdGgubWF4KHRvLCBsZWZ0TGVuKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIE1hdGgubWluKGZyb20sIGxlZnRMZW4pLCB0bywgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAodG8gPD0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIHRvKSB9XG4gICAgaWYgKGZyb20gPj0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5yaWdodC5zbGljZShmcm9tIC0gbGVmdExlbiwgdG8gLSBsZWZ0TGVuKSB9XG4gICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCBsZWZ0TGVuKS5hcHBlbmQodGhpcy5yaWdodC5zbGljZSgwLCB0byAtIGxlZnRMZW4pKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5yaWdodC5sZWFmQXBwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBpbm5lcikgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLmxlZnQubGVhZlByZXBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZChpbm5lciwgdGhpcy5yaWdodCkgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZWZ0LmRlcHRoID49IE1hdGgubWF4KHRoaXMucmlnaHQuZGVwdGgsIG90aGVyLmRlcHRoKSArIDEpXG4gICAgICB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgbmV3IEFwcGVuZCh0aGlzLnJpZ2h0LCBvdGhlcikpIH1cbiAgICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbiAgfTtcblxuICByZXR1cm4gQXBwZW5kO1xufShSb3BlU2VxdWVuY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgUm9wZVNlcXVlbmNlO1xuIiwgImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIFx1MjAxNCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2VsZWN0aW9uID0gcG9wLnNlbGVjdGlvbi5yZXNvbHZlKHBvcC50cmFuc2Zvcm0uZG9jKTtcbiAgICBsZXQgYWRkZWQgPSAocmVkbyA/IGhpc3RvcnkuZG9uZSA6IGhpc3RvcnkudW5kb25lKS5hZGRUcmFuc2Zvcm0ocG9wLnRyYW5zZm9ybSwgc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCksIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBsZXQgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCwgLTEpO1xuICAgIHJldHVybiBwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRDb21tYW5kKHJlZG8sIHNjcm9sbCkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmICghaGlzdCB8fCAocmVkbyA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lKS5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCByZWRvKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzY3JvbGwgPyB0ci5zY3JvbGxJbnRvVmlldygpIDogdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHVuZG9lcyB0aGUgbGFzdCBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCB1bmRvID0gYnVpbGRDb21tYW5kKGZhbHNlLCB0cnVlKTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gYnVpbGRDb21tYW5kKHRydWUsIHRydWUpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLiBEb24ndCBzY3JvbGwgdGhlXG5zZWxlY3Rpb24gaW50byB2aWV3LlxuKi9cbmNvbnN0IHVuZG9Ob1Njcm9sbCA9IGJ1aWxkQ29tbWFuZChmYWxzZSwgZmFsc2UpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZS4gRG9uJ3RcbnNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlldy5cbiovXG5jb25zdCByZWRvTm9TY3JvbGwgPSBidWlsZENvbW1hbmQodHJ1ZSwgZmFsc2UpO1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgcmVkb05vU2Nyb2xsLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9Ob1Njcm9sbCB9O1xuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGhpc3RvcnksIHJlZG8sIHVuZG8gfSBmcm9tICdAdGlwdGFwL3BtL2hpc3RvcnknXG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBoaXN0b3J5IGV2ZW50cyB0aGF0IGFyZSBjb2xsZWN0ZWQgYmVmb3JlIHRoZSBvbGRlc3QgZXZlbnRzIGFyZSBkaXNjYXJkZWQuXG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKiBAZXhhbXBsZSA1MFxuICAgKi9cbiAgZGVwdGg6IG51bWJlcixcblxuICAvKipcbiAgICogVGhlIGRlbGF5IChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gY2hhbmdlcyBhZnRlciB3aGljaCBhIG5ldyBncm91cCBzaG91bGQgYmUgc3RhcnRlZC5cbiAgICogQGRlZmF1bHQgNTAwXG4gICAqIEBleGFtcGxlIDEwMDBcbiAgICovXG4gIG5ld0dyb3VwRGVsYXk6IG51bWJlcixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhpc3Rvcnk6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyByZWNlbnQgY2hhbmdlc1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVuZG8oKVxuICAgICAgICovXG4gICAgICB1bmRvOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBSZWFwcGx5IHJldmVydGVkIGNoYW5nZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5yZWRvKClcbiAgICAgICAqL1xuICAgICAgcmVkbzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIHVuZG8gYW5kIHJlZG8gcmVjZW50IGNoYW5nZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvaGlzdG9yeVxuICpcbiAqICoqSW1wb3J0YW50Kio6IElmIHRoZSBgQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbmAgcGFja2FnZSBpcyB1c2VkLCBtYWtlIHN1cmUgdG8gcmVtb3ZlXG4gKiB0aGUgYGhpc3RvcnlgIGV4dGVuc2lvbiwgYXMgaXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGNvbGxhYm9yYXRpb25gIGV4dGVuc2lvbi5cbiAqXG4gKiBgQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbmAgdXNlcyBpdHMgb3duIGhpc3RvcnkgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBIaXN0b3J5ID0gRXh0ZW5zaW9uLmNyZWF0ZTxIaXN0b3J5T3B0aW9ucz4oe1xuICBuYW1lOiAnaGlzdG9yeScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwdGg6IDEwMCxcbiAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB1bmRvKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0sXG4gICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGhpc3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICdTaGlmdC1Nb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICdNb2QteSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcblxuICAgICAgLy8gUnVzc2lhbiBrZXlib2FyZCBsYXlvdXRzXG4gICAgICAnTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgJ1NoaWZ0LU1vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXJhZ3JhcGhPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIGEgcGFyYWdyYXBoIG5vZGUuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgcGFyYWdyYXBoOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHBhcmFncmFwaFxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVBhcmFncmFwaCgpXG4gICAgICAgKi9cbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBwYXJhZ3JhcGhzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9wYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlPFBhcmFncmFwaE9wdGlvbnM+KHtcbiAgbmFtZTogJ3BhcmFncmFwaCcsXG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ3AnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUFsdC0wJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0UGFyYWdyYXBoKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRleHQgbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RleHRcbiAqL1xuZXhwb3J0IGNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6ICd0ZXh0JyxcbiAgZ3JvdXA6ICdpbmxpbmUnLFxufSlcbiIsICJpbXBvcnQge1xuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgTWFyayxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFN0eWxlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBzcGFuIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBzcGFucyB3aXRob3V0IGlubGluZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnJlbW92ZUVtcHR5VGV4dFN0eWxlKClcbiAgICAgICAqL1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdGV4dCBzdHlsZXMuIEl0IGlzIHJlcXVpcmVkIGJ5IGRlZmF1bHRcbiAqIGZvciB0aGUgYHRleHRDb2xvcmAgYW5kIGBiYWNrZ3JvdW5kQ29sb3JgIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3RleHQtc3R5bGVcbiAqL1xuZXhwb3J0IGNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlPFRleHRTdHlsZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3RleHRTdHlsZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIGdldEF0dHJzOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaGFzQXR0cmlidXRlKCdzdHlsZScpXG5cbiAgICAgICAgICBpZiAoIWhhc1N0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3NwYW4nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSlcbiAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuc29tZSgoWywgdmFsdWVdKSA9PiAhIXZhbHVlKVxuXG4gICAgICAgIGlmIChoYXNTdHlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbi8qKlxuICogVGhlIGhlYWRpbmcgbGV2ZWwgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IHR5cGUgTGV2ZWwgPSAxIHwgMiB8IDMgfCA0IHwgNSB8IDZcblxuZXhwb3J0IGludGVyZmFjZSBIZWFkaW5nT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYXZhaWxhYmxlIGhlYWRpbmcgbGV2ZWxzLlxuICAgKiBAZGVmYXVsdCBbMSwgMiwgMywgNCwgNSwgNl1cbiAgICogQGV4YW1wbGUgWzEsIDIsIDNdXG4gICAqL1xuICBsZXZlbHM6IExldmVsW10sXG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIGEgaGVhZGluZyBub2RlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhlYWRpbmc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgaGVhZGluZyBub2RlXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgaGVhZGluZyBhdHRyaWJ1dGVzXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0SGVhZGluZyh7IGxldmVsOiAxIH0pXG4gICAgICAgKi9cbiAgICAgIHNldEhlYWRpbmc6IChhdHRyaWJ1dGVzOiB7IGxldmVsOiBMZXZlbCB9KSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBoZWFkaW5nIG5vZGVcbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBoZWFkaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVIZWFkaW5nKHsgbGV2ZWw6IDEgfSlcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlSGVhZGluZzogKGF0dHJpYnV0ZXM6IHsgbGV2ZWw6IExldmVsIH0pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaGVhZGluZ3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hlYWRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IEhlYWRpbmcgPSBOb2RlLmNyZWF0ZTxIZWFkaW5nT3B0aW9ucz4oe1xuICBuYW1lOiAnaGVhZGluZycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBbMSwgMiwgMywgNCwgNSwgNl0sXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdpbmxpbmUqJyxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHNcbiAgICAgIC5tYXAoKGxldmVsOiBMZXZlbCkgPT4gKHtcbiAgICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgICAgYXR0cnM6IHsgbGV2ZWwgfSxcbiAgICAgIH0pKVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgaGFzTGV2ZWwgPSB0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKG5vZGUuYXR0cnMubGV2ZWwpXG4gICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbFxuICAgICAgPyBub2RlLmF0dHJzLmxldmVsXG4gICAgICA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF1cblxuICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5yZWR1Y2UoKGl0ZW1zLCBsZXZlbCkgPT4gKHtcbiAgICAgIC4uLml0ZW1zLFxuICAgICAgLi4ue1xuICAgICAgICBbYE1vZC1BbHQtJHtsZXZlbH1gXTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGVhZGluZyh7IGxldmVsIH0pLFxuICAgICAgfSxcbiAgICB9KSwge30pXG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAobGV2ZWwgPT4ge1xuICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKGBeKCN7MSwke2xldmVsfX0pXFxcXHMkYCksXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczoge1xuICAgICAgICAgIGxldmVsLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBCb2xkT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBib2xkIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYm9sZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBib2xkIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYCoqYCBhcyBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC9cblxuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYCoqYCB3aGlsZSBwYXN0aW5nLlxuICovXG5leHBvcnQgY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkvZ1xuXG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgX19gIGFzIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKSQvXG5cbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGBfX2Agd2hpbGUgcGFzdGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfXyg/IVxccytfXykoKD86W15fXSspKV9fKD8hXFxzK19fKSkvZ1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gbWFyayB0ZXh0IGFzIGJvbGQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbWFya3MvYm9sZFxuICovXG5leHBvcnQgY29uc3QgQm9sZCA9IE1hcmsuY3JlYXRlPEJvbGRPcHRpb25zPih7XG4gIG5hbWU6ICdib2xkJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdHJvbmcnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnYicsXG4gICAgICAgIGdldEF0dHJzOiBub2RlID0+IChub2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXG4gICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUgYXMgc3RyaW5nKSAmJiBudWxsLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdHJvbmcnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICAnTW9kLUInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0YWxpY09wdGlvbnMge1xuICAvKipcbiAgICogSFRNTCBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgaXRhbGljIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpdGFsaWM6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0SXRhbGljKClcbiAgICAgICAqL1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKVxuICAgICAgICovXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRJdGFsaWMoKVxuICAgICAgICovXG4gICAgICB1bnNldEl0YWxpYzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhICppdGFsaWMqIG9uIGlucHV0LlxuICovXG5leHBvcnQgY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkL1xuXG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgKml0YWxpYyogb24gcGFzdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nXG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvXG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBwYXN0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nXG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaXRhbGljIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL2l0YWxpY1xuICovXG5leHBvcnQgY29uc3QgSXRhbGljID0gTWFyay5jcmVhdGU8SXRhbGljT3B0aW9ucz4oe1xuICBuYW1lOiAnaXRhbGljJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdlbScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdpJyxcbiAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gKG5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmZvbnRTdHlsZSAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAnZm9udC1zdHlsZT1pdGFsaWMnLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydlbScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtaSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgJ01vZC1JJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7RWRpdG9yfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgRG9jdW1lbnQgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50XCI7XG5pbXBvcnQgRHJvcGN1cnNvciBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvclwiO1xuaW1wb3J0IEdhcGN1cnNvciBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yXCI7XG5pbXBvcnQgSGFyZEJyZWFrIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrXCI7XG5pbXBvcnQgSGlzdG9yeSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeVwiO1xuaW1wb3J0IFBhcmFncmFwaCBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoXCI7XG5pbXBvcnQgVGV4dCBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dFwiO1xuaW1wb3J0IFRleHRTdHlsZSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZVwiO1xuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcnXG5pbXBvcnQgeyBCb2xkIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYm9sZCdcbmltcG9ydCB7IEl0YWxpYyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NyaWJibGVGb3JtQ29tcG9uZW50KHtcbiAgICBzdGF0ZSxcbiAgICBzdGF0ZVBhdGgsXG4gICAgZGlzYWJsZWQsXG4gICAgdG9vbGJhciA9IFtdLFxufSkge1xuICAgIGxldCBlZGl0b3I7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgc3RhdGVQYXRoOiBzdGF0ZVBhdGgsXG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgdG9vbGJhcjogdG9vbGJhcixcbiAgICAgICAgZWRpdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvclxuICAgICAgICB9LFxuICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzXG5cbiAgICAgICAgICAgIGVkaXRvciA9IG5ldyBFZGl0b3Ioe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuJHJlZnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBUZXh0LFxuICAgICAgICAgICAgICAgICAgICBQYXJhZ3JhcGgsXG4gICAgICAgICAgICAgICAgICAgIERyb3BjdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgIEdhcGN1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgSGFyZEJyZWFrLFxuICAgICAgICAgICAgICAgICAgICBIaXN0b3J5LFxuICAgICAgICAgICAgICAgICAgICBUZXh0U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIEhlYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIEJvbGQsXG4gICAgICAgICAgICAgICAgICAgIEl0YWxpYyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgb25DcmVhdGUoeyBlZGl0b3IgfSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVkQXQgPSBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSh7IGVkaXRvciB9KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZWRBdCA9IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uVXBkYXRlKHsgZWRpdG9yIH0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGlzQWN0aXZlKHR5cGUsIG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvci5pc0FjdGl2ZSh0eXBlLCBvcHRzKVxuICAgICAgICB9LFxuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7QUFFQSxTQUFTLFdBQVcsU0FBUztBQUMzQixPQUFLLFVBQVU7QUFDakI7QUFFQSxXQUFXLFlBQVk7QUFBQSxFQUNyQixhQUFhO0FBQUEsRUFFYixNQUFNLFNBQVMsS0FBSztBQUNsQixhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxRQUFRLEtBQUs7QUFDNUMsVUFBSSxLQUFLLFFBQVEsQ0FBQyxNQUFNO0FBQUssZUFBTztBQUN0QyxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsS0FBSyxTQUFTLEtBQUs7QUFDakIsUUFBSUEsU0FBUSxLQUFLLEtBQUssR0FBRztBQUN6QixXQUFPQSxVQUFTLEtBQUssU0FBWSxLQUFLLFFBQVFBLFNBQVEsQ0FBQztBQUFBLEVBQ3pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1BLFFBQVEsU0FBUyxLQUFLLE9BQU8sUUFBUTtBQUNuQyxRQUFJLE9BQU8sVUFBVSxVQUFVLE1BQU0sS0FBSyxPQUFPLE1BQU0sSUFBSTtBQUMzRCxRQUFJQSxTQUFRLEtBQUssS0FBSyxHQUFHLEdBQUcsVUFBVSxLQUFLLFFBQVEsTUFBTTtBQUN6RCxRQUFJQSxVQUFTLElBQUk7QUFDZixjQUFRLEtBQUssVUFBVSxLQUFLLEtBQUs7QUFBQSxJ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Q0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRU8sSUFBSSxRQUFRO0FBQUEsRUFDakIsSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztB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UUFDQSxrQkFBa0IsRUFBRSxRQUFBQSxRQUFPLEdBQUc7QUFDMUIsZ0JBQU0sWUFBWSxLQUFLLElBQUk7QUFBQSxRQUMvQjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFBQSxJQUNBLFNBQVMsTUFBTSxPQUFPLENBQUMsR0FBRztBQUN0QixhQUFPLE9BQU8sU0FBUyxNQUFNLElBQUk7QUFBQSxJQUNyQztBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsiZm91bmQiLCAibWFwIiwgImZyb20iLCAiZmlyc3QiLCAiY29weSIsICJmb3VuZCIsICJzbGljZSIsICJkb2MiLCAiYmFzZSIsICJpIiwgInR5cGUiLCAibmZhIiwgImVkZ2UiLCAiZXhwciIsICJub2RlIiwgInN0YXRlcyIsICJtYXJrIiwgInN0eWxlIiwgIndyYXAiLCAic3BhY2UiLCAiZGVsIiwgImZyb20iLCAibWFwIiwgImRvYyIsICJzbGljZSIsICJwYXJlbnQiLCAiZm91bmQiLCAic3R5bGUiLCAiYmFzZSIsICJpbmRleCIsICJqb2luYWJsZSIsICJmaXJzdCIsICJ3cmFwIiwgIm1hdGNoZXMiLCAibWF0Y2giLCAidHlwZSIsICJjbG9zZSIsICJUcmFuc2Zvcm1FcnJvciIsICJmcm9tIiwgImZvdW5kIiwgImRvYyIsICJtYXAiLCAic2xpY2UiLCAiZnJvbSIsICJkb2MiLCAiZmlyc3QiLCAiZW50ZXIiLCAiYmFzZSIsICJ3cmFwIiwgImNvcHkiLCAiZm91bmQiLCAicHJlTWF0Y2giLCAibWF0Y2hlcyIsICJlbXB0eSIsICJzbGljZSIsICJkb20iLCAiZXZlbnQiLCAiaGFuZGxlcnMiLCAiY3V0IiwgIk5vZGVUeXBlIiwgImkiLCAib2xkT2Zmc2V0IiwgImFuY2hvciIsICJ0ciIsICJzZWwiLCAiZnJvbSIsICJmb3VuZCIsICJwcm9wIiwgIm1hYyIsICJpZSIsICJtYWMiLCAic2hpZnQiLCAibWFwIiwgImNvcHkiLCAiZW1wdHkiLCAibGlmdCIsICJmaXJzdCIsICJ3cmFwIiwgInNldEJsb2NrVHlwZSIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hYyIsICJ3cmFwIiwgImZvdW5kIiwgImZpcnN0IiwgInNsaWNlIiwgImRvYyIsICJjb21tYW5kIiwgInJ1biIsICJfYSIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hdGNoZXMiLCAiaGFuZGxlcnMiLCAidG8iLCAiTWFyayIsICJyYW5nZSIsICJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwgIm9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciIsICJkZWxldGVSYW5nZSIsICJkZWxldGVTZWxlY3Rpb24iLCAib3JpZ2luYWxEZWxldGVTZWxlY3Rpb24iLCAiZXhpdENvZGUiLCAib3JpZ2luYWxFeGl0Q29kZSIsICJrZXlzIiwgInNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIiwgIm1hcCIsICJqb2luVXAiLCAib3JpZ2luYWxKb2luVXAiLCAiam9pbkRvd24iLCAib3JpZ2luYWxKb2luRG93biIsICJqb2luQmFja3dhcmQiLCAib3JpZ2luYWxKb2luQmFja3dhcmQiLCAiam9pbkZvcndhcmQiLCAib3JpZ2luYWxKb2luRm9yd2FyZCIsICJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCAib3JpZ2luYWxDb21tYW5kIiwgImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwgIm5vcm1hbGl6ZUtleU5hbWUiLCAic2hpZnQiLCAiZW1wdHkiLCAibGlmdCIsICJpc0FjdGl2ZSIsICJvcmlnaW5hbExpZnQiLCAibGlmdEVtcHR5QmxvY2siLCAib3JpZ2luYWxMaWZ0RW1wdHlCbG9jayIsICJsaWZ0TGlzdEl0ZW0iLCAib3JpZ2luYWxMaWZ0TGlzdEl0ZW0iLCAibmV3bGluZUluQ29kZSIsICJvcmlnaW5hbE5ld2xpbmVJbkNvZGUiLCAic2VsZWN0QWxsIiwgInNlbGVjdE5vZGVCYWNrd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCIsICJzZWxlY3ROb2RlRm9yd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIiwgInNlbGVjdFBhcmVudE5vZGUiLCAib3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIiwgInNlbGVjdFRleHRibG9ja0VuZCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCIsICJzZWxlY3RUZXh0YmxvY2tTdGFydCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IiwgImRvY3VtZW50IiwgImRlZmF1bHRCbG9ja0F0IiwgImdldFRleHQiLCAiZnJvbSIsICJub2RlIiwgImZyb20iLCAiZG9jIiwgImVtcHR5IiwgImZyb20iLCAicmFuZ2UiLCAiZW1wdHkiLCAiZnJvbSIsICJjb21tYW5kcyIsICJzZXRCbG9ja1R5cGUiLCAiZG9jIiwgInNpbmtMaXN0SXRlbSIsICJvcmlnaW5hbFNpbmtMaXN0SXRlbSIsICJzcGxpdEJsb2NrIiwgImRlZmF1bHRCbG9ja0F0IiwgImZpcnN0IiwgIndyYXAiLCAibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwgIm5leHRUeXBlIiwgImlzQWN0aXZlIiwgIndyYXBJbiIsICJvcmlnaW5hbFdyYXBJbiIsICJ3cmFwSW5MaXN0IiwgIm9yaWdpbmFsV3JhcEluTGlzdCIsICJmcm9tIiwgInN0eWxlIiwgImRvYyIsICJmb2N1cyIsICJibHVyIiwgImdldFRleHQiLCAiTWFyayIsICJyZW1vdmVNYXJrIiwgIk5vZGUiLCAiTm9kZSIsICJyZWN0IiwgImRvYyIsICJOb2RlIiwgImNvbW1hbmRzIiwgIlJvcGVTZXF1ZW5jZSIsICJmcm9tIiwgImZvckVhY2giLCAiTGVhZiIsICJBcHBlbmQiLCAiYXBwZW5kSW5uZXIiLCAiZGlzdF9kZWZhdWx0IiwgIm1hcCIsICJmcm9tIiwgImRpc3RfZGVmYXVsdCIsICJoaXN0b3J5IiwgInJlZG8iLCAiY29tbWFuZCIsICJyZWRvIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiTWFyayIsICJjb21tYW5kcyIsICJzdGFySW5wdXRSZWdleCIsICJzdGFyUGFzdGVSZWdleCIsICJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsICJ1bmRlcnNjb3JlUGFzdGVSZWdleCIsICJNYXJrIiwgImNvbW1hbmRzIiwgImVkaXRvciJdCn0K
